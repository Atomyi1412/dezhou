<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¾·å·æ‰‘å…‹ç‰Œå‹è®¡ç®—å™¨</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 900px;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        /* Card Selector Styles */
        .card-selectors {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .card-input-group {
            display: flex;
            flex-direction: column;
            width: 120px;
            position: relative;
        }

        .card-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
            text-align: center;
        }

        .card-select-trigger {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 42px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .card-select-trigger:hover {
            border-color: #007bff;
        }

        .card-select-trigger.filled {
            background-color: #e3f2fd;
            border-color: #90caf9;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            width: 200px;
            max-height: 300px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            display: none;
            overflow-y: auto;
            padding: 5px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .search-box {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #eee;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .card-option {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s;
        }

        .card-option:hover {
            background-color: #f5f5f5;
        }

        .card-option.selected {
            background-color: #e3f2fd;
        }
        
        .action-area {
            text-align: center;
            margin: 20px 0;
        }

        button {
            padding: 12px 40px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        .card {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 4px;
            background: #fff;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .suit-red { color: #d9534f; }
        .suit-black { color: #292b2c; }
        .error-msg {
            color: #d9534f;
            margin-top: 10px;
            display: none;
            text-align: center;
        }

        /* Modal Styles */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.5); 
            backdrop-filter: blur(2px);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto; 
            padding: 25px;
            border: 1px solid #888;
            width: 90%; 
            max-width: 600px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            position: relative;
            animation: modalFadeIn 0.3s;
        }

        @keyframes modalFadeIn {
            from {opacity: 0; transform: translateY(-20px);}
            to {opacity: 1; transform: translateY(0);}
        }

        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close-modal:hover,
        .close-modal:focus {
            color: #333;
            text-decoration: none;
            cursor: pointer;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .btn-secondary {
            background-color: #6c757d;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }

        /* Mobile Optimization */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }
            h1 {
                font-size: 24px;
                margin-bottom: 20px;
            }
            
            /* Stack inputs */
            .input-group {
                flex-direction: column !important;
            }
            #serialInput, #teamInput {
                width: 100% !important;
                box-sizing: border-box;
            }
            
            /* Compact Card Selectors */
            .card-selectors {
                gap: 5px;
                justify-content: space-between;
            }
            .card-input-group {
                width: 19%;
                min-width: 0; /* Allow shrinking */
            }
            .card-label {
                font-size: 12px;
            }
            .card-select-trigger {
                padding: 5px 2px;
                font-size: 12px;
                min-height: 40px;
            }
            .card {
                padding: 1px 4px; /* Smaller cards in selector */
                font-size: 12px;
                margin-right: 0;
            }
            
            /* Table Scroll */
            .table-responsive {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            table {
                min-width: 600px; /* Force scroll */
            }
            th, td {
                padding: 8px 5px;
                font-size: 13px;
                white-space: nowrap;
            }
            
            /* Modal adjust */
            .modal-content {
                width: 95%;
                margin: 10% auto;
                padding: 15px;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>å¾·å·æ‰‘å…‹ç‰Œå‹è®¡ç®—å™¨</h1>
    
    <div class="toolbar">
        <button onclick="openModal('settingsModal')" class="btn-secondary" style="padding: 8px 20px;">âš™ï¸ è®¾ç½®</button>
        <button onclick="openModal('importModal')" class="btn-secondary" style="padding: 8px 20px;">ğŸ“‚ æ‰¹é‡å¯¼å…¥</button>
    </div>

    <div class="input-group" style="margin-bottom: 10px; width: 100%; display: flex; gap: 10px;">
        <input type="text" id="serialInput" placeholder="åºå· (ä¾‹å¦‚: 1)" style="width: 100px; padding: 12px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px;">
        <input type="text" id="teamInput" placeholder="é˜Ÿä¼åç§°" style="flex: 1; padding: 12px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px;">
    </div>
    
    <div class="input-group" style="margin-bottom: 20px; width: 100%; display: flex; gap: 10px;">
        <input type="text" id="cardInput" placeholder="è¾“å…¥5å¼ ç‰Œ (ä¾‹å¦‚: â™ A â™¥K â™£Q â™¦J â™ 10 æˆ– As Kh Qc Jd Ts)" style="flex: 1; padding: 12px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px;">
    </div>

    <div class="card-selectors">
        <!-- Generate 5 card inputs -->
        <div class="card-input-group" id="group1">
            <div class="card-label">ç‰Œ1</div>
            <div class="card-select-trigger" onclick="toggleDropdown(1)" id="trigger1">... â–¾</div>
            <div class="dropdown-menu" id="dropdown1">
                <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(1)" onclick="event.stopPropagation()">
                <div class="card-options-list" id="list1"></div>
            </div>
        </div>
        <div class="card-input-group" id="group2">
            <div class="card-label">ç‰Œ2</div>
            <div class="card-select-trigger" onclick="toggleDropdown(2)" id="trigger2">... â–¾</div>
            <div class="dropdown-menu" id="dropdown2">
                <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(2)" onclick="event.stopPropagation()">
                <div class="card-options-list" id="list2"></div>
            </div>
        </div>
        <div class="card-input-group" id="group3">
            <div class="card-label">ç‰Œ3</div>
            <div class="card-select-trigger" onclick="toggleDropdown(3)" id="trigger3">... â–¾</div>
            <div class="dropdown-menu" id="dropdown3">
                <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(3)" onclick="event.stopPropagation()">
                <div class="card-options-list" id="list3"></div>
            </div>
        </div>
        <div class="card-input-group" id="group4">
            <div class="card-label">ç‰Œ4</div>
            <div class="card-select-trigger" onclick="toggleDropdown(4)" id="trigger4">... â–¾</div>
            <div class="dropdown-menu" id="dropdown4">
                <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(4)" onclick="event.stopPropagation()">
                <div class="card-options-list" id="list4"></div>
            </div>
        </div>
        <div class="card-input-group" id="group5">
            <div class="card-label">ç‰Œ5</div>
            <div class="card-select-trigger" onclick="toggleDropdown(5)" id="trigger5">... â–¾</div>
            <div class="dropdown-menu" id="dropdown5">
                <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(5)" onclick="event.stopPropagation()">
                <div class="card-options-list" id="list5"></div>
            </div>
        </div>
    </div>

    <div class="action-area">
        <button id="actionBtn" onclick="processHand()">è®¡ç®— & æ’å</button>
        <button id="cancelBtn" onclick="cancelEdit()" style="display:none; background-color: #6c757d; margin-left: 10px;">å–æ¶ˆ</button>
    </div>

    <div id="errorMsg" class="error-msg"></div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('settingsModal')">&times;</span>
            <h2 style="margin-top: 0; color: #007bff;">è®¾ç½®</h2>
            <div style="margin-top: 20px; display: flex; align-items: center; gap: 10px;">
                <label for="totalTeamsInput">æŠ¥åé˜Ÿä¼æ€»æ•°:</label>
                <input type="number" id="totalTeamsInput" value="49" min="1" style="padding: 8px; border: 1px solid #ccc; border-radius: 3px; width: 100px;" onchange="updateTotalTeams()">
                <span style="color: #666; font-size: 14px;">(ç”¨äºè®¡ç®—ç§¯åˆ†ï¼Œç¬¬1åè·å¾—æ­¤åˆ†æ•°)</span>
            </div>
        </div>
    </div>

    <!-- Bulk Import Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('importModal')">&times;</span>
            <h2 style="margin-top: 0; color: #007bff;">æ‰¹é‡å¯¼å…¥ (Excel/CSV)</h2>
            
            <div style="margin-top: 20px;">
                <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border: 1px dashed #ccc; border-radius: 5px;">
                    <p style="margin: 0 0 10px 0; font-size: 14px; font-weight: bold;">ä¸Šä¼ æ–‡ä»¶å¯¼å…¥:</p>
                    <input type="file" id="fileInput" accept=".xlsx, .xls, .csv" onchange="handleFileUpload(event)" style="width: 100%;">
                </div>

                <p style="font-size: 14px; color: #666; margin-bottom: 5px;">æˆ–ç²˜è´´å†…å®¹ (æ ¼å¼: åºå· | é˜Ÿä¼åç§° | ç‰Œé¢)</p>
                <textarea id="bulkInput" rows="10" style="width: 100%; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 5px; font-family: monospace;" placeholder="ä¾‹å¦‚:
1	TeamA	â™ A â™¥K â™£Q â™¦J â™ 10
2	TeamB	As Ks Qs Js Ts"></textarea>
                <div style="margin-top: 15px; text-align: right;">
                    <button onclick="processBulkImport()" style="background-color: #28a745; padding: 10px 30px;">å¼€å§‹å¯¼å…¥</button>
                </div>
            </div>
        </div>
    </div>

    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
        <h2 style="margin: 0;">æ’è¡Œæ¦œ</h2>
        <div>
            <button onclick="exportRanking()" style="background-color: #17a2b8; padding: 8px 20px; font-size: 14px; margin-right: 10px;">å¯¼å‡ºè¡¨æ ¼</button>
            <button onclick="clearData()" style="background-color: #dc3545; padding: 8px 20px; font-size: 14px;">æ¸…ç©ºæ•°æ®</button>
        </div>
    </div>
    <div class="table-responsive">
        <table id="rankingTable">
            <thead>
                <tr>
                    <th>æ’å</th>
                    <th>åºå·</th>
                    <th>é˜Ÿä¼åç§°</th>
                    <th>ç‰Œå‹åç§°</th>
                    <th>ç‰Œé¢</th>
                    <th>ç§¯åˆ†</th>
                    <th>åˆ†æ•°</th>
                    <th>æ“ä½œ</th>
                </tr>
            </thead>
            <tbody>
                <!-- ç»“æœå°†æ’å…¥è¿™é‡Œ -->
            </tbody>
        </table>
    </div>
</div>

<script>
    // ç‰Œé¢å®šä¹‰
    const SUITS = {
        's': 'â™ ', 'S': 'â™ ', 'â™ ': 'â™ ',
        'h': 'â™¥', 'H': 'â™¥', 'â™¥': 'â™¥',
        'c': 'â™£', 'C': 'â™£', 'â™£': 'â™£',
        'd': 'â™¦', 'D': 'â™¦', 'â™¦': 'â™¦'
    };
    
    const RANKS = {
        '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
        'T': 10, 't': 10,
        'J': 11, 'j': 11,
        'Q': 12, 'q': 12,
        'K': 13, 'k': 13,
        'A': 14, 'a': 14
    };

    const RANK_NAMES = {
        2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '10',
        11: 'J', 12: 'Q', 13: 'K', 14: 'A'
    };

    const HAND_TYPES = [
        { name: "é«˜ç‰Œ", value: 1 },
        { name: "å¯¹å­", value: 2 },
        { name: "ä¸¤å¯¹", value: 3 },
        { name: "ä¸‰æ¡", value: 4 },
        { name: "é¡ºå­", value: 5 },
        { name: "åŒèŠ±", value: 6 },
        { name: "è‘«èŠ¦", value: 7 },
        { name: "å››æ¡", value: 8 },
        { name: "åŒèŠ±é¡º", value: 9 },
        { name: "çš‡å®¶åŒèŠ±é¡º", value: 10 }
    ];
    
    // å…¨å±€çŠ¶æ€ï¼šä¿å­˜æ¯ä¸ªä½ç½®é€‰ä¸­çš„ç‰Œ
    // æ ¼å¼: { 1: { suit: 'â™ ', rank: 14, name: 'â™ A' }, ... }
    let selectedCards = {
        1: null, 2: null, 3: null, 4: null, 5: null
    };
    
    let deck = [];
    let totalTeams = 49;

    function updateTotalTeams() {
        const input = document.getElementById('totalTeamsInput');
        const val = parseInt(input.value);
        if (!isNaN(val) && val > 0) {
            totalTeams = val;
            updateTable();
        }
    }

    // åˆå§‹åŒ–
    function init() {
        generateDeck();
        renderDropdowns();
        
        // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰èœå•
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.card-input-group')) {
                closeAllDropdowns();
            }
            // Click outside modal to close
            if (event.target.classList.contains('modal')) {
                event.target.style.display = "none";
            }
        });
    }

    // Modal functions
    function openModal(modalId) {
        document.getElementById(modalId).style.display = "block";
    }

    function closeModal(modalId) {
        document.getElementById(modalId).style.display = "none";
    }

    function generateDeck() {
        const suits = [
            { symbol: 'â™ ', color: 'black', name: 'Spade', chinese: 'é»‘æ¡ƒ', short: 's' },
            { symbol: 'â™¥', color: 'red', name: 'Heart', chinese: 'çº¢æ¡ƒ', short: 'h' },
            { symbol: 'â™£', color: 'black', name: 'Club', chinese: 'æ¢…èŠ±', short: 'c' },
            { symbol: 'â™¦', color: 'red', name: 'Diamond', chinese: 'æ–¹å—', short: 'd' }
        ];
        const ranks = [
            { val: 2, label: '2' }, { val: 3, label: '3' }, { val: 4, label: '4' }, 
            { val: 5, label: '5' }, { val: 6, label: '6' }, { val: 7, label: '7' }, 
            { val: 8, label: '8' }, { val: 9, label: '9' }, { val: 10, label: '10', alias: 't' },
            { val: 11, label: 'J' }, { val: 12, label: 'Q' }, { val: 13, label: 'K' }, { val: 14, label: 'A', alias: '1' }
        ];

        deck = [];
        for (let s of suits) {
            for (let r of ranks) {
                // æ„å»ºæœç´¢å…³é”®è¯
                // ç§»é™¤è‹±æ–‡å…¨ç§°(Spade, Heart...)ï¼Œå› ä¸ºå®ƒä»¬åŒ…å« 'a' ä¼šå¯¼è‡´æœç´¢ 'A' æ—¶åŒ¹é…æ‰€æœ‰ç‰Œ
                // ä¿ç•™: ç¬¦å·(â™ ), ç‚¹æ•°(A), ä¸­æ–‡(é»‘æ¡ƒ), ç®€å†™(s), åˆ«å(t, 1)
                let keys = [
                    `${s.symbol}${r.label}`, // â™ A
                    r.label,                 // A
                    s.chinese,               // é»‘æ¡ƒ
                    s.short,                 // s
                    s.short + r.label,       // sA
                    r.label + s.short        // As
                ];
                if (r.alias) keys.push(r.alias);

                deck.push({
                    suit: s.symbol,
                    rank: r.val,
                    rankLabel: r.label,
                    color: s.color,
                    fullName: `${s.symbol}${r.label}`,
                    searchKey: keys.join(' ').toLowerCase()
                });
            }
        }
    }

    function renderDropdowns() {
        for (let i = 1; i <= 5; i++) {
            const list = document.getElementById(`list${i}`);
            list.innerHTML = '';
            deck.forEach(card => {
                const option = document.createElement('div');
                option.className = 'card-option';
                option.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span>`;
                option.onclick = (e) => {
                    e.stopPropagation();
                    selectCard(i, card);
                };
                // Store card data for filtering
                option.dataset.search = card.searchKey;
                list.appendChild(option);
            });
        }
    }

    function toggleDropdown(index) {
        const dropdown = document.getElementById(`dropdown${index}`);
        const isVisible = dropdown.classList.contains('show');
        
        closeAllDropdowns();
        
        if (!isVisible) {
            dropdown.classList.add('show');
            // Focus search box
            const input = dropdown.querySelector('.search-box');
            input.value = '';
            filterCards(index); // Reset filter
            setTimeout(() => input.focus(), 50);
        }
    }

    function closeAllDropdowns() {
        document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
    }

    function selectCard(index, card) {
        selectedCards[index] = card;
        
        // Update trigger UI
        const trigger = document.getElementById(`trigger${index}`);
        trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> â–¾`;
        trigger.classList.add('filled');
        
        closeAllDropdowns();
        updateTextInput();
    }

    function updateTextInput() {
        const parts = [];
        for (let i = 1; i <= 5; i++) {
            if (selectedCards[i]) {
                parts.push(selectedCards[i].fullName); // Use fullName (e.g., â™ A)
            }
        }
        // Only update if text input is empty or we are syncing from valid dropdowns
        // Actually, better to always sync to show what is selected
        document.getElementById('cardInput').value = parts.join(' ');
    }

    function filterCards(index) {
        const input = document.querySelector(`#dropdown${index} .search-box`);
        const filter = input.value.toLowerCase();
        const list = document.getElementById(`list${index}`);
        const options = list.getElementsByClassName('card-option');

        for (let option of options) {
            const txtValue = option.dataset.search;
            if (txtValue.indexOf(filter) > -1) {
                option.style.display = "";
            } else {
                option.style.display = "none";
            }
        }
    }

    let handHistory = [];
    let currentEditingId = null;

    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Close modal immediately if file is selected (we will process it)
        // Actually, user might want to see the text area populated first?
        // Requirement: "å¦‚æœé€‰æ‹©æ–‡ä»¶å¯¼å…¥æˆåŠŸåè‡ªåŠ¨å…³é—­æ‰¹é‡å¯¼å…¥äºŒçº§æ¡†"
        // So we should close it AFTER success.
        // But here we just read file. The actual import happens in processBulkImport called by reader.onload.
        // Wait, my implementation of reader.onload calls processBulkImport() directly.
        // So processBulkImport will handle closing.

        const reader = new FileReader();
        
        if (file.name.endsWith('.csv')) {
            reader.onload = function(e) {
                const text = e.target.result;
                document.getElementById('bulkInput').value = text;
                processBulkImport(true); // Pass flag to indicate auto-import from file
            };
            reader.readAsText(file);
        } else {
            // Excel
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    
                    // Convert to JSON (array of arrays) to be safe
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                    
                    // Convert to Tab Separated Values for our existing parser
                    // Replace newlines in cell data with space to prevent line breaking
                    const tsv = jsonData.map(row => 
                        row.map(cell => {
                            if (typeof cell === 'string') {
                                return cell.replace(/[\n\r]+/g, ' ');
                            }
                            return cell;
                        }).join('\t')
                    ).join('\n');
                    
                    document.getElementById('bulkInput').value = tsv;
                    processBulkImport(true); // Pass flag to indicate auto-import from file
                } catch (err) {
                    alert('è¯»å–Excelæ–‡ä»¶å¤±è´¥: ' + err.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Reset file input so same file can be selected again if needed
        event.target.value = '';
    }

    function processBulkImport(isFromFile = false) {
        const input = document.getElementById('bulkInput').value.trim();
        if (!input) return;

        // Use a smarter split that respects quotes (standard CSV/TSV behavior) to handle multi-line fields in copy-paste scenarios
        // Regex: Split by newline if not followed by an odd number of quotes
        // But JS doesn't support variable length lookbehind, so we use lookahead for even quotes until end of string.
        // Actually, simple strategy: if a line has unclosed quote, merge with next.
        
        let rawLines = input.split(/\r?\n/);
        const lines = [];
        let currentLine = '';
        let inQuote = false;
        
        for (let line of rawLines) {
            // Count quotes in this line
            const quotes = (line.match(/"/g) || []).length;
            
            if (!inQuote) {
                if (quotes % 2 === 0) {
                    // Balanced, simple line
                    lines.push(line);
                } else {
                    // Unbalanced, start of multi-line
                    currentLine = line;
                    inQuote = true;
                }
            } else {
                currentLine += '\n' + line; // Restore newline
                if (quotes % 2 !== 0) {
                    // Found closing quote (odd number of quotes + previous odd = even)
                    lines.push(currentLine);
                    currentLine = '';
                    inQuote = false;
                }
                // If even quotes, we are still inside multiline quote
            }
        }
        if (currentLine) lines.push(currentLine); // Push remaining if any

        let successCount = 0;
        let errors = [];
        
        // é»˜è®¤åˆ—æ˜ å°„
        let colMap = { id: 0, team: 1, hand: 2 };
        let foundHeader = false;

        lines.forEach((line, index) => {
            line = line.trim();
            if (!line) return;
            
            // Handle CSV/TSV parsing manually to respect quotes
            let parts = [];
            
            if (line.includes('\t')) {
                parts = line.split('\t');
            } else {
                if (line.indexOf('"') === -1) {
                    parts = line.split(/[,ï¼Œ]/);
                } else {
                    parts = line.split(/[,ï¼Œ]/); // Simplified
                }
            }

            // Clean up parts
            parts = parts.map(p => {
                p = p.trim();
                if (p.startsWith('"') && p.endsWith('"')) {
                    p = p.slice(1, -1).replace(/""/g, '"');
                }
                return p;
            });

            parts = parts.map(p => p.replace(/[\n\r]+/g, ' '));
            
            // è¯†åˆ«è¡¨å¤´å¹¶åŠ¨æ€æ˜ å°„åˆ—
            if (index === 0) {
                let tempMap = {};
                let headerFound = false;
                
                parts.forEach((col, i) => {
                    const c = col.toLowerCase();
                    if (c.includes('åºå·') || c === 'id' || c === 'no') tempMap.id = i;
                    else if (c.includes('é˜Ÿä¼') || c.includes('team') || c === 'name') tempMap.team = i;
                    else if (c.includes('ç‰Œé¢') || c.includes('cards') || c === 'hand') tempMap.hand = i;
                });

                // å¦‚æœè‡³å°‘æ‰¾åˆ° åºå·+é˜Ÿä¼ æˆ– é˜Ÿä¼+ç‰Œé¢ï¼Œåˆ™è®¤ä¸ºæ˜¯è¡¨å¤´
                if ((tempMap.id !== undefined && tempMap.team !== undefined) || 
                    (tempMap.team !== undefined && tempMap.hand !== undefined)) {
                    
                    colMap = {
                        id: tempMap.id !== undefined ? tempMap.id : 0,
                        team: tempMap.team !== undefined ? tempMap.team : 1,
                        hand: tempMap.hand !== undefined ? tempMap.hand : 2
                    };
                    foundHeader = true;
                    return; // è·³è¿‡è¡¨å¤´
                }
                
                // å…¼å®¹æ—§é€»è¾‘ï¼ˆå¦‚æœæ²¡æœ‰ç²¾ç¡®åŒ¹é…ä½†çœ‹èµ·æ¥åƒè¡¨å¤´ï¼‰
                const firstCol = parts[0] || '';
                const secondCol = parts[1] || '';
                if (firstCol.includes('åºå·') || secondCol.includes('é˜Ÿä¼') || secondCol.includes('Team')) {
                    return; // è·³è¿‡è¡¨å¤´
                }
            }
            
            const maxIndex = Math.max(colMap.id, colMap.team, colMap.hand);
            if (parts.length <= maxIndex) {
                errors.push(`ç¬¬ ${index+1} è¡Œæ ¼å¼é”™è¯¯: åˆ—æ•°ä¸è¶³ (éœ€è‡³å°‘ ${maxIndex+1} åˆ—)`);
                return;
            }

            const serial = parts[colMap.id];
            const team = parts[colMap.team];
            
            let cardsStr = '';
            if (foundHeader) {
                cardsStr = parts[colMap.hand];
            } else {
                // å…¼å®¹æ—§æ¨¡å¼ï¼šå¦‚æœæ²¡æœ‰è¯†åˆ«åˆ°è¡¨å¤´ï¼Œå‡è®¾ä»ç¬¬3åˆ—å¼€å§‹éƒ½æ˜¯ç‰Œï¼ˆåº”å¯¹é€—å·åˆ†å‰²çš„æƒ…å†µï¼‰
                cardsStr = parts.slice(2).join(' ');
            }

            try {
                const cards = parseCards(cardsStr);
                const result = evaluateHand(cards);
                
                handHistory.push({
                    id: Date.now().toString() + Math.random(), // Ensure unique ID
                    cards: cards,
                    serial: serial,
                    team: team,
                    ...result
                });
                successCount++;
            } catch (e) {
                errors.push(`ç¬¬ ${index+1} è¡Œ (${team}) é”™è¯¯: ${e.message}`);
            }
        });

        // Re-sort and update table
        handHistory.sort((a, b) => b.score - a.score);
        updateTable();
        
        // Show result
        if (errors.length > 0) {
            alert(`å¯¼å…¥å®Œæˆ: ${successCount} æˆåŠŸ\n\né”™è¯¯:\n${errors.join('\n')}`);
        } else {
            alert(`æˆåŠŸå¯¼å…¥ ${successCount} æ¡æ•°æ®`);
            document.getElementById('bulkInput').value = '';
            // Close modal if requested (e.g. from file upload) or always?
            // Requirement: "å¦‚æœé€‰æ‹©æ–‡ä»¶å¯¼å…¥æˆåŠŸåè‡ªåŠ¨å…³é—­"
            // Let's close it always on full success for better UX, or only if from file?
            // User said "å¦‚æœé€‰æ‹©æ–‡ä»¶å¯¼å…¥æˆåŠŸå...", implies manual paste might stay open?
            // But usually if success, closing is fine.
            // Let's stick to closing it always on full success as per previous implementation, 
            // but specifically ensure it handles the file upload case nicely.
            closeModal('importModal');
        }
    }

    function processHand() {
        const errorMsg = document.getElementById('errorMsg');
        const inputVal = document.getElementById('cardInput').value.trim();
        const serialVal = document.getElementById('serialInput').value.trim();
        const teamVal = document.getElementById('teamInput').value.trim();
        
        errorMsg.style.display = 'none';

        try {
            if (!serialVal) throw new Error("è¯·è¾“å…¥åºå·");
            if (!teamVal) throw new Error("è¯·è¾“å…¥é˜Ÿä¼åç§°");

            let currentHand = [];

            // Strategy: 
            // 1. If text input has changed manually (we can't easily detect "manual" vs "auto" here without more state),
            //    let's try to parse text first if it looks valid.
            // 2. Or, just parse text input always if it's not empty. 
            //    Since selectCard updates text input, text input should be the source of truth if populated.
            
            if (inputVal) {
                currentHand = parseCards(inputVal);
                // Sync back to UI (dropdowns)
                currentHand.forEach((card, i) => {
                    // We need to find this card in our deck to get the exact object ref if possible, 
                    // or just use the object returned by parseCards (which should be from deck)
                    // parseCards now returns objects from deck.
                    selectedCards[i+1] = card;
                    
                    // Update trigger UI manually
                    const trigger = document.getElementById(`trigger${i+1}`);
                    trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> â–¾`;
                    trigger.classList.add('filled');
                });
                // Clear remaining slots if any (e.g. input had 3 cards) - actually parseCards throws if not 5
            } else {
                // Use dropdowns
                for (let i = 1; i <= 5; i++) {
                    if (!selectedCards[i]) {
                        throw new Error(`è¯·é€‰æ‹©ç¬¬ ${i} å¼ ç‰Œ`);
                    }
                    currentHand.push(selectedCards[i]);
                }
            }
            
            // Check duplicates
            const uniqueCheck = new Set(currentHand.map(c => c.suit + c.rank));
            if (uniqueCheck.size !== 5) {
                throw new Error("ç‰Œé¢é‡å¤ï¼Œè¯·æ£€æŸ¥");
            }
            
            const result = evaluateHand(currentHand);
            
            if (currentEditingId) {
                // Update existing
                const index = handHistory.findIndex(h => h.id === currentEditingId);
                if (index !== -1) {
                    handHistory[index] = {
                        ...handHistory[index],
                        cards: currentHand,
                        serial: serialVal,
                        team: teamVal,
                        ...result
                    };
                }
                cancelEdit(); // Reset UI
            } else {
                // Add new
                handHistory.push({
                    id: Date.now().toString(), // Simple unique ID
                    cards: currentHand,
                    serial: serialVal,
                    team: teamVal,
                    ...result
                });
            }

            // æ’åºï¼šåˆ†æ•°ä»é«˜åˆ°ä½
            handHistory.sort((a, b) => b.score - a.score);

            updateTable();
            
            // Clear inputs if not editing (if editing, cancelEdit already cleared)
            if (!currentEditingId) {
                document.getElementById('cardInput').value = '';
                document.getElementById('serialInput').value = '';
                document.getElementById('teamInput').value = '';
                // Clear dropdowns
                for (let i = 1; i <= 5; i++) {
                     selectedCards[i] = null;
                     const trigger = document.getElementById(`trigger${i}`);
                     trigger.innerHTML = `... â–¾`;
                     trigger.classList.remove('filled');
                }
            }
            
        } catch (e) {
            errorMsg.textContent = e.message;
            errorMsg.style.display = 'block';
        }
    }
    
    function parseCards(input) {
        // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…æ‰€æœ‰å¯èƒ½çš„ç‰Œç»„åˆ
        // Suits: â™ â™¥â™£â™¦sShHcCdD
        // Ranks: 10, 2-9, tTjJqQkKaA, 1
        const suitRegex = "[â™ â™¥â™£â™¦sShHcCdD]";
        const rankRegex = "(?:10|[2-9]|[tTjJqQkKaA]|1)";
        
        // æ¨¡å¼1: èŠ±è‰² + ç‚¹æ•° (ä¾‹å¦‚: â™ A, s10)
        // æ¨¡å¼2: ç‚¹æ•° + èŠ±è‰² (ä¾‹å¦‚: As, 10s)
        const cardRegex = new RegExp(`(${suitRegex}${rankRegex})|(${rankRegex}${suitRegex})`, 'g');
        
        const parts = input.match(cardRegex) || [];
        
        if (parts.length !== 5) {
             throw new Error(`å¿…é¡»è¾“å…¥5å¼ ç‰Œï¼Œå½“å‰è¯†åˆ«åˆ° ${parts.length} å¼ `);
        }

        const parsedCards = [];
        
        // Helper to find card in deck
        const findCard = (suitChar, rankStr) => {
             // Normalize suitChar to standard symbol or match deck properties
             // rankStr could be '10', 'A', 't', etc.
             
             // Map input suit to deck suit symbol
             const suitMap = {
                 's': 'â™ ', 'S': 'â™ ', 'â™ ': 'â™ ',
                 'h': 'â™¥', 'H': 'â™¥', 'â™¥': 'â™¥',
                 'c': 'â™£', 'C': 'â™£', 'â™£': 'â™£',
                 'd': 'â™¦', 'D': 'â™¦', 'â™¦': 'â™¦'
             };
             
             const targetSuit = suitMap[suitChar];
             if (!targetSuit) return null;

             // Map rank string to value/label
             const rankMap = {
                 '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                 't': 10, 'T': 10,
                 'j': 11, 'J': 11,
                 'q': 12, 'Q': 12,
                 'k': 13, 'K': 13,
                 'a': 14, 'A': 14, '1': 14
             };
             const targetRankVal = rankMap[rankStr];
             if (!targetRankVal) return null;

             return deck.find(c => c.suit === targetSuit && c.rank === targetRankVal);
        };

        for (let part of parts) {
            let suitChar = '';
            let rankStr = '';
            
            // Regex: Suit first or Rank first
            // Suit: [â™ â™¥â™£â™¦sShHcCdD]
            // Rank: [2-9]|10|[tTjJqQkKaA]|1
            
            const matchPrefix = part.match(/^([â™ â™¥â™£â™¦sShHcCdD])([2-9]|10|[tTjJqQkKaA]|1)$/);
            const matchSuffix = part.match(/^([2-9]|10|[tTjJqQkKaA]|1)([â™ â™¥â™£â™¦sShHcCdD])$/);

            if (matchPrefix) {
                suitChar = matchPrefix[1];
                rankStr = matchPrefix[2];
            } else if (matchSuffix) {
                rankStr = matchSuffix[1];
                suitChar = matchSuffix[2];
            } else {
                throw new Error(`æ— æ³•è¯†åˆ«çš„ç‰Œ: ${part}`);
            }

            const card = findCard(suitChar, rankStr);
            if (!card) {
                throw new Error(`æ— æ³•è¯†åˆ«çš„ç‰Œ: ${part}`);
            }
            parsedCards.push(card);
        }
        return parsedCards;
    }

    function evaluateHand(cards) {
        // æ’åºç‰Œé¢ (ä»å¤§åˆ°å°)
        const sortedCards = [...cards].sort((a, b) => b.rank - a.rank);
        const ranks = sortedCards.map(c => c.rank);
        const suits = sortedCards.map(c => c.suit);

        // æ£€æŸ¥åŒèŠ±
        const isFlush = suits.every(s => s === suits[0]);

        // æ£€æŸ¥é¡ºå­
        let isStraight = true;
        for (let i = 0; i < 4; i++) {
            if (ranks[i] - ranks[i+1] !== 1) {
                isStraight = false;
                break;
            }
        }
        // ç‰¹æ®Šæƒ…å†µ: A-5-4-3-2 (A=14, 2=2)
        // æ­¤æ—¶ ranks æ˜¯ [14, 5, 4, 3, 2]
        if (!isStraight && ranks[0] === 14 && ranks[1] === 5 && ranks[2] === 4 && ranks[3] === 3 && ranks[4] === 2) {
            isStraight = true;
            // ä¸ºäº†æ¯”è¾ƒå¤§å°ï¼Œè¿™é‡ŒæŠŠå®ƒå½“ä½œ 5-high straight
            // ä½†æ˜¯åœ¨åˆ†æ•°è®¡ç®—æ—¶éœ€è¦ç‰¹æ®Šå¤„ç†ï¼ŒæŠŠAå½“ä½œ1æ¥å¤„ç†
        }

        // ç»Ÿè®¡ç‚¹æ•°é¢‘ç‡
        const rankCounts = {};
        ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
        
        // è·å–å››æ¡ã€ä¸‰æ¡ã€å¯¹å­
        const counts = Object.values(rankCounts);
        const isFourOfAKind = counts.includes(4);
        const isThreeOfAKind = counts.includes(3);
        const pairCount = counts.filter(c => c === 2).length;

        let handTypeIndex = 0; // 0-9, å¯¹åº” HAND_TYPES ç´¢å¼•
        let score = 0;

        // è®¡ç®—åŸºç¡€åˆ†æ•° (Base Score)
        // æ¯ä¸€çº§ç›¸å·® 1,000,000,000 (10^9) ä¿è¯çº§åˆ«å‹åˆ¶
        // çº§åˆ«å†…æ¯”è¾ƒä½¿ç”¨ HEX ç±»ä¼¼æ€æƒ³: 
        // c1*16^4 + c2*16^3 + ...
        // è¿™é‡Œç®€å•ç”¨ 100è¿›åˆ¶

        const getKickersValue = (cardRanks) => {
            let val = 0;
            let power = 1;
            for (let i = cardRanks.length - 1; i >= 0; i--) {
                val += cardRanks[i] * power;
                power *= 100;
            }
            return val;
        };

        if (isFlush && isStraight) {
            if (ranks[0] === 14 && ranks[1] === 13) { // Royal Flush
                handTypeIndex = 9;
                score = 9 * 10000000000;
            } else { // Straight Flush
                handTypeIndex = 8;
                // å¤„ç† A-5-4-3-2 çš„æƒ…å†µï¼Œæ­¤æ—¶æœ€å¤§ç‰Œæ˜¯ 5
                let highRank = ranks[0];
                if (ranks[0] === 14 && ranks[4] === 2) highRank = 5;
                score = 8 * 10000000000 + highRank;
            }
        } else if (isFourOfAKind) {
            handTypeIndex = 7;
            const quadRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 4));
            const kicker = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 1));
            score = 7 * 10000000000 + quadRank * 100 + kicker;
        } else if (isThreeOfAKind && pairCount === 1) { // Full House
            handTypeIndex = 6;
            const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
            const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
            score = 6 * 10000000000 + tripRank * 100 + pairRank;
        } else if (isFlush) {
            handTypeIndex = 5;
            score = 5 * 10000000000 + getKickersValue(ranks);
        } else if (isStraight) {
            handTypeIndex = 4;
            let highRank = ranks[0];
            if (ranks[0] === 14 && ranks[4] === 2) highRank = 5;
            score = 4 * 10000000000 + highRank;
        } else if (isThreeOfAKind) {
            handTypeIndex = 3;
            const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
            const kickers = ranks.filter(r => r !== tripRank);
            score = 3 * 10000000000 + tripRank * 10000 + getKickersValue(kickers);
        } else if (pairCount === 2) {
            handTypeIndex = 2;
            const pairs = Object.keys(rankCounts).filter(key => rankCounts[key] === 2).map(Number).sort((a,b) => b-a);
            const kicker = ranks.find(r => !pairs.includes(r));
            score = 2 * 10000000000 + pairs[0] * 10000 + pairs[1] * 100 + kicker;
        } else if (pairCount === 1) {
            handTypeIndex = 1;
            const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
            const kickers = ranks.filter(r => r !== pairRank);
            score = 1 * 10000000000 + pairRank * 1000000 + getKickersValue(kickers);
        } else {
            handTypeIndex = 0;
            score = getKickersValue(ranks);
        }

        return {
            handTypeName: HAND_TYPES[handTypeIndex].name,
            score: score
        };
    }

    function editEntry(id) {
        const entry = handHistory.find(h => h.id === id);
        if (!entry) return;

        currentEditingId = id;
        
        // Populate inputs
        document.getElementById('serialInput').value = entry.serial;
        document.getElementById('teamInput').value = entry.team;
        
        // Populate cards
        entry.cards.forEach((card, i) => {
             selectedCards[i+1] = card;
             const trigger = document.getElementById(`trigger${i+1}`);
             trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> â–¾`;
             trigger.classList.add('filled');
        });
        updateTextInput();

        // Update UI state
        document.getElementById('actionBtn').textContent = 'æ›´æ–°';
        document.getElementById('actionBtn').style.backgroundColor = '#28a745';
        document.getElementById('cancelBtn').style.display = 'inline-block';
        
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function cancelEdit() {
        currentEditingId = null;
        
        // Clear inputs
        document.getElementById('serialInput').value = '';
        document.getElementById('teamInput').value = '';
        document.getElementById('cardInput').value = '';
        
        // Clear dropdowns
        for (let i = 1; i <= 5; i++) {
             selectedCards[i] = null;
             const trigger = document.getElementById(`trigger${i}`);
             trigger.innerHTML = `... â–¾`;
             trigger.classList.remove('filled');
        }

        // Reset UI state
        document.getElementById('actionBtn').textContent = 'è®¡ç®— & æ’å';
        document.getElementById('actionBtn').style.backgroundColor = '#007bff';
        document.getElementById('cancelBtn').style.display = 'none';
        document.getElementById('errorMsg').style.display = 'none';
    }

    function clearData() {
        if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
            handHistory = [];
            cancelEdit();
            updateTable();
        }
    }

    function updateTable() {
        const tbody = document.querySelector('#rankingTable tbody');
        tbody.innerHTML = '';

        let effectiveRank = 1;

        handHistory.forEach((entry, index) => {
            const tr = document.createElement('tr');
            
            // Determine effective rank (handle ties)
            if (index > 0 && entry.score === handHistory[index-1].score) {
                // Tie with previous: effectiveRank remains unchanged
            } else {
                // No tie: effectiveRank is the current position
                effectiveRank = index + 1;
            }

            // æ’å
            const tdRank = document.createElement('td');
            tdRank.textContent = effectiveRank;
            tr.appendChild(tdRank);
            
            // åºå·
            const tdSerial = document.createElement('td');
            tdSerial.textContent = entry.serial;
            tr.appendChild(tdSerial);
            
            // é˜Ÿä¼åç§°
            const tdTeam = document.createElement('td');
            tdTeam.textContent = entry.team;
            tr.appendChild(tdTeam);

            // ç‰Œå‹åç§°
            const tdType = document.createElement('td');
            tdType.textContent = entry.handTypeName;
            tr.appendChild(tdType);

            // ç‰Œé¢
            const tdCards = document.createElement('td');
            entry.cards.forEach(card => {
                const span = document.createElement('span');
                span.className = `card ${card.color === 'red' ? 'suit-red' : 'suit-black'}`;
                span.textContent = `${card.suit}${card.rankLabel}`;
                tdCards.appendChild(span);
            });
            tr.appendChild(tdCards);

            // ç§¯åˆ†
            const tdPoints = document.createElement('td');
            // Points calculation based on effective rank
            // Rank 1 gets totalTeams points
            // Rank N gets totalTeams - N + 1 points
            const points = totalTeams - effectiveRank + 1;
            
            tdPoints.textContent = points;
            tdPoints.style.fontWeight = 'bold';
            tdPoints.style.color = points > 0 ? '#28a745' : '#dc3545';
            tr.appendChild(tdPoints);

            // åˆ†æ•° (Debugç”¨ï¼Œä¹Ÿå¯ä»¥æ˜¾ç¤º)
            const tdScore = document.createElement('td');
            tdScore.textContent = entry.score.toLocaleString();
            tr.appendChild(tdScore);
            
            // æ“ä½œ
            const tdAction = document.createElement('td');
            const editBtn = document.createElement('button');
            editBtn.textContent = 'ç¼–è¾‘';
            editBtn.style.padding = '5px 10px';
            editBtn.style.fontSize = '12px';
            editBtn.onclick = () => editEntry(entry.id);
            tdAction.appendChild(editBtn);
            tr.appendChild(tdAction);

            tbody.appendChild(tr);
        });
    }

    function exportRanking() {
        if (handHistory.length === 0) {
            alert('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
            return;
        }

        // Prepare data for export
        let effectiveRank = 1;
        const data = handHistory.map((entry, index) => {
            // Determine effective rank (handle ties)
            if (index > 0 && entry.score === handHistory[index-1].score) {
                // Tie: effectiveRank remains unchanged
            } else {
                effectiveRank = index + 1;
            }

            const points = totalTeams - effectiveRank + 1;
            
            // æ ¼å¼åŒ–ç‰Œé¢å­—ç¬¦ä¸²ï¼Œç§»é™¤é¢œè‰²æ ‡è®°ï¼Œçº¯æ–‡æœ¬
            const cardStr = entry.cards.map(c => `${c.suit}${c.rankLabel}`).join(' ');
            
            return {
                "æ’å": effectiveRank,
                "åºå·": entry.serial,
                "é˜Ÿä¼åç§°": entry.team,
                "ç‰Œå‹åç§°": entry.handTypeName,
                "ç‰Œé¢": cardStr,
                "ç§¯åˆ†": points,
                "åˆ†æ•°": entry.score
            };
        });

        // Create worksheet
        const ws = XLSX.utils.json_to_sheet(data);
        
        // Adjust column widths
        const wscols = [
            {wch: 6},  // æ’å
            {wch: 10}, // åºå·
            {wch: 20}, // é˜Ÿä¼åç§°
            {wch: 20}, // ç‰Œå‹åç§°
            {wch: 25}, // ç‰Œé¢
            {wch: 8},  // ç§¯åˆ†
            {wch: 15}  // åˆ†æ•°
        ];
        ws['!cols'] = wscols;

        // Create workbook
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "æ’è¡Œæ¦œ");

        // Generate filename with timestamp
        const date = new Date();
        const dateStr = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        const timeStr = `${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}`;
        const filename = `å¾·å·æ‰‘å…‹æ’è¡Œæ¦œ_${dateStr}_${timeStr}.xlsx`;

        // Export
        try {
            XLSX.writeFile(wb, filename);
        } catch (e) {
            alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }

    // å¯åŠ¨
    init();
</script>

</body>
</html>
