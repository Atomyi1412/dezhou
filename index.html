<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ£è¯å¤§å†’é™©ç»Ÿè®¡</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Christmas Theme Palette */
        :root {
            --xmas-red: #D42426;
            --xmas-green: #165B33;
            --xmas-light-green: #2E8B57;
            --xmas-gold: #F8B229;
            --xmas-bg: #f0f2f5;
            --xmas-white: #ffffff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--xmas-bg);
            /* Simple snow pattern */
            background-image: radial-gradient(#e6e9ef 15%, transparent 16%), radial-gradient(#e6e9ef 15%, transparent 16%);
            background-size: 60px 60px;
            background-position: 0 0, 30px 30px;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background-color: var(--xmas-white);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 1400px;
            border-top: 6px solid var(--xmas-red);
            position: relative;
        }
        /* Decorative ribbon effect */
        .container::before {
            content: "ğŸ„";
            position: absolute;
            top: -25px;
            left: 20px;
            font-size: 40px;
            z-index: 10;
        }
        .container::after {
            content: "ğŸ…";
            position: absolute;
            top: -25px;
            right: 20px;
            font-size: 40px;
            z-index: 10;
        }

        h1 {
            color: var(--xmas-red);
            text-align: center;
            margin-bottom: 25px;
            font-weight: 800;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            letter-spacing: 1px;
            border-bottom: 2px dashed var(--xmas-green);
            padding-bottom: 10px;
            display: inline-block;
            width: 100%;
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 2px solid #eee;
            margin-bottom: 20px;
            justify-content: center;
        }
        .tab-btn {
            padding: 12px 24px;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            transition: all 0.3s;
            font-size: 15px;
        }
        .tab-btn:hover {
            color: var(--xmas-light-green);
            background-color: rgba(46, 139, 87, 0.05);
            border-radius: 5px 5px 0 0;
        }
        .tab-btn.active {
            color: var(--xmas-green);
            border-bottom-color: var(--xmas-red);
        }
        .tab-content {
            display: none;
            animation: fadeIn 0.4s ease-out;
        }
        .tab-content.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Card Selector Styles */
        .card-selectors {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
            background: #f9fdf9;
            padding: 15px;
            border-radius: 8px;
            border: 1px dashed #d1e7dd;
        }
        
        .card-input-group {
            display: flex;
            flex-direction: column;
            width: 120px;
            position: relative;
        }

        .card-label {
            font-size: 14px;
            color: var(--xmas-green);
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }

        .card-select-trigger {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 42px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .card-select-trigger:hover {
            border-color: var(--xmas-light-green);
            box-shadow: 0 0 0 3px rgba(46, 139, 87, 0.1);
        }

        .card-select-trigger.filled {
            background-color: #e8f5e9;
            border-color: #a5d6a7;
            color: #1b5e20;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            width: 200px;
            max-height: 300px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            display: none;
            overflow-y: auto;
            padding: 5px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .search-box {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #eee;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .search-box:focus {
            outline: none;
            border-color: var(--xmas-light-green);
        }

        .card-option {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s;
        }

        .card-option:hover {
            background-color: #f1f8e9;
        }

        .card-option.selected {
            background-color: #e8f5e9;
            color: var(--xmas-green);
        }
        
        .action-area {
            text-align: center;
            margin: 25px 0;
        }

        button {
            padding: 12px 40px;
            font-size: 16px;
            background-color: var(--xmas-green);
            color: white;
            border: none;
            border-radius: 25px; /* Rounder buttons */
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(22, 91, 51, 0.2);
            font-weight: 600;
        }
        button:hover {
            background-color: var(--xmas-light-green);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(22, 91, 51, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 20px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 0 1px #eee;
        }
        th, td {
            padding: 14px 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        th {
            background-color: var(--xmas-green);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 14px;
            letter-spacing: 0.5px;
        }
        tr:last-child td {
            border-bottom: none;
        }
        table tr { position: relative; }
        tr:hover td { background-color: inherit; }
        tr:hover::after {
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            border: 2px solid rgba(46, 139, 87, 0.55);
            border-radius: 8px;
            pointer-events: none;
        }

        .card {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 4px;
            background: #fff;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .suit-red { color: var(--xmas-red); }
        .suit-black { color: #292b2c; }
        
        .error-msg {
            color: var(--xmas-red);
            margin-top: 10px;
            display: none;
            text-align: center;
            padding: 10px;
            background: #fff5f5;
            border-radius: 4px;
            border: 1px solid #ffebee;
        }

        /* Modal Styles */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.5); 
            backdrop-filter: blur(3px);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto; 
            padding: 25px;
            border: none;
            width: 90%; 
            max-width: 600px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            animation: modalFadeIn 0.3s;
            border-top: 5px solid var(--xmas-green);
        }

        @keyframes modalFadeIn {
            from {opacity: 0; transform: translateY(-20px);}
            to {opacity: 1; transform: translateY(0);}
        }

        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            transition: color 0.2s;
        }

        .close-modal:hover,
        .close-modal:focus {
            color: var(--xmas-red);
            text-decoration: none;
            cursor: pointer;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            box-shadow: none;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }

        /* Mobile Optimization */
        @media (max-width: 768px) {
            body {
                padding: 10px 5px;
                background-size: 30px 30px;
            }
            .container {
                padding: 15px 10px;
                width: 100%;
                box-sizing: border-box;
            }
            .container::before, .container::after {
                font-size: 24px;
                top: -15px;
            }
            h1 {
                font-size: 22px;
                margin-bottom: 15px;
            }
            
            /* Scrollable Tabs */
            .tabs {
                justify-content: flex-start;
                overflow-x: auto;
                white-space: nowrap;
                padding-bottom: 5px;
                margin-bottom: 15px;
                -webkit-overflow-scrolling: touch;
                border-bottom: 1px solid #eee;
            }
            .tab-btn {
                padding: 10px 15px;
                font-size: 14px;
                flex-shrink: 0;
            }
            
            /* Stack inputs */
            .input-group {
                flex-direction: column !important;
                align-items: stretch !important;
            }
            .input-group select, 
            .input-group input {
                width: 100% !important;
                box-sizing: border-box;
                margin-bottom: 8px;
            }
            
            /* Compact Card Selectors - Grid Layout */
            .card-selectors {
                gap: 8px;
                padding: 10px;
                display: grid;
                grid-template-columns: repeat(3, 1fr); /* 3 per row */
            }
            .card-input-group {
                width: auto; /* Let grid handle width */
                min-width: 0;
            }
            
            .card-label {
                font-size: 12px;
            }
            .card-select-trigger {
                padding: 5px;
                font-size: 13px;
                min-height: 40px;
            }
            
            /* Fix Dropdown Overflow */
            .dropdown-menu {
                width: 180px; 
                max-width: 85vw;
            }
            /* Align right for right-side items to prevent overflow */
            .card-input-group:nth-child(3n) .dropdown-menu,
            .card-input-group:nth-child(3n-1) .dropdown-menu {
                right: 0;
                left: auto;
            }

            /* Table Scroll */
            .table-responsive {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                border-radius: 8px;
                box-shadow: 0 0 0 1px #eee;
                margin-bottom: 15px;
            }
            table {
                min-width: 600px;
                margin-top: 0;
                box-shadow: none;
                border-radius: 0;
            }
            th, td {
                padding: 8px 6px;
                font-size: 13px;
                white-space: nowrap;
            }
            
            /* Modal adjust */
            .modal-content {
                width: 90%;
                margin: 15% auto;
                padding: 20px;
                max-height: 85vh;
                overflow-y: auto;
            }
            
            /* Toolbar Buttons Grid */
            .toolbar {
                flex-wrap: wrap;
                gap: 8px;
            }
            .toolbar button {
                flex: 1 1 calc(50% - 8px); /* 2 buttons per row */
                padding: 10px 5px;
                font-size: 13px;
            }
            
            /* Search Container Stack */
            .search-container {
                flex-direction: column;
                align-items: stretch;
                padding: 12px;
            }
            .search-container input, 
            .search-container button,
            .search-container .hand-type-btn {
                width: 100% !important;
                max-width: none;
                margin-bottom: 8px;
            }
            
            /* Year Modal Specifics */
            .year-modal-body {
                flex-direction: column !important;
                align-items: stretch !important;
            }
            .year-modal-body select,
            .year-modal-body input,
            .year-modal-body button {
                width: 100% !important;
                margin-bottom: 10px;
            }

            /* Prevent Zoom on Focus */
            select, input, textarea {
                font-size: 16px !important;
            }
            /* Wish Input Group Grid */
            #wishFormSection .input-group {
                display: grid !important;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
            #wishFormSection .input-group input {
                width: 100% !important;
                min-width: 0;
            }
        }
        /* Team List Styles */
        .team-group-header {
            background-color: #f8f9fa;
            padding: 10px 15px;
            font-weight: bold;
            color: #495057;
            border-left: 4px solid var(--xmas-red);
            margin-top: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .team-list-table {
            width: 100%;
            margin-bottom: 10px;
        }
        .team-list-table td {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .tag {
            display: inline-block;
            background: #e8f5e9; /* Light green */
            color: var(--xmas-green);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-right: 5px;
            border: 1px solid #c8e6c9;
        }

        /* Search Area Styles */
        .search-container {
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 5px rgba(0,0,0,0.02);
        }
        
        .search-input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 20px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        
        .search-input:focus {
            border-color: var(--xmas-green);
            box-shadow: 0 0 0 3px rgba(22, 91, 51, 0.1);
        }
        
        .btn-icon {
            margin-right: 5px;
        }
        
        /* Custom Button Colors */
        .btn-success { background-color: var(--xmas-green) !important; }
        .btn-info { background-color: var(--xmas-light-green) !important; }
        .btn-danger { background-color: var(--xmas-red) !important; }
        .btn-secondary { background-color: #6c757d !important; }
        
        .hand-type-btn {
            width: 140px;
            padding: 8px 15px;
            border: 1px solid #ced4da;
            border-radius: 20px;
            background: white;
            color: #495057;
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .hand-type-btn:hover {
            border-color: var(--xmas-green);
        }

        /* Header Buttons */
        .header-btn {
            background-color: rgba(255, 255, 255, 0.9);
            color: var(--xmas-green);
            border: 1px solid var(--xmas-green);
            border-radius: 20px;
            padding: 8px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            font-weight: 600;
        }

        .header-btn:hover {
            background-color: var(--xmas-green);
            color: white;
            box-shadow: 0 4px 8px rgba(22, 91, 51, 0.2);
            transform: translateY(-1px);
        }
        
        .header-btn.settings-btn {
            border-color: var(--xmas-red);
            color: var(--xmas-red);
        }
        
        .header-btn.settings-btn:hover {
            background-color: var(--xmas-red);
            color: white;
        }
        
        @media (max-width: 768px) {
            .header-buttons {
                position: absolute;
                top: 15px;
                right: 15px;
            }
            .header-btn {
                padding: 6px 10px;
                font-size: 12px;
            }
            .header-btn .btn-text {
                display: none;
            }
        }

        /* Large Screen Optimization */
        @media (min-width: 1200px) {
            .search-container {
                display: grid;
                grid-template-columns: 80px 1fr 1fr 240px 160px 100px; /* Increased Wish column */
                gap: 12px; /* Slightly reduced gap */
                align-items: center;
            }
            .search-container input.search-input,
            .search-container button,
            .search-container .hand-type-btn {
                width: 100% !important;
                margin-bottom: 0;
            }
            /* Min-Max Wrapper (4th child) */
            .search-container > div:nth-child(4) {
                display: flex;
                width: 100%;
                gap: 5px;
                align-items: center;
            }
            /* Target inputs inside Min-Max wrapper specifically to prevent overflow */
            .search-container > div:nth-child(4) input.search-input {
                width: auto !important; /* Allow flex to control width */
                flex: 1;
                min-width: 0; /* Important for flex shrinking */
            }
            /* Hand Type Wrapper (5th child) */
            .search-container > div:nth-child(5) {
                width: 100%;
            }
            /* Dropdown menu width adjustment */
            .search-container .dropdown-menu {
                width: 200px; /* Keep fixed width or match parent */
            }
        }
        
        /* Christmas Loader Styles */
        .christmas-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.98);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 0.5s;
        }

        .loader-content {
            text-align: center;
        }

        .santa-icon {
            font-size: 80px;
            animation: bounce 1s infinite alternate;
        }

        .loading-text {
            font-size: 24px;
            font-weight: bold;
            color: var(--xmas-red);
            margin-top: 20px;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif; /* Cute font */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .snowflakes {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .flake {
            font-size: 24px;
            animation: spin 2s linear infinite;
            color: #87CEEB;
        }

        .flake:nth-child(2) { animation-delay: 0.2s; color: #B0E0E6; }
        .flake:nth-child(3) { animation-delay: 0.4s; color: #ADD8E6; }

        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-20px); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<div id="pageLoader" class="christmas-loader">
    <div class="loader-content">
        <div class="santa-icon">ğŸ…</div>
        <div class="loading-text">æ­£åœ¨åŠ è½½åœ£è¯æƒŠå–œ...</div>
        <div class="snowflakes">
            <div class="flake">â„ï¸</div>
            <div class="flake">â„ï¸</div>
            <div class="flake">â„ï¸</div>
        </div>
    </div>
</div>

<div class="container">
    <div class="header-buttons" style="position: absolute; right: 20px; top: 20px; display: flex; gap: 10px;">
        <button onclick="openYearModal()" class="header-btn year-btn" title="åˆ‡æ¢å¹´ä»½">
            ğŸ“… <span class="btn-text">åˆ‡æ¢å¹´ä»½</span>
        </button>
        <button id="headerSettingsBtn" onclick="openModal('settingsModal')" class="header-btn settings-btn" title="è®¾ç½®" style="display: none;">
            âš™ï¸ <span class="btn-text">è®¾ç½®</span>
        </button>
    </div>
    <h1>åœ£è¯å¤§å†’é™©ç»Ÿè®¡</h1>
    
    <div class="tabs">
        <div class="tab-btn active" onclick="switchTab('calc')">ç‰Œå‹è®¡ç®— & æ’è¡Œ</div>
        <div class="tab-btn" onclick="switchTab('wishes')">å¿ƒæ„¿è®¡ç®— & æ’è¡Œ</div>
        <div class="tab-btn" onclick="switchTab('teams')">é˜Ÿä¼ç®¡ç†</div>
        <div class="tab-btn" onclick="switchTab('final')">æœ€ç»ˆæ’è¡Œ</div>
        <div class="tab-btn" onclick="switchTab('gifts')">ç¤¼ç‰©é€‰æ‹©</div>
    </div>

    <!-- Final Ranking Tab -->
    <div id="tab-final" class="tab-content">
        <div class="toolbar">
            <button onclick="exportFinalRanking()" class="btn-secondary btn-success"><span class="btn-icon">ğŸ“¤</span>å¯¼å‡ºæ€»æ¦œ</button>
            <button onclick="updateFinalRanking()" class="btn-secondary"><span class="btn-icon">ğŸ”„</span>åˆ·æ–°æ•°æ®</button>
        </div>
        
        <div style="margin-bottom: 10px; padding: 10px; background: #fff; border-radius: 5px; border: 1px solid #eee; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; font-size: 13px;">
            <strong style="color: var(--xmas-green);">ç¤¼ç‰©æ¡£ä½å›¾ç¤º:</strong>
            <span id="tierLegendContainer" style="display: flex; gap: 10px; flex-wrap: wrap;">
                <!-- Generated by JS -->
            </span>
        </div>

        <!-- Search Inputs -->
        <div class="search-container">
            <input type="text" id="searchSerial" class="search-input" placeholder="åºå·" style="width: 80px;" oninput="updateFinalRanking()">
            <input type="text" id="searchTeam" class="search-input" placeholder="é˜Ÿä¼åç§° (æ¨¡ç³Š)" style="width: 150px;" oninput="updateFinalRanking()">
            <input type="text" id="searchMembers" class="search-input" placeholder="æˆå‘˜ (æ¨¡ç³Š)" style="width: 150px;" oninput="updateFinalRanking()">
            <div style="display: flex; align-items: center; gap: 5px;">
                <input type="number" id="searchWishMin" class="search-input" placeholder="å¿ƒæ„¿åˆ†Min" style="width: 100px;" oninput="updateFinalRanking()">
                <span style="color: #999;">-</span>
                <input type="number" id="searchWishMax" class="search-input" placeholder="Max" style="width: 100px;" oninput="updateFinalRanking()">
        </div>
        
        <div style="position: relative; display: inline-block;">
            <button onclick="toggleHandTypeDropdown()" id="handTypeDropdownBtn" class="hand-type-btn">
                <span>é€‰æ‹©ç‰Œå‹</span>
                <span style="font-size: 12px;">â–¼</span>
            </button>
            <div id="handTypeDropdown" class="dropdown-menu" style="width: 180px;">
                <div style="padding: 8px; border-bottom: 1px solid #eee;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-weight: bold; font-size: 14px;">
                        <input type="checkbox" onclick="toggleAllHandTypes(this)" style="margin-right: 8px;"> å…¨é€‰
                    </label>
                </div>
                <div id="handTypeList" style="max-height: 250px; overflow-y: auto;">
                    <!-- JS Generated -->
                </div>
            </div>
        </div>

        <button onclick="clearFinalSearch()" class="btn-secondary" style="padding: 8px 20px;">é‡ç½®</button>
    </div>

        <div class="table-responsive">
            <table id="finalRankingTable">
                <thead>
                    <tr>
                        <th>æœ€ç»ˆæ’å</th>
                        <th>åºå·</th>
                        <th>é˜Ÿä¼åç§°</th>
                        <th>æˆå‘˜</th>
                        <th>å¿ƒæ„¿æ€»è®¡</th>
                        <th>å¿ƒæ„¿ç§¯åˆ†</th>
                        <th>ç‰Œå‹åç§°</th>
                        <th>ç‰Œé¢</th>
                        <th>ç‰Œå‹ç§¯åˆ†</th>
                        <th>æœ€ç»ˆåˆ†æ•°</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Dynamic Content -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Gift Selection Tab -->
    <div id="tab-gifts" class="tab-content">
        <div class="toolbar" style="margin-bottom: 20px; display:flex; gap:10px;">
            <button onclick="viewGiftImages()" class="btn-secondary"><span class="btn-icon">ğŸ–¼ï¸</span>æŸ¥çœ‹ç¤¼ç‰©å‚è€ƒå›¾</button>
            <button onclick="exportGiftSelection()" class="btn-secondary btn-success" style="padding: 8px 20px;">ğŸ“¤ å¯¼å‡ºç¤¼ç‰©é€‰æ‹©</button>
        </div>
        
        <div class="search-container" style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
            <input type="text" id="searchGiftTeam" class="search-input" placeholder="é˜Ÿä¼åç§° (æ¨¡ç³Š)" oninput="renderGiftSelection()" style="flex: 1; min-width: 150px;">
            <input type="text" id="searchGiftMember" class="search-input" placeholder="æˆå‘˜ (æ¨¡ç³Š)" oninput="renderGiftSelection()" style="flex: 1; min-width: 150px;">
        </div>
        
        <div class="table-responsive">
            <table id="giftSelectionTable">
                <thead>
                    <tr>
                        <th>æœ€ç»ˆæ’å</th>
                        <th>ç¤¼ç‰©æ¡£ä½</th>
                        <th>é˜Ÿä¼åç§°</th>
                        <th>ç¤¼ç‰©é€‰æ‹© (æˆå‘˜å¯¹åº”ç¼–å·)</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Dynamic Content -->
                </tbody>
            </table>
        </div>
    </div>
    
    <!-- Gift Images Modal (for viewing) -->
    <div id="giftImagesModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close-modal" onclick="closeModal('giftImagesModal')">&times;</span>
            <h2 style="margin-top: 0; color: var(--xmas-green);">ç¤¼ç‰©å‚è€ƒå›¾</h2>
            <div id="giftImagesViewContainer" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
                <!-- Generated by JS -->
            </div>
        </div>
    </div>

    <!-- Calculator Tab -->
    <div id="tab-calc" class="tab-content active">
        <div class="toolbar" id="calcToolbar">
            <button id="btnCalcImport" onclick="openModal('importModal')" class="btn-secondary" style="padding: 8px 20px;">ğŸ“‚ æ‰¹é‡å¯¼å…¥</button>
            <button id="btnExportRanking" onclick="exportRanking()" class="btn-secondary btn-info" style="padding: 8px 20px; font-size: 14px;">ğŸ“¤ å¯¼å‡ºè¡¨æ ¼</button>
            <button id="btnClearHandData" onclick="clearData()" class="btn-secondary btn-danger" style="padding: 8px 20px; font-size: 14px;">æ¸…ç©ºæ•°æ®</button>
        </div>

        <div id="calcFormSection" style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <div class="input-group" id="calcInputSection" style="margin-bottom: 10px; width: 100%; display: flex; gap: 10px;">
                <select id="serialInput" style="width: 120px; padding: 12px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px; background-color: white;" onchange="syncTeamInput('serial')">
                    <option value="">åºå·</option>
                </select>
                <select id="teamInput" style="flex: 1; padding: 12px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px; background-color: white;" onchange="syncTeamInput('team')">
                    <option value="">é˜Ÿä¼åç§°</option>
                </select>
            </div>
        
            <div class="card-selectors" id="calcCardSelectors" style="background: transparent; border: none; padding: 0; margin-bottom: 10px;">
                <!-- Generate 5 card inputs -->
                <div class="card-input-group" id="group1">
                    <div class="card-label">ç‰Œ1</div>
                    <div class="card-select-trigger" onclick="toggleDropdown(1)" id="trigger1">... â–¾</div>
                    <div class="dropdown-menu" id="dropdown1">
                        <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(1)" onclick="event.stopPropagation()">
                        <div class="card-options-list" id="list1"></div>
                    </div>
                </div>
                <div class="card-input-group" id="group2">
                    <div class="card-label">ç‰Œ2</div>
                    <div class="card-select-trigger" onclick="toggleDropdown(2)" id="trigger2">... â–¾</div>
                    <div class="dropdown-menu" id="dropdown2">
                        <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(2)" onclick="event.stopPropagation()">
                        <div class="card-options-list" id="list2"></div>
                    </div>
                </div>
                <div class="card-input-group" id="group3">
                    <div class="card-label">ç‰Œ3</div>
                    <div class="card-select-trigger" onclick="toggleDropdown(3)" id="trigger3">... â–¾</div>
                    <div class="dropdown-menu" id="dropdown3">
                        <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(3)" onclick="event.stopPropagation()">
                        <div class="card-options-list" id="list3"></div>
                    </div>
                </div>
                <div class="card-input-group" id="group4">
                    <div class="card-label">ç‰Œ4</div>
                    <div class="card-select-trigger" onclick="toggleDropdown(4)" id="trigger4">... â–¾</div>
                    <div class="dropdown-menu" id="dropdown4">
                        <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(4)" onclick="event.stopPropagation()">
                        <div class="card-options-list" id="list4"></div>
                    </div>
                </div>
                <div class="card-input-group" id="group5">
                    <div class="card-label">ç‰Œ5</div>
                    <div class="card-select-trigger" onclick="toggleDropdown(5)" id="trigger5">... â–¾</div>
                    <div class="dropdown-menu" id="dropdown5">
                        <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(5)" onclick="event.stopPropagation()">
                        <div class="card-options-list" id="list5"></div>
                    </div>
                </div>
            </div>

            <div class="action-area" id="calcActionArea" style="text-align: center;">
                <button id="cancelBtn" onclick="cancelEdit()" style="display:none; background-color: #6c757d; margin-right: 10px; padding: 8px 25px;">å–æ¶ˆ</button>
                <button id="actionBtn" onclick="processHand()" style="padding: 8px 25px;">è®¡ç®— & æ’å</button>
            </div>
            <div id="errorMsg" class="error-msg"></div>
        </div>

    <!-- Bulk Import Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('importModal')">&times;</span>
            <h2 style="margin-top: 0; color: var(--xmas-green);">æ‰¹é‡å¯¼å…¥ (Excel/CSV)</h2>
            
            <div style="margin-top: 20px;">
                <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border: 1px dashed #ccc; border-radius: 5px;">
                    <p style="margin: 0 0 10px 0; font-size: 14px; font-weight: bold;">ä¸Šä¼ æ–‡ä»¶å¯¼å…¥:</p>
                    <input type="file" id="fileInput" accept=".xlsx, .xls, .csv" onchange="handleFileUpload(event)" style="width: 100%;">
                </div>

                <p style="font-size: 14px; color: #666; margin-bottom: 5px;">æˆ–ç²˜è´´å†…å®¹ (æ ¼å¼: åºå· | é˜Ÿä¼åç§° | ç‰Œé¢)</p>
                <textarea id="bulkInput" rows="10" style="width: 100%; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 5px; font-family: monospace;" placeholder="ä¾‹å¦‚:
1	TeamA	â™ A â™¥K â™£Q â™¦J â™ 10
2	TeamB	As Ks Qs Js Ts"></textarea>
                <div style="margin-top: 15px; text-align: right;">
                    <button onclick="processBulkImport()" class="btn-secondary btn-success" style="padding: 10px 30px;">å¼€å§‹å¯¼å…¥</button>
                </div>
            </div>
        </div>
    </div>

    <div id="calcExportBar" style="display: none;">
        <!-- Deprecated: buttons moved to toolbar -->
    </div>


    <div class="table-responsive">
        <table id="rankingTable">
            <thead>
                <tr>
                    <th>æ’å</th>
                    <th>åºå·</th>
                    <th>é˜Ÿä¼åç§°</th>
                    <th>ç‰Œå‹åç§°</th>
                    <th>ç‰Œé¢</th>
                    <th>ç§¯åˆ†</th>
                    <th>åˆ†æ•°</th>
                    <th>æ“ä½œ</th>
                </tr>
            </thead>
            <tbody>
                <!-- ç»“æœå°†æ’å…¥è¿™é‡Œ -->
            </tbody>
        </table>
    </div> <!-- End table-responsive -->
    </div> <!-- End tab-calc -->

    <!-- Wish Calculation Tab -->
    <div id="tab-wishes" class="tab-content">
        <div class="toolbar" id="wishToolbar">
            <button id="btnWishImport" onclick="openModal('wishImportModal')" class="btn-secondary" style="padding: 8px 20px;">ğŸ“‚ æ‰¹é‡å¯¼å…¥</button>
            <button id="btnWishExport" onclick="exportWishRanking()" class="btn-secondary btn-success" style="padding: 8px 20px;">ğŸ“¤ å¯¼å‡ºæ’è¡Œ</button>
            <button id="btnWishClear" onclick="clearWishData()" class="btn-secondary btn-danger" style="padding: 8px 20px; font-size: 14px;">æ¸…ç©ºæ•°æ®</button>
        </div>

        <div id="wishFormSection" style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <h3 style="margin-top: 0; font-size: 16px; color: var(--xmas-green);">å½•å…¥/ç¼–è¾‘å¿ƒæ„¿</h3>
            <div class="input-group" style="margin-bottom: 10px; width: 100%; display: flex; gap: 10px;">
                <select id="wishSerialInput" style="width: 120px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; background-color: white;" onchange="syncWishInput('serial')">
                    <option value="">åºå·</option>
                </select>
                <select id="wishTeamInput" style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px; background-color: white;" onchange="syncWishInput('team')">
                    <option value="">é˜Ÿä¼åç§°</option>
                </select>
            </div>
            <div class="input-group" style="margin-bottom: 10px; width: 100%; display: flex; gap: 10px; flex-wrap: wrap;">
                <input type="number" id="wish1" placeholder="1é¢—å¿ƒæ„¿æ•°é‡" style="flex: 1; min-width: 120px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box;">
                <input type="number" id="wish2" placeholder="2é¢—å¿ƒæ„¿æ•°é‡" style="flex: 1; min-width: 120px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box;">
                <input type="number" id="wish3" placeholder="3é¢—å¿ƒæ„¿æ•°é‡" style="flex: 1; min-width: 120px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box;">
                <input type="number" id="wish4" placeholder="4é¢—å¿ƒæ„¿æ•°é‡" style="flex: 1; min-width: 120px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box;">
                <input type="number" id="wish5" placeholder="5é¢—å¿ƒæ„¿æ•°é‡" style="flex: 1; min-width: 120px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box;">
            </div>
            <div style="text-align: center;">
                <button id="cancelWishEditBtn" onclick="cancelWishEdit()" style="padding: 8px 25px; background-color: #6c757d; margin-right: 10px; display: none;">å–æ¶ˆ</button>
                <button id="saveWishBtn" onclick="saveWish()" style="padding: 8px 25px;">ä¿å­˜æ•°æ®</button>
            </div>
        </div>

        <div class="table-responsive">
            <table id="wishRankingTable">
                <thead>
                    <tr>
                        <th>æ’å</th>
                        <th>åºå·</th>
                        <th>é˜Ÿä¼åç§°</th>
                        <th>1é¢—</th>
                        <th>2é¢—</th>
                        <th>3é¢—</th>
                        <th>4é¢—</th>
                        <th>5é¢—</th>
                        <th>å¿ƒæ„¿æ€»è®¡</th>
                        <th>ç§¯åˆ†</th>
                        <th>æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Dynamic Content -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Team Management Tab -->
    <div id="tab-teams" class="tab-content">
        <div class="toolbar" id="teamToolbar">
            <button id="btnTeamImport" onclick="openModal('teamImportModal')" class="btn-secondary" style="padding: 8px 20px;">ğŸ“‚ æ‰¹é‡å¯¼å…¥</button>
            <button id="btnTeamExport" onclick="exportTeams()" class="btn-secondary btn-success" style="padding: 8px 20px;">ğŸ“¤ å¯¼å‡ºé˜Ÿä¼</button>
            <button id="btnTeamClear" onclick="clearTeamData()" class="btn-secondary btn-danger" style="padding: 8px 20px; font-size: 14px;">æ¸…ç©ºåˆ—è¡¨</button>
        </div>

        <!-- Add Team Form -->
        <div id="teamFormSection" style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <h3 style="margin-top: 0; font-size: 16px; color: var(--xmas-green);">æ·»åŠ /ç¼–è¾‘é˜Ÿä¼</h3>
            <div class="input-group" style="margin-bottom: 10px; width: 100%; display: flex; gap: 10px; align-items: center;">
                <input type="text" id="teamSerial" placeholder="åºå·" style="width: 80px; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <div style="flex: 1; display: flex; gap: 5px; align-items: center;">
                    <input type="text" id="teamName" placeholder="é˜Ÿä¼åç§°" style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                    <input type="file" id="teamNameImageInput" accept="image/*" style="display:none" onchange="handleTeamImageSelect(this)">
                    <button onclick="document.getElementById('teamNameImageInput').click()" style="padding: 5px 10px; font-size: 12px;">ä¸Šä¼ å›¾ç‰‡é˜Ÿå</button>
                    <div id="teamNamePreview" style="display:none; align-items: center; gap: 5px;">
                        <img id="teamNamePreviewImg" src="" style="height: 30px; border: 1px solid #ddd;">
                        <button onclick="clearTeamImage()" style="padding: 0 5px; color: red;">&times;</button>
                    </div>
                </div>
            </div>
            <div class="input-group" style="margin-bottom: 10px; width: 100%; display: flex; gap: 10px;">
                <input type="text" id="teamMembers" placeholder="æˆå‘˜ (ç”¨é€—å·æˆ–ç©ºæ ¼åˆ†éš”)" style="flex: 2; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <input type="text" id="teamTime" placeholder="é¢„çº¦æ—¶é—´ (ä¾‹å¦‚: 11.24(å‘¨ä¸€)ä¸‹åˆ18:00)" style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
            </div>
            <div style="text-align: center;">
                <button id="cancelTeamEditBtn" onclick="cancelTeamEdit()" style="padding: 8px 25px; background-color: #6c757d; margin-right: 10px; display: none;">å–æ¶ˆ</button>
                <button id="saveTeamBtn" onclick="saveTeam()" style="padding: 8px 25px;">ä¿å­˜é˜Ÿä¼</button>
            </div>
        </div>

        <!-- Team List -->
        <div id="teamListContainer">
            <!-- Dynamic Content -->
        </div>
    </div>

</div>
<div id="yearModal" class="modal">
  <div class="modal-content">
    <span class="close-modal" onclick="closeModal('yearModal')">&times;</span>
    <h3 style="margin-top:0; color: var(--xmas-green);">é€‰æ‹©å¹´ä»½</h3>
    <div class="year-modal-body" style="display:flex; gap:10px; align-items:center;">
      <select id="yearSelect" class="search-input" style="width:140px;"></select>
      <input type="password" id="yearPasscode" class="search-input" placeholder="ç®¡ç†å£ä»¤ï¼ˆå¯é€‰ï¼‰" style="width:160px;">
      <button onclick="confirmYearSelection()" style="padding:8px 20px;">ç¡®å®š</button>
    </div>
  </div>
</div>



<!-- Settings Modal -->
<div id="settingsModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal" onclick="closeModal('settingsModal')">&times;</span>
        <h2 style="margin-top: 0; color: var(--xmas-green);">è®¾ç½®</h2>
        
        <div style="margin-top: 20px;">
            <div class="input-group" style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">é˜Ÿä¼æ€»æ•° (ç”¨äºç§¯åˆ†è®¡ç®—):</label>
                <input type="number" id="totalTeamsInput" value="49" onchange="updateTotalTeams()" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <p style="font-size: 12px; color: #666; margin-top: 5px;">é»˜è®¤ä¸º49é˜Ÿã€‚ç¬¬ä¸€åç§¯åˆ† = é˜Ÿä¼æ€»æ•°ï¼Œæœ€åä¸€å1åˆ†ã€‚</p>
            </div>
            
            <hr style="margin: 20px 0; border: 0; border-top: 1px dashed #ccc;">
            
            <h3 style="font-size: 16px; color: var(--xmas-green);">ç¤¼ç‰©æ¡£ä½é…ç½®</h3>
            <div id="giftTiersConfig" style="margin-bottom: 15px;">
                <!-- Generated by JS -->
            </div>
            
            <hr style="margin: 20px 0; border: 0; border-top: 1px dashed #ccc;">
            
            <h3 style="font-size: 16px; color: var(--xmas-green);">ç¤¼ç‰©å›¾ç‰‡ç®¡ç†</h3>
            <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border: 1px dashed #ccc; border-radius: 5px;">
                 <label style="display: block; margin-bottom: 5px; font-weight: bold;">ä¸Šä¼ å‚è€ƒå›¾ç‰‡:</label>
                 <input type="file" id="giftImageInput" accept="image/*" onchange="handleGiftImageUpload(event)" style="width: 100%; margin-bottom: 10px;">
                 <div id="giftImagePreviewContainer" style="display: flex; flex-wrap: wrap; gap: 10px;"></div>
            </div>
        </div>
    </div>
</div>

<!-- Wish Import Modal -->
<div id="wishImportModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeModal('wishImportModal')">&times;</span>
        <h2 style="margin-top: 0; color: var(--xmas-green);">æ‰¹é‡å¯¼å…¥å¿ƒæ„¿ (Excel)</h2>
        
        <div style="margin-top: 20px;">
            <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border: 1px dashed #ccc; border-radius: 5px;">
                <p style="margin: 0 0 10px 0; font-size: 14px; font-weight: bold;">ä¸Šä¼ æ–‡ä»¶å¯¼å…¥:</p>
                <input type="file" id="wishFileInput" accept=".xlsx, .xls" onchange="handleWishFileUpload(event)" style="width: 100%;">
            </div>
            <p style="font-size: 12px; color: #666;">æ”¯æŒæ ¼å¼: åºå· | é˜Ÿä¼åç§° | 1é¢—å¿ƒæ„¿ | 2é¢—å¿ƒæ„¿ | 3é¢—å¿ƒæ„¿ | 4é¢—å¿ƒæ„¿ | 5é¢—å¿ƒæ„¿</p>
        </div>
    </div>
</div>

<!-- Team Import Modal -->
<div id="teamImportModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeModal('teamImportModal')">&times;</span>
        <h2 style="margin-top: 0; color: var(--xmas-green);">æ‰¹é‡å¯¼å…¥é˜Ÿä¼</h2>
        
        <div style="margin-top: 20px;">
            <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border: 1px dashed #ccc; border-radius: 5px;">
                <p style="margin: 0 0 10px 0; font-size: 14px; font-weight: bold;">ä¸Šä¼ æ–‡ä»¶å¯¼å…¥ (Excel):</p>
                <input type="file" id="teamFileInput" accept=".xlsx, .xls" onchange="handleTeamFileUpload(event)" style="width: 100%;">
            </div>
            <p style="font-size: 12px; color: #666;">æ”¯æŒæ ¼å¼: åºå· | é˜Ÿä¼åç§° | æˆå‘˜1 | æˆå‘˜2... | é˜Ÿä¼äººæ•° | é¢„çº¦æ—¶é—´</p>
        </div>
    </div>
</div>


<script>
    const SUPABASE_URL = 'https://ixdgydcuaretfutmsyhz.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml4ZGd5ZGN1YXJldGZ1dG1zeWh6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4NjMwNjQsImV4cCI6MjA4MDQzOTA2NH0.xs37WIBXOQcqKXfa1dK_JT9vyabw6xmz4jaWob7KEOo';
    let supabaseClient = null;
    let currentYear = null;
    let isAdmin = false;
    // ç‰Œé¢å®šä¹‰
    const SUITS = {
        's': 'â™ ', 'S': 'â™ ', 'â™ ': 'â™ ',
        'h': 'â™¥', 'H': 'â™¥', 'â™¥': 'â™¥',
        'c': 'â™£', 'C': 'â™£', 'â™£': 'â™£',
        'd': 'â™¦', 'D': 'â™¦', 'â™¦': 'â™¦'
    };
    
    const RANKS = {
        '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
        'T': 10, 't': 10,
        'J': 11, 'j': 11,
        'Q': 12, 'q': 12,
        'K': 13, 'k': 13,
        'A': 14, 'a': 14
    };

    const RANK_NAMES = {
        2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '10',
        11: 'J', 12: 'Q', 13: 'K', 14: 'A'
    };

    const HAND_TYPES = [
        { name: "é«˜ç‰Œ", value: 1 },
        { name: "å¯¹å­", value: 2 },
        { name: "ä¸¤å¯¹", value: 3 },
        { name: "ä¸‰æ¡", value: 4 },
        { name: "é¡ºå­", value: 5 },
        { name: "åŒèŠ±", value: 6 },
        { name: "è‘«èŠ¦", value: 7 },
        { name: "å››æ¡", value: 8 },
        { name: "åŒèŠ±é¡º", value: 9 },
        { name: "çš‡å®¶åŒèŠ±é¡º", value: 10 }
    ];
    
    // å…¨å±€çŠ¶æ€ï¼šä¿å­˜æ¯ä¸ªä½ç½®é€‰ä¸­çš„ç‰Œ
    // æ ¼å¼: { 1: { suit: 'â™ ', rank: 14, name: 'â™ A' }, ... }
    let selectedCards = {
        1: null, 2: null, 3: null, 4: null, 5: null
    };
    
    let deck = [];
    let totalTeams = 49;
    let wishList = []; // Stores wish data: { serial, team, wishes: [c1,c2,c3,c4,c5], total, points }
    
    // Gift Tiers Default Configuration
    let giftTiers = [
        { min: 1, max: 4, name: "1000æ¡£", color: "#F8BBD0", value: 1000 }, // Pink
        { min: 5, max: 10, name: "800æ¡£", color: "#BBDEFB", value: 800 },  // Blue
        { min: 11, max: 20, name: "600æ¡£", color: "#C8E6C9", value: 600 }, // Green
        { min: 21, max: 44, name: "400æ¡£", color: "#FFF9C4", value: 400 }, // Yellow
        { min: 45, max: 50, name: "200æ¡£", color: "#F5F5F5", value: 200 }  // Gray
    ];
    let giftImages = []; // Array of base64 strings or objects { url: ..., desc: ... }

    function openYearModal() {
        const sel = document.getElementById('yearSelect');
        if (sel.options.length === 0) {
            const now = new Date().getFullYear();
            for (let y = now - 5; y <= now + 1; y++) {
                const opt = document.createElement('option');
                opt.value = y;
                opt.textContent = y;
                sel.appendChild(opt);
            }
            sel.value = String(now);
        }
        openModal('yearModal');
    }

    async function confirmYearSelection() {
        const y = parseInt(document.getElementById('yearSelect').value);
        if (!y || isNaN(y)) return;
        currentYear = y;
        
        const passInput = document.getElementById('yearPasscode');
        const pass = (passInput && passInput.value) ? passInput.value.trim() : '';
        
        if (pass.length > 0) {
             if (pass === 'sd502502') {
                 isAdmin = true;
             } else {
                 alert('ç®¡ç†å£ä»¤é”™è¯¯ï¼');
                 return;
             }
        } else {
             isAdmin = false;
        }

        // Show loader
        const loader = document.getElementById('pageLoader');
        if (loader) {
            loader.style.display = 'flex';
            // Ensure opacity is reset (since init() fades it out)
            requestAnimationFrame(() => {
                loader.style.opacity = '1';
            });
        }

        closeModal('yearModal');
        await initSupabase();
        await loadYearData(y);
        updateHeaderYear();
        updateCalculatorDropdowns();
        renderWishDropdowns();
        updateTable();
        updateFinalRanking();
        applyRoleUI();

        // Hide loader with a small delay
        if (loader) {
            // Fade out effect
            loader.style.opacity = '0';
            setTimeout(() => {
                loader.style.display = 'none';
            }, 500);
        }
    }

    function applyRoleUI() {
        const show = (el) => { if (el) el.style.display = ''; };
        const hide = (el) => { if (el) el.style.display = 'none'; };

        if (isAdmin) {
            show(document.getElementById('headerSettingsBtn'));
            show(document.getElementById('btnCalcSettings'));
            show(document.getElementById('btnCalcImport'));
            show(document.getElementById('calcFormSection')); // Show wrapper
            show(document.getElementById('btnClearHandData'));

            show(document.getElementById('btnWishSettings'));
            show(document.getElementById('btnWishImport'));
            show(document.getElementById('btnWishClear'));
            show(document.getElementById('wishFormSection'));

            show(document.getElementById('btnTeamImport'));
            show(document.getElementById('btnTeamClear'));
            show(document.getElementById('teamFormSection'));
        } else {
            hide(document.getElementById('headerSettingsBtn'));
            hide(document.getElementById('btnCalcSettings'));
            hide(document.getElementById('btnCalcImport'));
            hide(document.getElementById('calcFormSection')); // Hide wrapper
            hide(document.getElementById('btnClearHandData'));

            hide(document.getElementById('btnWishSettings'));
            hide(document.getElementById('btnWishImport'));
            hide(document.getElementById('btnWishClear'));
            hide(document.getElementById('wishFormSection'));

            hide(document.getElementById('btnTeamImport'));
            hide(document.getElementById('btnTeamClear'));
            hide(document.getElementById('teamFormSection'));
        }
    }

    function updateHeaderYear() {
        const h1 = document.querySelector('h1');
        if (h1 && currentYear) {
            h1.textContent = `${currentYear}å¹´åœ£è¯å¤§å†’é™©ç»Ÿè®¡`;
            document.title = `${currentYear}å¹´åœ£è¯å¤§å†’é™©ç»Ÿè®¡`;
        }
    }

    async function initSupabase() {
        if (!supabaseClient) {
            supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }
    }

    async function loadYearData(year) {
        if (!supabaseClient) return;
        const { data: teams } = await supabaseClient.from('teams').select('*').eq('year', year).order('sort_key', { ascending: true });
        const { data: wishes } = await supabaseClient.from('wishes').select('*').eq('year', year);
        const { data: hands } = await supabaseClient.from('hands').select('*').eq('year', year);
        
        // Load Settings (Tiers & Images)
        const { data: settings } = await supabaseClient.from('settings').select('*').eq('year', year);
        if (settings) {
            const tiersSetting = settings.find(s => s.key === 'gift_tiers');
            if (tiersSetting) giftTiers = tiersSetting.value;
            
            const imagesSetting = settings.find(s => s.key === 'gift_images');
            if (imagesSetting) giftImages = imagesSetting.value;
        }

        teamList = (teams || []).map(t => ({ 
            id: `${year}-${t.serial}`, 
            serial: String(t.serial), 
            name: t.name, 
            members: t.members || [], 
            count: t.count || 0, 
            time: t.time || '', 
            sortKey: t.sort_key || 0,
            gifts: t.gifts || {} // Load gifts
        }));
        wishList = (wishes || []).map(w => ({ serial: String(w.serial), team: w.team_name || '', wishes: Array.isArray(w.wishes) ? w.wishes : (w.wishes ? Object.values(w.wishes) : [0,0,0,0,0]), total: w.total || 0 }));
        handHistory = (hands || []).map(h => ({ id: `${year}-${h.serial}`, serial: String(h.serial), team: h.team_name || '', handTypeName: h.hand_type_name || '', cards: Array.isArray(h.cards) ? h.cards : [], score: h.hand_raw_score || 0 }));
        
        renderTeamList();
        renderWishRanking();
        handHistory.sort((a, b) => b.score - a.score);
        updateTable();
        
        // Update UI components that depend on data
        renderGiftTiersConfig();
        renderGiftTierLegend();
        renderGiftImagesPreview();
        
        // Refresh active tab content if necessary
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab) {
            if (activeTab.id === 'tab-gifts') {
                renderGiftSelection();
            } else if (activeTab.id === 'tab-final') {
                updateFinalRanking();
            }
        }
    }

    async function upsertTeams(rows) {
        if (!supabaseClient || !currentYear) return;
        const payload = rows.map(t => ({ 
            year: currentYear, 
            serial: String(t.serial), 
            name: t.name, 
            members: t.members, 
            count: t.count, 
            time: t.time, 
            sort_key: t.sortKey,
            gifts: t.gifts // Persist gifts
        }));
        await supabaseClient.from('teams').upsert(payload, { onConflict: 'year,serial' });
    }

    async function deleteTeamInCloud(serial) {
        if (!supabaseClient || !currentYear) return;
        await supabaseClient.from('teams').delete().eq('year', currentYear).eq('serial', String(serial));
    }

    async function upsertWishes(rows) {
        if (!supabaseClient || !currentYear) return;
        const payload = rows.map(w => ({ year: currentYear, serial: String(w.serial), team_name: w.team, wishes: w.wishes, total: w.total }));
        await supabaseClient.from('wishes').upsert(payload, { onConflict: 'year,serial' });
    }

    async function deleteWishInCloud(serial) {
        if (!supabaseClient || !currentYear) return;
        await supabaseClient.from('wishes').delete().eq('year', currentYear).eq('serial', String(serial));
    }

    async function upsertHands(rows) {
        if (!supabaseClient || !currentYear) return;
        const payload = rows.map(h => ({ year: currentYear, serial: String(h.serial), team_name: h.team, hand_type_name: h.handTypeName, cards: h.cards, hand_points: 0, hand_raw_score: h.score }));
        await supabaseClient.from('hands').upsert(payload, { onConflict: 'year,serial' });
    }

    async function deleteHandsInCloud(serial) {
        if (!supabaseClient || !currentYear) return;
        await supabaseClient.from('hands').delete().eq('year', currentYear).eq('serial', String(serial));
    }

    async function upsertFinalRanking(rows) {
        if (!supabaseClient || !currentYear) return;
        const payload = rows.map(r => ({ year: currentYear, serial: String(r.serial), team_name: r.team, members: r.members ? r.members.split(',').map(m => m.trim()).filter(Boolean) : [], wish_total: r.wishTotal, wish_points: r.wishPoints, hand_type_name: r.handTypeName, hand_cards: r.handCards, hand_points: r.handPoints, hand_raw_score: r.handRawScore, final_score: r.finalScore, rank: r.rank }));
        await supabaseClient.from('final_rankings').upsert(payload, { onConflict: 'year,serial' });
    }

    function updateTotalTeams() {
        const input = document.getElementById('totalTeamsInput');
        const val = parseInt(input.value);
        if (!isNaN(val) && val > 0) {
            totalTeams = val;
            updateTable();
            renderWishRanking(); // Also update wish ranking
        }
    }

    // Tab Switching
    function switchTab(tabId) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
        
        document.getElementById('tab-' + tabId).classList.add('active');
        // Find button
        const btns = document.querySelectorAll('.tab-btn');
        if (tabId === 'calc') {
            btns[0].classList.add('active');
            updateCalculatorDropdowns();
        }
        if (tabId === 'wishes') {
            btns[1].classList.add('active');
            renderWishDropdowns();
        }
        if (tabId === 'teams') {
            btns[2].classList.add('active');
        }
        if (tabId === 'final') {
            btns[3].classList.add('active');
            updateFinalRanking();
        }
        if (tabId === 'gifts') {
            btns[4].classList.add('active');
            renderGiftSelection();
        }
    }

    function getFinalRankingData() {
        // 1. Ensure Wish Points are up to date
        // Note: We don't call renderWishRanking() here to avoid side effects (DOM updates) if just exporting.
        // But we need the points. wishList entries have points if renderWishRanking ran.
        // To be safe, we can force update wishList points without rendering? 
        // Actually, let's just recalculate points locally to be purely functional.
        
        // Calculate Wish Points
        // Sort a copy to avoid mutating global wishList unexpectedly if that matters (though usually we want them synced)
        const sortedWishes = [...wishList].sort((a, b) => b.total - a.total);
        const wishPointsMap = {};
        let wishRank = 1;
        sortedWishes.forEach((entry, index) => {
            if (index > 0 && entry.total === sortedWishes[index-1].total) {
                // Tie
            } else {
                wishRank = index + 1;
            }
            const points = totalTeams - wishRank + 1;
            wishPointsMap[entry.serial] = {
                points: points,
                total: entry.total,
                team: entry.team
            };
        });

        // Calculate Hand Points
        const sortedHands = [...handHistory].sort((a, b) => b.score - a.score);
        const handPointsMap = {};
        let handRank = 1;
        sortedHands.forEach((entry, index) => {
            if (index > 0 && entry.score === sortedHands[index-1].score) {
                // Tie
            } else {
                handRank = index + 1;
            }
            const points = totalTeams - handRank + 1;
            handPointsMap[entry.serial] = {
                points: points,
                handTypeName: entry.handTypeName,
                cards: entry.cards,
                team: entry.team,
                score: entry.score // Include raw score for tie-breaking
            };
        });

        // Aggregate
        const allSerials = new Set();
        teamList.forEach(t => allSerials.add(t.serial));
        wishList.forEach(w => allSerials.add(w.serial));
        handHistory.forEach(h => allSerials.add(h.serial));

        const ranking = [];

        allSerials.forEach(serial => {
            const teamEntry = teamList.find(t => t.serial === serial);
            const wishData = wishPointsMap[serial];
            const handData = handPointsMap[serial];

            // Name resolution
            let teamName = "æœªçŸ¥é˜Ÿä¼";
            if (teamEntry) teamName = teamEntry.name;
            else if (handData) teamName = handData.team;
            else if (wishData) teamName = wishData.team;

            const members = teamEntry ? teamEntry.members.join(', ') : "";
            const wishTotal = wishData ? wishData.total : 0;
            const wishPoints = wishData ? wishData.points : 0; // 0 points if not in wish list
            
            const handTypeName = handData ? handData.handTypeName : "-";
            const handCards = handData ? handData.cards : [];
            const handPoints = handData ? handData.points : 0;
            const handRawScore = handData ? handData.score : 0;

            const finalScore = wishPoints + handPoints;

            ranking.push({
                serial: serial,
                team: teamName,
                members: members,
                wishTotal: wishTotal,
                wishPoints: wishPoints,
                handTypeName: handTypeName,
                handCards: handCards,
                handPoints: handPoints,
                handRawScore: handRawScore,
                finalScore: finalScore
            });
        });

        // Sort by Final Score, then by Hand Raw Score
        ranking.sort((a, b) => {
            if (b.finalScore !== a.finalScore) {
                return b.finalScore - a.finalScore;
            }
            // Tie-breaker: Hand Strength
            return b.handRawScore - a.handRawScore;
        });
        
        // Assign Final Ranks
        let finalRank = 1;
        ranking.forEach((item, index) => {
            // Check for tie in both Final Score AND Hand Raw Score
            if (index > 0 && 
                item.finalScore === ranking[index-1].finalScore && 
                item.handRawScore === ranking[index-1].handRawScore) {
                // Tie
            } else {
                finalRank = index + 1;
            }
            item.rank = finalRank;
        });

        return ranking;
    }

    // Hand Type Filter Logic
    let selectedHandTypes = [];

    function initHandTypeFilter() {
        const container = document.getElementById('handTypeList');
        if (!container) return;
        container.innerHTML = '';
        
        HAND_TYPES.forEach(type => {
            const div = document.createElement('div');
            div.style.padding = '8px';
            div.style.borderBottom = '1px solid #f5f5f5';
            
            div.innerHTML = `
                <label style="cursor: pointer; display: flex; align-items: center; width: 100%; margin: 0;">
                    <input type="checkbox" value="${type.name}" onchange="updateHandTypeSelection()" style="margin-right: 8px;"> 
                    ${type.name}
                </label>
            `;
            container.appendChild(div);
        });
    }

    function toggleHandTypeDropdown() {
        const dropdown = document.getElementById('handTypeDropdown');
        const current = dropdown.style.display;
        
        // Close card dropdowns (remove .show class)
        if (typeof closeAllDropdowns === 'function') {
            closeAllDropdowns();
        }
        
        // Clear inline display style from other dropdowns (fix for potential conflicts)
        document.querySelectorAll('.dropdown-menu').forEach(d => {
            if (d !== dropdown) d.style.display = ''; 
        });

        // Toggle current
        dropdown.style.display = (current === 'block') ? 'none' : 'block';
        
        if (dropdown.style.display === 'block') {
            setTimeout(() => {
                document.addEventListener('click', closeHandTypeDropdownOutside);
            }, 0);
        }
    }

    function closeHandTypeDropdownOutside(e) {
        const dropdown = document.getElementById('handTypeDropdown');
        const btn = document.getElementById('handTypeDropdownBtn');
        if (dropdown && !dropdown.contains(e.target) && !btn.contains(e.target)) {
            dropdown.style.display = 'none';
            document.removeEventListener('click', closeHandTypeDropdownOutside);
        }
    }

    function updateHandTypeSelection() {
        const checkboxes = document.querySelectorAll('#handTypeList input[type="checkbox"]');
        selectedHandTypes = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
        
        const btn = document.getElementById('handTypeDropdownBtn');
        const span = btn.querySelector('span');
        
        if (selectedHandTypes.length === 0) {
            span.textContent = 'é€‰æ‹©ç‰Œå‹';
            btn.style.borderColor = '#ccc';
            btn.style.background = 'white';
            btn.style.color = '#333';
        } else if (selectedHandTypes.length === HAND_TYPES.length) {
            span.textContent = 'å…¨éƒ¨ç‰Œå‹';
            btn.style.borderColor = '#165B33';
            btn.style.background = '#e8f5e9';
            btn.style.color = '#165B33';
        } else {
            span.textContent = `å·²é€‰ ${selectedHandTypes.length} é¡¹`;
            btn.style.borderColor = '#165B33';
            btn.style.background = '#e8f5e9';
            btn.style.color = '#165B33';
        }
        
        // Check/Uncheck "Select All" based on selection
        const allCb = document.querySelector('#handTypeDropdown input[onclick*="toggleAllHandTypes"]');
        if (allCb) {
             allCb.checked = (checkboxes.length > 0 && selectedHandTypes.length === checkboxes.length);
        }

        updateFinalRanking();
    }

    function toggleAllHandTypes(source) {
        const checkboxes = document.querySelectorAll('#handTypeList input[type="checkbox"]');
        checkboxes.forEach(cb => cb.checked = source.checked);
        updateHandTypeSelection();
    }

    function filterFinalRanking(data) {
        const sSerial = document.getElementById('searchSerial').value.trim().toLowerCase();
        const sTeam = document.getElementById('searchTeam').value.trim().toLowerCase();
        const sMembers = document.getElementById('searchMembers').value.trim().toLowerCase();
        const sWishMin = parseFloat(document.getElementById('searchWishMin').value);
        const sWishMax = parseFloat(document.getElementById('searchWishMax').value);
        
        return data.filter(item => {
            // Serial: Exact match (if provided)
            if (sSerial && String(item.serial).toLowerCase() !== sSerial) return false;

            // Team Name: Fuzzy match
            if (sTeam && !String(item.team).toLowerCase().includes(sTeam)) return false;

            // Members: Fuzzy match
            if (sMembers && !String(item.members).toLowerCase().includes(sMembers)) return false;

            // Wish Score Range
            if (!isNaN(sWishMin) && item.wishTotal < sWishMin) return false;
            if (!isNaN(sWishMax) && item.wishTotal > sWishMax) return false;

            // Hand Type: Multi-select
            if (selectedHandTypes.length > 0 && !selectedHandTypes.includes(item.handTypeName)) return false;

            return true;
        });
    }

    function clearFinalSearch() {
        document.getElementById('searchSerial').value = '';
        document.getElementById('searchTeam').value = '';
        document.getElementById('searchMembers').value = '';
        document.getElementById('searchWishMin').value = '';
        document.getElementById('searchWishMax').value = '';
        
        // Reset Hand Type Filter
        const checkboxes = document.querySelectorAll('#handTypeList input[type="checkbox"]');
        checkboxes.forEach(cb => cb.checked = false);
        const allCb = document.querySelector('#handTypeDropdown input[onclick*="toggleAllHandTypes"]');
        if (allCb) allCb.checked = false;
        
        updateHandTypeSelection();
    }

    function updateFinalRanking() {
        const data = getFinalRankingData();
        const filteredData = filterFinalRanking(data);
        const tbody = document.querySelector('#finalRankingTable tbody');
        const thead = document.querySelector('#finalRankingTable thead tr');
        
        // Ensure "Gift Tier" header exists
        if (!thead.querySelector('.th-gift-tier')) {
            const th = document.createElement('th');
            th.className = 'th-gift-tier';
            th.textContent = 'ç¤¼ç‰©æ¡£ä½';
            // Insert after Rank (1st column)
            thead.insertBefore(th, thead.children[1]);
        }
        
        tbody.innerHTML = '';

        filteredData.forEach(item => {
            const tr = document.createElement('tr');
            
            // Determine Gift Tier based on Rank
            const tier = giftTiers.find(t => item.rank >= t.min && item.rank <= t.max);
            const tierName = tier ? tier.name : "-";
            const tierColor = tier ? tier.color : "";
            
            if (tierColor) {
                tr.style.backgroundColor = tierColor;
            }
            
            // æœ€ç»ˆæ’å
            tr.innerHTML += `<td>${item.rank}</td>`;
            
            // ç¤¼ç‰©æ¡£ä½
            tr.innerHTML += `<td>${tierName}</td>`;
            
            // åºå·
            tr.innerHTML += `<td>${item.serial}</td>`;
            // é˜Ÿä¼åç§°
            const nameDisplay = isImage(item.team) ? `<img src="${item.team}" style="height:30px; vertical-align:middle;">` : item.team;
            tr.innerHTML += `<td>${nameDisplay}</td>`;
            // æˆå‘˜
            tr.innerHTML += `<td>${item.members}</td>`;
            // å¿ƒæ„¿æ€»è®¡
            tr.innerHTML += `<td>${item.wishTotal}</td>`;
            // å¿ƒæ„¿ç§¯åˆ†
            tr.innerHTML += `<td>${item.wishPoints}</td>`;
            // ç‰Œå‹åç§°
            tr.innerHTML += `<td>${item.handTypeName}</td>`;
            // ç‰Œé¢
            const cardTd = document.createElement('td');
            if (item.handCards.length > 0) {
                 item.handCards.forEach(c => {
                     const s = document.createElement('span');
                     s.className = `card ${c.color === 'red' ? 'suit-red' : 'suit-black'}`;
                     s.textContent = `${c.suit}${c.rankLabel}`;
                     cardTd.appendChild(s);
                 });
            } else {
                cardTd.textContent = "-";
            }
            tr.appendChild(cardTd);
            
            // ç‰Œå‹ç§¯åˆ†
            tr.innerHTML += `<td>${item.handPoints}</td>`;
            // æœ€ç»ˆåˆ†æ•°
            tr.innerHTML += `<td style="font-weight:bold; color:#d9534f; font-size:1.1em;">${item.finalScore}</td>`;
            
            tbody.appendChild(tr);
        });
    }

    function exportFinalRanking() {
        const data = getFinalRankingData();
        if (data.length === 0) {
            alert('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
            return;
        }

        const exportData = data.map(item => {
            const cardStr = item.handCards.map(c => `${c.suit}${c.rankLabel}`).join(' ');
            return {
                "æœ€ç»ˆæ’å": item.rank,
                "åºå·": item.serial,
                "é˜Ÿä¼åç§°": isImage(item.team) ? "[å›¾ç‰‡é˜Ÿä¼]" : item.team,
                "æˆå‘˜": item.members,
                "å¿ƒæ„¿æ€»è®¡": item.wishTotal,
                "å¿ƒæ„¿ç§¯åˆ†": item.wishPoints,
                "ç‰Œå‹åç§°": item.handTypeName,
                "ç‰Œé¢": cardStr,
                "ç‰Œå‹ç§¯åˆ†": item.handPoints,
                "æœ€ç»ˆåˆ†æ•°": item.finalScore
            };
        });

        upsertFinalRanking(data);
        const ws = XLSX.utils.json_to_sheet(exportData);
        
        // Column widths
        const wscols = [
            {wch: 8},  // æ’å
            {wch: 10}, // åºå·
            {wch: 20}, // é˜Ÿä¼
            {wch: 30}, // æˆå‘˜
            {wch: 10}, // å¿ƒæ„¿æ€»è®¡
            {wch: 10}, // å¿ƒæ„¿ç§¯åˆ†
            {wch: 15}, // ç‰Œå‹
            {wch: 20}, // ç‰Œé¢
            {wch: 10}, // ç‰Œå‹ç§¯åˆ†
            {wch: 10}  // æœ€ç»ˆåˆ†æ•°
        ];
        ws['!cols'] = wscols;

        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "æœ€ç»ˆæ€»æ¦œ");
        
        const date = new Date();
        const dateStr = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        const timeStr = `${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}`;
        
        try {
             XLSX.writeFile(wb, `æœ€ç»ˆæ€»æ¦œ_${dateStr}_${timeStr}.xlsx`);
        } catch (e) {
             alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }

    function updateCalculatorDropdowns() {
        const serialSelect = document.getElementById('serialInput');
        const teamSelect = document.getElementById('teamInput');
        
        // Save current selection
        const currentSerial = serialSelect.value;
        const currentTeam = teamSelect.value;

        serialSelect.innerHTML = '<option value="">åºå·</option>';
        teamSelect.innerHTML = '<option value="">é˜Ÿä¼åç§°</option>';
        
        // Sort by serial
        const sortedList = [...teamList].sort((a, b) => {
            const na = parseInt(a.serial);
            const nb = parseInt(b.serial);
            if (!isNaN(na) && !isNaN(nb)) return na - nb;
            return String(a.serial).localeCompare(String(b.serial));
        });

        sortedList.forEach(team => {
            const optSerial = document.createElement('option');
            optSerial.value = team.serial;
            optSerial.textContent = team.serial;
            serialSelect.appendChild(optSerial);
            
            const optName = document.createElement('option');
            optName.value = team.name;
            optName.textContent = isImage(team.name) ? `åºå· ${team.serial} - [å›¾ç‰‡é˜Ÿä¼]` : team.name;
            teamSelect.appendChild(optName);
        });

        // Restore selection if valid
        if (currentSerial && sortedList.some(t => t.serial === currentSerial)) serialSelect.value = currentSerial;
        if (currentTeam && sortedList.some(t => t.name === currentTeam)) teamSelect.value = currentTeam;
    }

    function syncTeamInput(source) {
        const serialSelect = document.getElementById('serialInput');
        const teamSelect = document.getElementById('teamInput');
        
        if (source === 'serial') {
            const serial = serialSelect.value;
            const team = teamList.find(t => t.serial === serial);
            if (team) {
                teamSelect.value = team.name;
            } else {
                teamSelect.value = "";
            }
        } else if (source === 'team') {
            const name = teamSelect.value;
            const team = teamList.find(t => t.name === name);
            if (team) {
                serialSelect.value = team.serial;
            } else {
                serialSelect.value = "";
            }
        }
    }

    // Team Management
    let teamList = [];
    let currentTeamImageData = null;
    let currentEditingTeamId = null;

    function isImage(str) {
        return typeof str === 'string' && str.startsWith('data:image');
    }

    function handleTeamImageSelect(input) {
        const file = input.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            currentTeamImageData = e.target.result;
            // Update preview
            document.getElementById('teamNamePreviewImg').src = currentTeamImageData;
            document.getElementById('teamNamePreview').style.display = 'flex';
            document.getElementById('teamName').disabled = true;
            document.getElementById('teamName').placeholder = "(å·²é€‰æ‹©å›¾ç‰‡é˜Ÿå)";
            document.getElementById('teamName').value = "";
        };
        reader.readAsDataURL(file);
    }

    function clearTeamImage() {
        currentTeamImageData = null;
        document.getElementById('teamNameImageInput').value = ''; // Reset file input
        document.getElementById('teamNamePreview').style.display = 'none';
        document.getElementById('teamName').disabled = false;
        document.getElementById('teamName').placeholder = "é˜Ÿä¼åç§°";
    }

    function editTeam(id) {
        const team = teamList.find(t => t.id === id);
        if (!team) return;

        currentEditingTeamId = id;
        
        // Populate inputs
        document.getElementById('teamSerial').value = team.serial;
        document.getElementById('teamMembers').value = team.members.join(' ');
        document.getElementById('teamTime').value = team.time;
        
        // Handle name (text or image)
        if (isImage(team.name)) {
            currentTeamImageData = team.name;
            document.getElementById('teamNamePreviewImg').src = currentTeamImageData;
            document.getElementById('teamNamePreview').style.display = 'flex';
            document.getElementById('teamName').disabled = true;
            document.getElementById('teamName').placeholder = "(å·²é€‰æ‹©å›¾ç‰‡é˜Ÿå)";
            document.getElementById('teamName').value = "";
        } else {
            clearTeamImage();
            document.getElementById('teamName').value = team.name;
        }

        // Update UI state
        document.getElementById('saveTeamBtn').textContent = 'æ›´æ–°é˜Ÿä¼';
        document.getElementById('saveTeamBtn').style.backgroundColor = 'var(--xmas-green)';
        document.getElementById('cancelTeamEditBtn').style.display = 'inline-block';
        
        // Scroll to form
        document.querySelector('.toolbar').scrollIntoView({ behavior: 'smooth' });
    }

    function cancelTeamEdit() {
        currentEditingTeamId = null;
        
        // Clear inputs
        document.getElementById('teamSerial').value = '';
        document.getElementById('teamName').value = '';
        document.getElementById('teamMembers').value = '';
        document.getElementById('teamTime').value = '';
        clearTeamImage();
        
        // Reset UI state
        document.getElementById('saveTeamBtn').textContent = 'ä¿å­˜é˜Ÿä¼';
        document.getElementById('saveTeamBtn').style.backgroundColor = ''; // Reset to default (usually inherited or empty)
        document.getElementById('cancelTeamEditBtn').style.display = 'none';
    }
    
    function saveTeam() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        const serial = document.getElementById('teamSerial').value.trim();
        let name = document.getElementById('teamName').value.trim();
        const membersStr = document.getElementById('teamMembers').value.trim();
        const time = document.getElementById('teamTime').value.trim();
        
        // Use image if selected
        if (currentTeamImageData) {
            name = currentTeamImageData;
        }

        if (!serial || !name || !time) {
            alert('è¯·å¡«å†™åºå·ã€é˜Ÿä¼åç§°(æˆ–ä¸Šä¼ å›¾ç‰‡)å’Œé¢„çº¦æ—¶é—´');
            return;
        }
        
        const members = membersStr.split(/[,ï¼Œ\s]+/).filter(m => m);
        
        const teamData = {
            serial: serial,
            name: name,
            members: members,
            count: members.length,
            time: time,
            sortKey: parseTimeKey(time)
        };
        
        if (currentEditingTeamId) {
            // Editing existing team
            const index = teamList.findIndex(t => t.id === currentEditingTeamId);
            if (index !== -1) {
                // Check serial conflict with OTHER teams
                const conflict = teamList.find(t => t.serial === serial && t.id !== currentEditingTeamId);
                if (conflict) {
                    alert(`åºå· ${serial} å·²è¢«é˜Ÿä¼ "${isImage(conflict.name) ? '[å›¾ç‰‡é˜Ÿä¼]' : conflict.name}" å ç”¨ï¼Œè¯·æ›´æ¢åºå·`);
                    return;
                }
                
                // Update
                teamList[index] = {
                    ...teamList[index],
                    ...teamData
                };
                cancelTeamEdit();
            }
        } else {
            // Adding new team
            const team = {
                id: Date.now().toString(),
                ...teamData
            };
            
            // Check if serial exists
            const existIdx = teamList.findIndex(t => t.serial === serial);
            if (existIdx >= 0) {
                if (confirm(`åºå· ${serial} å·²å­˜åœ¨ (${isImage(teamList[existIdx].name) ? '[å›¾ç‰‡é˜Ÿå]' : teamList[existIdx].name})ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) {
                    teamList[existIdx] = {
                        ...teamList[existIdx], // Keep ID
                        ...teamData
                    };
                } else {
                    return;
                }
            } else {
                teamList.push(team);
            }
            
            // Clear inputs
            document.getElementById('teamSerial').value = '';
            document.getElementById('teamName').value = '';
            document.getElementById('teamMembers').value = '';
            document.getElementById('teamTime').value = '';
            clearTeamImage();
        }
        
        renderTeamList();
        upsertTeams([teamData]);
    }
    
    function clearTeamData() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if (confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰é˜Ÿä¼æ•°æ®å—ï¼Ÿ')) {
            teamList = [];
            if (supabaseClient && currentYear) supabaseClient.from('teams').delete().eq('year', currentYear);
            renderTeamList();
        }
    }
    
    function parseTimeKey(timeStr) {
        // Format: 11.24(å‘¨ä¸€)ä¸‹åˆ18:00
        // Regex to find Month.Day and Hour:Minute
        // Support variants: 11.24, 11æœˆ24æ—¥, 18:00, 18ç‚¹00
        try {
            const dateMatch = timeStr.match(/(\d{1,2})[.\æœˆ](\d{1,2})/);
            // Support : ï¼š or ç‚¹ for time separator
            const timeMatch = timeStr.match(/(\d{1,2})[:ï¼šç‚¹](\d{0,2})/);
            
            let val = 0;
            if (dateMatch) {
                val += parseInt(dateMatch[1]) * 1000000; // Month
                val += parseInt(dateMatch[2]) * 10000;   // Day
            }
            if (timeMatch) {
                let hour = parseInt(timeMatch[1]);
                // If minute part is empty (e.g. "18ç‚¹"), treat as 0
                let minute = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
                if (isNaN(minute)) minute = 0;
                
                val += hour * 100;
                val += minute;
            }
            return val;
        } catch (e) {
            return 0;
        }
    }
    
    function getDayLabel(timeStr) {
        // Extract "11.24(å‘¨ä¸€)" part
        const match = timeStr.match(/(\d{1,2}[.\æœˆ]\d{1,2}(?:\(å‘¨[ä¸€äºŒä¸‰å››äº”å…­æ—¥]\))?)/);
        return match ? match[1] : 'å…¶ä»–æ—¶é—´';
    }

    function renderTeamList() {
        const container = document.getElementById('teamListContainer');
        container.innerHTML = '';
        
        // Sort by time
        teamList.sort((a, b) => a.sortKey - b.sortKey);
        
        // Group by Day
        const groups = {};
        teamList.forEach(team => {
            const day = getDayLabel(team.time);
            if (!groups[day]) groups[day] = [];
            groups[day].push(team);
        });
        
        Object.keys(groups).forEach(day => {
            const groupDiv = document.createElement('div');
            
            const header = document.createElement('div');
            header.className = 'team-group-header';
            header.textContent = day;
            groupDiv.appendChild(header);
            
            const table = document.createElement('table');
            table.className = 'team-list-table';
            table.innerHTML = `
                <thead>
                    <tr style="background:#fff; border-bottom:2px solid #eee; font-size:12px; color:#888;">
                        <th style="text-align:left; width:80px;">æ—¶é—´</th>
                        <th style="text-align:left; width:60px;">åºå·</th>
                        <th style="text-align:left; width:150px;">é˜Ÿä¼åç§°</th>
                        <th style="text-align:left;">æˆå‘˜</th>
                        <th style="text-align:center; width:50px;">äººæ•°</th>
                        ${isAdmin ? '<th style="text-align:center; width:60px;">æ“ä½œ</th>' : ''}
                    </tr>
                </thead>
                <tbody></tbody>
            `;
            
            const tbody = table.querySelector('tbody');
            groups[day].forEach(team => {
                const tr = document.createElement('tr');
                // Extract just time part for display if possible, or show full?
                // User requirement: "åˆ—è¡¨æŒ‰ç…§é¢„çº¦æ—¶é—´æ’åº"
                // Let's show the time part (e.g. 18:00) in first col
                const timeMatch = team.time.match(/\d{1,2}[:ï¼š]\d{1,2}/);
                const shortTime = timeMatch ? timeMatch[0] : team.time;
                
                const membersHtml = team.members.map(m => `<span class="tag">${m}</span>`).join('');
                
                const nameDisplay = isImage(team.name) ? `<img src="${team.name}" style="height:30px; vertical-align:middle;">` : team.name;

                tr.innerHTML = `
                    <td>${shortTime}</td>
                    <td><span style="font-weight:bold; color:#007bff;">${team.serial}</span></td>
                    <td>${nameDisplay}</td>
                    <td>${membersHtml}</td>
                    <td style="text-align:center;">${team.count}</td>
                    ${isAdmin ? `<td style="text-align:center;">\n                        <button onclick=\"editTeam('${team.id}')\" style=\"padding:2px 5px; font-size:12px; background:#007bff; margin-right:5px;\">ç¼–è¾‘</button>\n                        <button onclick=\"deleteTeam('${team.id}')\" style=\"padding:2px 5px; font-size:12px; background:#dc3545;\">åˆ é™¤</button>\n                    </td>` : ''}
                `;
                tbody.appendChild(tr);
            });
            
            groupDiv.appendChild(table);
            container.appendChild(groupDiv);
        });
    }
    
    function deleteTeam(id) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if (confirm('ç¡®å®šåˆ é™¤æ­¤é˜Ÿä¼å—ï¼Ÿ')) {
            const del = teamList.find(t => t.id === id);
            teamList = teamList.filter(t => t.id !== id);
            if (del) deleteTeamInCloud(del.serial);
            renderTeamList();
        }
    }

    function exportTeams() {
        if (teamList.length === 0) {
            alert('æ²¡æœ‰é˜Ÿä¼æ•°æ®å¯å¯¼å‡º');
            return;
        }

        // Sort by time (same as display)
        const sortedList = [...teamList].sort((a, b) => a.sortKey - b.sortKey);

        const data = sortedList.map(team => {
            return {
                "åºå·": team.serial,
                "é˜Ÿä¼åç§°": isImage(team.name) ? "[å›¾ç‰‡é˜Ÿä¼]" : team.name,
                "æˆå‘˜": team.members.join(', '),
                "äººæ•°": team.count,
                "é¢„çº¦æ—¶é—´": team.time
            };
        });

        const ws = XLSX.utils.json_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "é˜Ÿä¼åˆ—è¡¨");

        // Generate filename
        const date = new Date();
        const dateStr = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        const timeStr = `${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}`;
        const filename = `é˜Ÿä¼åˆ—è¡¨_${dateStr}_${timeStr}.xlsx`;

        try {
            XLSX.writeFile(wb, filename);
        } catch (e) {
            alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }

    function handleTeamFileUpload(event) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                
                let successCount = 0;
                
                // Analyze header to find columns
                let startRow = 0;
                let colSerial = -1;
                let colName = -1;
                let colTime = -1;
                let headerRow = [];
                
                // Find header row
                for(let i=0; i<Math.min(20, jsonData.length); i++) { // Increased search range
                    // Handle sparse arrays by using Array.from to fill holes with undefined, then map
                    const rawRow = jsonData[i] || [];
                    const row = Array.from(rawRow).map(c => String(c || '').trim());
                    
                    // Check for key columns
                    if (row.some(c => c.includes('é˜Ÿä¼åç§°') || c.includes('Team'))) {
                        startRow = i + 1;
                        headerRow = row;
                        colSerial = row.findIndex(c => c.includes('åºå·') || c.includes('No') || c.includes('ID'));
                        colName = row.findIndex(c => c.includes('é˜Ÿä¼åç§°') || c.includes('Team'));
                        colTime = row.findIndex(c => c.includes('é¢„çº¦æ—¶é—´') || c.includes('Time') || c.includes('Date'));
                        break;
                    }
                }
                
                if (colName === -1) {
                    throw new Error("æœªæ‰¾åˆ°'é˜Ÿä¼åç§°'åˆ—ï¼Œè¯·æ£€æŸ¥è¡¨å¤´");
                }
                if (colTime === -1) {
                    // Try to guess if not found explicitly? 
                    // Maybe look for a column with date-like strings in first data row?
                    // For now, let's assume it exists or warn.
                    console.warn("æœªæ‰¾åˆ°'é¢„çº¦æ—¶é—´'åˆ—ï¼Œå°†è·³è¿‡æ—¶é—´è§£æ");
                }
                
                for (let i = startRow; i < jsonData.length; i++) {
                    const row = jsonData[i];
                    if (!row || row.length === 0) continue;
                    
                    // Helper to safely get cell value
                    const getVal = (idx) => {
                        if (idx < 0 || idx >= row.length) return '';
                        return String(row[idx] || '').trim().replace(/[\r\n]+/g, ' '); // Replace newlines with space
                    };
                    
                    const serial = colSerial !== -1 ? getVal(colSerial) : '';
                    let name = getVal(colName);
                    const time = colTime !== -1 ? getVal(colTime) : '';
                    
                    if (!name && serial) {
                        name = "(éœ€è¡¥å……å›¾ç‰‡)";
                    }
                    
                    if (!name) continue; // Skip if no name
                    
                    // Collect members
                    const members = [];
                    // Scan cols between Name and Time (or end of row if Time not found)
                    const endCol = colTime !== -1 ? colTime : row.length;
                    
                    if (colName < endCol) {
                        for (let j = colName + 1; j < endCol; j++) {
                            // Check header for "Count" or "äººæ•°"
                            // But be careful: sometimes users put names in columns labeled "äººæ•°" (e.g. "é¢†é˜Ÿäººæ•°" but filled with name)
                            // So only skip if header implies count AND value looks like a number
                            const isCountHeader = headerRow[j] && (headerRow[j].includes('äººæ•°') || headerRow[j].includes('Count'));
                            
                            const val = getVal(j);
                            
                            if (isCountHeader) {
                                // If header says count, skip only if value is numeric or like "4äºº"
                                // If it's a name (NaN), keep it
                                if (!isNaN(val) || /^\d+\s*äºº?$/.test(val)) {
                                    continue;
                                }
                            }
                            
                            // Skip empty, "äººæ•°" literal in data (unlikely if header check works), or pure numbers (double check)
                            if (val && !val.includes('äººæ•°')) {
                                // Heuristic: Member names are usually not single digits. 
                                // But strictly, we should rely on header check.
                                // If header check passed, we accept it unless it looks very wrong.
                                // Let's keep the length check but be careful.
                                if (isNaN(val) || val.length > 1) {
                                    members.push(val);
                                }
                            }
                        }
                    }
                    
                    const newTeam = {
                        id: Date.now().toString() + Math.random(),
                        serial: serial || (teamList.length + 1).toString(), // Fallback serial
                        name: name,
                        members: members,
                        count: members.length,
                        time: time,
                        sortKey: parseTimeKey(time)
                    };
                    teamList.push(newTeam);
                    successCount++;
                }
                
                renderTeamList();
                upsertTeams(teamList);
                alert(`æˆåŠŸå¯¼å…¥ ${successCount} æ”¯é˜Ÿä¼`);
                closeModal('teamImportModal');
                
            } catch (err) {
                console.error(err);
                alert('å¯¼å…¥å¤±è´¥: ' + err.message);
            }
        };
        reader.readAsArrayBuffer(file);
        event.target.value = '';
    }


    // --- Wish Calculation Functions ---

    let currentEditingWishSerial = null;

    function renderWishDropdowns() {
        const serialSelect = document.getElementById('wishSerialInput');
        const teamSelect = document.getElementById('wishTeamInput');
        
        // Save current selection
        const currentSerial = serialSelect.value;
        const currentTeam = teamSelect.value;

        serialSelect.innerHTML = '<option value="">åºå·</option>';
        teamSelect.innerHTML = '<option value="">é˜Ÿä¼åç§°</option>';
        
        // Sort by serial
        const sortedList = [...teamList].sort((a, b) => {
            const na = parseInt(a.serial);
            const nb = parseInt(b.serial);
            if (!isNaN(na) && !isNaN(nb)) return na - nb;
            return String(a.serial).localeCompare(String(b.serial));
        });

        sortedList.forEach(team => {
            const optSerial = document.createElement('option');
            optSerial.value = team.serial;
            optSerial.textContent = team.serial;
            serialSelect.appendChild(optSerial);
            
            const optName = document.createElement('option');
            optName.value = team.name;
            optName.textContent = isImage(team.name) ? `åºå· ${team.serial} - [å›¾ç‰‡é˜Ÿä¼]` : team.name;
            teamSelect.appendChild(optName);
        });

        // Restore selection if valid
        if (currentSerial && sortedList.some(t => t.serial === currentSerial)) serialSelect.value = currentSerial;
        if (currentTeam && sortedList.some(t => t.name === currentTeam)) teamSelect.value = currentTeam;
    }

    function syncWishInput(source) {
        const serialSelect = document.getElementById('wishSerialInput');
        const teamSelect = document.getElementById('wishTeamInput');
        
        if (source === 'serial') {
            const selectedSerial = serialSelect.value;
            const team = teamList.find(t => t.serial === selectedSerial);
            if (team) {
                teamSelect.value = team.name;
            } else {
                teamSelect.value = "";
            }
        } else {
            const selectedTeam = teamSelect.value;
            const team = teamList.find(t => t.name === selectedTeam);
            if (team) {
                serialSelect.value = team.serial;
            } else {
                serialSelect.value = "";
            }
        }
    }

    function saveWish() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        const serial = document.getElementById('wishSerialInput').value;
        const teamName = document.getElementById('wishTeamInput').value;
        
        if (!serial || !teamName) {
            alert('è¯·é€‰æ‹©é˜Ÿä¼');
            return;
        }

        const w1 = parseInt(document.getElementById('wish1').value) || 0;
        const w2 = parseInt(document.getElementById('wish2').value) || 0;
        const w3 = parseInt(document.getElementById('wish3').value) || 0;
        const w4 = parseInt(document.getElementById('wish4').value) || 0;
        const w5 = parseInt(document.getElementById('wish5').value) || 0;
        
        const total = w1 + w2 + w3 + w4 + w5;
        
        const wishData = {
            serial: serial,
            team: teamName,
            wishes: [w1, w2, w3, w4, w5],
            total: total
        };
        
        // Check if exists
        const index = wishList.findIndex(w => w.serial === serial);
        if (index !== -1) {
            wishList[index] = wishData;
        } else {
            wishList.push(wishData);
        }
        
        renderWishRanking();
        upsertWishes([wishData]);
        cancelWishEdit();
    }

    function cancelWishEdit() {
        document.getElementById('wishSerialInput').value = "";
        document.getElementById('wishTeamInput').value = "";
        document.getElementById('wish1').value = "";
        document.getElementById('wish2').value = "";
        document.getElementById('wish3').value = "";
        document.getElementById('wish4').value = "";
        document.getElementById('wish5').value = "";
        
        document.getElementById('saveWishBtn').textContent = 'ä¿å­˜æ•°æ®';
        document.getElementById('cancelWishEditBtn').style.display = 'none';
        currentEditingWishSerial = null;
    }

    function editWish(serial) {
        const wish = wishList.find(w => w.serial === serial);
        if (!wish) return;
        
        document.getElementById('wishSerialInput').value = wish.serial;
        // Trigger sync to set team name (or set manually)
        // syncWishInput('serial'); 
        // Better set manually to ensure correct
        const team = teamList.find(t => t.serial === serial);
        if (team) document.getElementById('wishTeamInput').value = team.name;
        else document.getElementById('wishTeamInput').value = wish.team; // Fallback
        
        document.getElementById('wish1').value = wish.wishes[0] || '';
        document.getElementById('wish2').value = wish.wishes[1] || '';
        document.getElementById('wish3').value = wish.wishes[2] || '';
        document.getElementById('wish4').value = wish.wishes[3] || '';
        document.getElementById('wish5').value = wish.wishes[4] || '';
        
        document.getElementById('saveWishBtn').textContent = 'æ›´æ–°æ•°æ®';
        document.getElementById('cancelWishEditBtn').style.display = 'inline-block';
        
        currentEditingWishSerial = serial;
    }

    function deleteWish(serial) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if(confirm('ç¡®å®šåˆ é™¤è¯¥é˜Ÿä¼çš„å¿ƒæ„¿æ•°æ®å—ï¼Ÿ')) {
            wishList = wishList.filter(w => w.serial !== serial);
            deleteWishInCloud(serial);
            renderWishRanking();
        }
    }

    function clearWishData() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if(confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰å¿ƒæ„¿æ•°æ®å—ï¼Ÿ')) {
            wishList = [];
            if (supabaseClient && currentYear) supabaseClient.from('wishes').delete().eq('year', currentYear);
            renderWishRanking();
        }
    }

    function renderWishRanking() {
        const tbody = document.querySelector('#wishRankingTable tbody');
        tbody.innerHTML = '';
        
        // Sort by total wishes (descending)
        wishList.sort((a, b) => b.total - a.total);
        
        let effectiveRank = 1;
        
        wishList.forEach((entry, index) => {
             // Tie handling
             if (index > 0 && entry.total === wishList[index-1].total) {
                 // Tie
             } else {
                 effectiveRank = index + 1;
             }
             
             const points = totalTeams - effectiveRank + 1;
             entry.rank = effectiveRank;
             entry.points = points;
             
             const tr = document.createElement('tr');
             
             const nameDisplay = isImage(entry.team) ? `<img src="${entry.team}" style="height:30px; vertical-align:middle;">` : entry.team;
             
            tr.innerHTML = `
               <td>${effectiveRank}</td>
               <td>${entry.serial}</td>
               <td>${nameDisplay}</td>
               <td>${entry.wishes[0]}</td>
               <td>${entry.wishes[1]}</td>
               <td>${entry.wishes[2]}</td>
               <td>${entry.wishes[3]}</td>
               <td>${entry.wishes[4]}</td>
               <td style="font-weight:bold;">${entry.total}</td>
               <td style="color:${points > 0 ? '#28a745' : 'inherit'}; font-weight:bold;">${points}</td>
               ${isAdmin ? `<td>\n                   <button onclick=\"editWish('${entry.serial}')\" style=\"padding:2px 5px; font-size:12px; background:#007bff; margin-right:5px;\">ç¼–è¾‘</button>\n                   <button onclick=\"deleteWish('${entry.serial}')\" style=\"padding:2px 5px; font-size:12px; background:#dc3545;\">åˆ é™¤</button>\n               </td>` : ''}
            `;
             tbody.appendChild(tr);
        });
    }

    function handleWishFileUpload(event) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                
                let successCount = 0;
                let startRow = 0;
                let colSerial = -1;
                let colName = -1;
                let colW1 = -1;
                
                // Find headers
                for(let i=0; i<Math.min(20, jsonData.length); i++) {
                    const rawRow = jsonData[i] || [];
                    const row = Array.from(rawRow).map(c => String(c || '').trim());
                    if (row.some(c => c.includes('åºå·') || c.includes('é˜Ÿä¼åç§°'))) {
                        startRow = i + 1;
                        colSerial = row.findIndex(c => c.includes('åºå·'));
                        colName = row.findIndex(c => c.includes('é˜Ÿä¼åç§°'));
                        colW1 = row.findIndex(c => c.includes('1é¢—') || c.includes('1æ˜Ÿ'));
                        break;
                    }
                }
                
                if (colSerial === -1 || colName === -1) {
                    throw new Error("æœªæ‰¾åˆ°'åºå·'æˆ–'é˜Ÿä¼åç§°'åˆ—");
                }
                
                for (let i = startRow; i < jsonData.length; i++) {
                    const rawRow = jsonData[i] || [];
                    const row = Array.from(rawRow).map(c => String(c || '').trim());
                    
                    const serial = row[colSerial];
                    let team = row[colName];
                    
                    if (!serial && !team) continue;
                    
                    // Normalize team name
                    if (teamList.length > 0) {
                         const normalize = str => String(str || '').replace(/\s+/g, '');
                         const canonical = teamList.find(t => String(t.serial) === String(serial) && normalize(t.name) === normalize(team));
                         if (canonical) team = canonical.name;
                    }
                    
                    const wishes = [0, 0, 0, 0, 0];
                    if (colW1 !== -1) {
                        for (let j = 0; j < 5; j++) {
                            if (colW1 + j < rawRow.length) {
                                const val = parseInt(rawRow[colW1 + j]);
                                wishes[j] = isNaN(val) ? 0 : val;
                            }
                        }
                    }
                    
                    const total = wishes.reduce((a,b) => a+b, 0);
                    
                    // Update or Add
                    const existingIdx = wishList.findIndex(w => w.serial === serial);
                    const entry = {
                        serial: serial,
                        team: team,
                        wishes: wishes,
                        total: total
                    };
                    
                    if (existingIdx !== -1) {
                        wishList[existingIdx] = entry;
                    } else {
                        wishList.push(entry);
                    }
                    successCount++;
                }
                
                renderWishRanking();
                upsertWishes(wishList);
                alert(`æˆåŠŸå¯¼å…¥ ${successCount} æ¡å¿ƒæ„¿æ•°æ®`);
                closeModal('wishImportModal');
                
            } catch (err) {
                console.error(err);
                alert('å¯¼å…¥å¤±è´¥: ' + err.message);
            }
        };
        reader.readAsArrayBuffer(file);
        event.target.value = '';
    }

    function exportWishRanking() {
        if (wishList.length === 0) {
            alert('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
            return;
        }
        
        const data = wishList.map(entry => {
            return {
                "æ’å": entry.rank,
                "åºå·": entry.serial,
                "é˜Ÿä¼åç§°": isImage(entry.team) ? "[å›¾ç‰‡é˜Ÿä¼]" : entry.team,
                "1é¢—å¿ƒæ„¿": entry.wishes[0],
                "2é¢—å¿ƒæ„¿": entry.wishes[1],
                "3é¢—å¿ƒæ„¿": entry.wishes[2],
                "4é¢—å¿ƒæ„¿": entry.wishes[3],
                "5é¢—å¿ƒæ„¿": entry.wishes[4],
                "å¿ƒæ„¿æ€»è®¡": entry.total,
                "ç§¯åˆ†": entry.points
            };
        });
        
        const ws = XLSX.utils.json_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "å¿ƒæ„¿æ’è¡Œ");
        
        try {
             XLSX.writeFile(wb, `å¿ƒæ„¿æ’è¡Œ_${new Date().getTime()}.xlsx`);
        } catch (e) {
             alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }

    async function init() {
        initHandTypeFilter();
        generateDeck();
        renderDropdowns();
        updateCalculatorDropdowns();
        renderWishDropdowns();
        currentYear = new Date().getFullYear();
        await initSupabase();
        await loadYearData(currentYear);
        updateHeaderYear();
        applyRoleUI();
        renderGiftTiersConfig(); // Init tiers config UI
        renderGiftTierLegend(); // Init legend
        
        // Hide Loader
        const loader = document.getElementById('pageLoader');
        if (loader) {
            loader.style.opacity = '0';
            setTimeout(() => loader.style.display = 'none', 500);
        }
        
        // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰èœå•
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.card-input-group')) {
                closeAllDropdowns();
            }
            // Click outside modal to close
            if (event.target.classList.contains('modal')) {
                event.target.style.display = "none";
            }
        });
    }

    // --- Gift Tiers & Images Logic ---

    function renderGiftTiersConfig() {
        const container = document.getElementById('giftTiersConfig');
        container.innerHTML = '';
        
        giftTiers.forEach((tier, index) => {
            const div = document.createElement('div');
            div.style.display = 'flex';
            div.style.gap = '5px';
            div.style.marginBottom = '5px';
            div.style.alignItems = 'center';
            
            div.innerHTML = `
                <input type="text" placeholder="åç§°" value="${tier.name}" onchange="updateGiftTier(${index}, 'name', this.value)" style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                <input type="number" placeholder="Min" value="${tier.min}" onchange="updateGiftTier(${index}, 'min', this.value)" style="width: 50px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                <span>-</span>
                <input type="number" placeholder="Max" value="${tier.max}" onchange="updateGiftTier(${index}, 'max', this.value)" style="width: 50px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                <input type="color" value="${tier.color}" onchange="updateGiftTier(${index}, 'color', this.value)" style="width: 40px; height: 30px; border: none; background: none; cursor: pointer;">
                <button onclick="removeGiftTier(${index})" style="padding: 2px 5px; color: red; border: none; background: none; cursor: pointer;">&times;</button>
            `;
            container.appendChild(div);
        });
        
        const addBtn = document.createElement('button');
        addBtn.textContent = '+ æ·»åŠ æ¡£ä½';
        addBtn.className = 'btn-secondary';
        addBtn.style.padding = '5px 10px';
        addBtn.style.fontSize = '12px';
        addBtn.onclick = addGiftTier;
        container.appendChild(addBtn);
        
        // Also update settings in cloud if changed? Or just rely on "Save" button? 
        // We don't have a global "Save Settings" button, changes are usually immediate or auto-saved.
        // Let's add an auto-save for settings later or just save now.
        saveAppSettings();
    }
    
    function updateGiftTier(index, field, value) {
        if (field === 'min' || field === 'max') value = parseInt(value) || 0;
        giftTiers[index][field] = value;
        renderGiftTierLegend();
        saveAppSettings();
    }
    
    function addGiftTier() {
        giftTiers.push({ min: 0, max: 0, name: "æ–°æ¡£ä½", color: "#ffffff", value: 0 });
        renderGiftTiersConfig();
    }
    
    function removeGiftTier(index) {
        giftTiers.splice(index, 1);
        renderGiftTiersConfig();
    }
    
    function renderGiftTierLegend() {
        const container = document.getElementById('tierLegendContainer');
        if (!container) return;
        container.innerHTML = '';
        giftTiers.forEach(tier => {
            const span = document.createElement('span');
            span.style.display = 'inline-flex';
            span.style.alignItems = 'center';
            span.style.gap = '5px';
            span.innerHTML = `<span style="width: 15px; height: 15px; background-color: ${tier.color}; border: 1px solid #ccc; display: inline-block;"></span> ${tier.name} (${tier.min}-${tier.max})`;
            container.appendChild(span);
        });
    }

    async function handleGiftImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Convert to Base64
        const reader = new FileReader();
        reader.onload = async function(e) {
            const base64 = e.target.result;
            // Add to giftImages
            giftImages.push({
                id: Date.now().toString(),
                url: base64, // Storing base64 directly for simplicity as requested "upload gift images" without external storage bucket setup instructions
                desc: file.name
            });
            renderGiftImagesPreview();
            saveAppSettings();
            event.target.value = ''; // Reset
        };
        reader.readAsDataURL(file);
    }
    
    function renderGiftImagesPreview() {
        const container = document.getElementById('giftImagePreviewContainer');
        container.innerHTML = '';
        giftImages.forEach((img, index) => {
            const div = document.createElement('div');
            div.style.position = 'relative';
            div.style.display = 'inline-block'; // Ensure proper positioning context
            div.style.margin = '5px';
            div.innerHTML = `
                <img src="${img.url}" style="height: 60px; border: 1px solid #ccc; border-radius: 4px; display: block;">
                <button onclick="removeGiftImage(${index})" style="position: absolute; top: -8px; right: -8px; background: red; color: white; border-radius: 50%; width: 20px; height: 20px; border: none; cursor: pointer; font-size: 14px; line-height: 18px; padding: 0; display: flex; align-items: center; justify-content: center;">&times;</button>
            `;
            container.appendChild(div);
        });
        
        // Also update the view modal
        const viewContainer = document.getElementById('giftImagesViewContainer');
        if (viewContainer) {
            viewContainer.innerHTML = '';
            giftImages.forEach(img => {
                const wrapper = document.createElement('div');
                wrapper.style.cursor = 'zoom-in';
                wrapper.onclick = () => showEnlargedImage(img.url);
                
                const imgEl = document.createElement('img');
                imgEl.src = img.url;
                imgEl.style.maxWidth = '100%';
                imgEl.style.maxHeight = '400px';
                imgEl.style.border = '1px solid #ccc';
                imgEl.style.borderRadius = '4px';
                
                wrapper.appendChild(imgEl);
                viewContainer.appendChild(wrapper);
            });
        }
    }
    
    function showEnlargedImage(url) {
        // Create or reuse an overlay for zoomed image
        let overlay = document.getElementById('imageZoomOverlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'imageZoomOverlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0,0,0,0.9)'; // Darker bg
            overlay.style.zIndex = '2000';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.overflow = 'hidden'; // Prevent scrolling body
            
            // Pan/Zoom State
            let scale = 1;
            let panning = false;
            let pointX = 0;
            let pointY = 0;
            let startX = 0;
            let startY = 0;

            const img = document.createElement('img');
            img.style.maxWidth = '100%';
            img.style.maxHeight = '100%';
            img.style.boxShadow = '0 0 20px rgba(0,0,0,0.5)';
            img.style.transition = 'transform 0.1s ease-out'; // Smooth zoom
            img.style.cursor = 'grab';
            img.style.transformOrigin = 'center center'; // Ensure scaling from center
            img.draggable = false;
            
            // Zoom with wheel
            overlay.onwheel = (e) => {
                e.preventDefault();
                // Simply scale, don't adjust position based on mouse (simplifies logic and prevents jumping)
                // If we want mouse-centric zoom, we need complex offset calc.
                // Let's stick to center zoom + pan for stability.
                const delta = -e.deltaY;
                const oldScale = scale;
                (delta > 0) ? (scale *= 1.2) : (scale /= 1.2);
                
                if (scale < 1) scale = 1;
                if (scale > 5) scale = 5; 
                
                // If scaling down to 1, reset position
                if (scale === 1) {
                    pointX = 0;
                    pointY = 0;
                }
                
                updateTransform();
            };
            
            // Pan with mouse
            img.onmousedown = (e) => {
                e.preventDefault();
                startX = e.clientX - pointX;
                startY = e.clientY - pointY;
                panning = true;
                img.style.cursor = 'grabbing';
            };
            
            overlay.onmouseup = () => {
                panning = false;
                img.style.cursor = 'grab';
            };
            
            overlay.onmousemove = (e) => {
                if (!panning) return;
                e.preventDefault();
                pointX = e.clientX - startX;
                pointY = e.clientY - startY;
                updateTransform();
            };
            
            // Double click to reset or zoom
            img.ondblclick = (e) => {
                e.stopPropagation(); // Prevent overlay click close
                if (scale > 1) {
                    scale = 1;
                    pointX = 0;
                    pointY = 0;
                } else {
                    scale = 2;
                    // Center on click? Simplified to center
                    pointX = 0;
                    pointY = 0; 
                }
                updateTransform();
            }

            function updateTransform() {
                img.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
            }
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '20px';
            closeBtn.style.right = '20px';
            closeBtn.style.fontSize = '30px';
            closeBtn.style.color = 'white';
            closeBtn.style.background = 'none';
            closeBtn.style.border = 'none';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.zIndex = '2001';
            closeBtn.onclick = () => {
                overlay.style.display = 'none';
                resetZoom();
            };
            
            // Click background to close
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    overlay.style.display = 'none';
                    resetZoom();
                }
            };
            
            function resetZoom() {
                scale = 1;
                pointX = 0;
                pointY = 0;
                updateTransform();
            }

            overlay.appendChild(img);
            overlay.appendChild(closeBtn);
            document.body.appendChild(overlay);
        }
        
        const img = overlay.querySelector('img');
        img.src = url;
        overlay.style.display = 'flex';
    }
    
    function removeGiftImage(index) {
        giftImages.splice(index, 1);
        renderGiftImagesPreview();
        saveAppSettings();
    }
    
    function viewGiftImages() {
        renderGiftImagesPreview(); // Ensure up to date
        openModal('giftImagesModal');
    }
    
    async function saveAppSettings() {
        if (!supabaseClient || !currentYear) return;
        
        // Save Tiers
        await supabaseClient.from('settings').upsert({ 
            year: currentYear, 
            key: 'gift_tiers', 
            value: giftTiers 
        }, { onConflict: 'year,key' });
        
        // Save Images (Warning: Supabase row size limit might be hit if many large images. 
        // Ideally should use Storage, but for now using DB column as requested/implied by context restrictions)
        await supabaseClient.from('settings').upsert({ 
            year: currentYear, 
            key: 'gift_images', 
            value: giftImages 
        }, { onConflict: 'year,key' });
    }
    
    // --- Gift Selection Logic ---
    
    function renderGiftSelection() {
        const tbody = document.querySelector('#giftSelectionTable tbody');
        tbody.innerHTML = '';
        
        let data = getFinalRankingData(); // Sorted by Rank

        // Filter Logic
        const sTeam = document.getElementById('searchGiftTeam')?.value.toLowerCase().trim() || '';
        const sMember = document.getElementById('searchGiftMember')?.value.toLowerCase().trim() || '';

        if (sTeam || sMember) {
            data = data.filter(item => {
                const matchTeam = !sTeam || item.team.toLowerCase().includes(sTeam);
                // item.members is string "m1, m2" joined in getFinalRankingData
                const matchMember = !sMember || item.members.toLowerCase().includes(sMember);
                return matchTeam && matchMember;
            });
        }
        
        data.forEach(item => {
            const tr = document.createElement('tr');
            
            // Tier
            const tier = giftTiers.find(t => item.rank >= t.min && item.rank <= t.max);
            const tierName = tier ? tier.name : "-";
            const tierColor = tier ? tier.color : "";
            
            if (tierColor) tr.style.backgroundColor = tierColor;
            
            tr.innerHTML += `<td style="width: 80px; text-align: center; font-weight: bold;">${item.rank}</td>`;
            tr.innerHTML += `<td style="width: 100px; text-align: center;">${tierName}</td>`;
            
             const nameDisplay = isImage(item.team) ? `<img src="${item.team}" style="height:30px; vertical-align:middle;">` : item.team;
            tr.innerHTML += `<td>${nameDisplay}</td>`;
            
            // Members & Gifts
            const tdGifts = document.createElement('td');
            
            // Get Team from teamList to access members and gift data
            const teamEntry = teamList.find(t => t.serial === item.serial);
            const members = teamEntry ? teamEntry.members : [];
            const gifts = teamEntry ? (teamEntry.gifts || {}) : {};
            
            if (members.length === 0) {
                tdGifts.textContent = "æ— æˆå‘˜ä¿¡æ¯";
            } else {
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.gap = '5px';
                
                members.forEach(member => {
                    const memberGift = gifts[member] || { id: '', remark: '' };
                    
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.gap = '10px';
                    
                    row.innerHTML = `
                        <span style="width: 80px; font-weight: bold; text-align: right;">${member}:</span>
                        <input type="text" placeholder="ç¤¼ç‰©ç¼–å·" value="${memberGift.id || ''}" 
                            onblur="handleGiftBlur(this, '${item.serial}', '${member}', 'id')"
                            style="width: 100px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                        <input type="text" placeholder="å¤‡æ³¨" value="${memberGift.remark || ''}" 
                            onblur="handleGiftBlur(this, '${item.serial}', '${member}', 'remark')"
                            style="flex: 1; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                        <span class="save-status" style="font-size: 12px; color: green; display: none;">å·²ä¿å­˜</span>
                    `;
                    container.appendChild(row);
                });
                tdGifts.appendChild(container);
            }
            
            tr.appendChild(tdGifts);
            tbody.appendChild(tr);
        });
    }
    
    function exportGiftSelection() {
        const data = getFinalRankingData();
        if (data.length === 0) {
            alert('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
            return;
        }
        
        let exportData = [];
        
        data.forEach(item => {
            const teamEntry = teamList.find(t => t.serial === item.serial);
            const members = teamEntry ? teamEntry.members : [];
            const gifts = teamEntry ? (teamEntry.gifts || {}) : {};
            const tier = giftTiers.find(t => item.rank >= t.min && item.rank <= t.max);
            const tierName = tier ? tier.name : '-';
            const teamName = isImage(item.team) ? "[å›¾ç‰‡é˜Ÿä¼]" : item.team;
            
            if (members.length > 0) {
                members.forEach(member => {
                    const g = gifts[member] || {};
                    const giftId = g.id ? String(g.id) : '';
                    const remark = g.remark ? String(g.remark) : '';
                    
                    exportData.push({
                        "æœ€ç»ˆæ’å": item.rank,
                        "ç¤¼ç‰©æ¡£ä½": tierName,
                        "é˜Ÿä¼åç§°": teamName,
                        "æˆå‘˜åç§°": member,
                        "ç¤¼ç‰©é€‰æ‹©": giftId,
                        "å¤‡æ³¨": remark
                    });
                });
            } else {
                exportData.push({
                    "æœ€ç»ˆæ’å": item.rank,
                    "ç¤¼ç‰©æ¡£ä½": tierName,
                    "é˜Ÿä¼åç§°": teamName,
                    "æˆå‘˜åç§°": "æ— æˆå‘˜ä¿¡æ¯",
                    "ç¤¼ç‰©é€‰æ‹©": "",
                    "å¤‡æ³¨": ""
                });
            }
        });

        const ws = XLSX.utils.json_to_sheet(exportData);
        ws['!cols'] = [
            { wch: 8 },  // æœ€ç»ˆæ’å
            { wch: 10 }, // ç¤¼ç‰©æ¡£ä½
            { wch: 20 }, // é˜Ÿä¼åç§°
            { wch: 15 }, // æˆå‘˜åç§°
            { wch: 15 }, // ç¤¼ç‰©é€‰æ‹©
            { wch: 20 }  // å¤‡æ³¨
        ];
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'ç¤¼ç‰©é€‰æ‹©');
        const date = new Date();
        const dateStr = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        const timeStr = `${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}`;
        try {
            XLSX.writeFile(wb, `ç¤¼ç‰©é€‰æ‹©_${dateStr}_${timeStr}.xlsx`);
        } catch (e) {
            alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }
    
    // Handle blur event for auto-save
    async function handleGiftBlur(input, serial, member, field) {
        const newValue = input.value;
        const team = teamList.find(t => t.serial === serial);
        if (!team) return;
        
        if (!team.gifts) team.gifts = {};
        if (!team.gifts[member]) team.gifts[member] = { id: '', remark: '' };
        
        // Only save if changed
        if (team.gifts[member][field] !== newValue) {
            team.gifts[member][field] = newValue;
            
            // Show saving status
            const statusSpan = input.parentNode.querySelector('.save-status');
            statusSpan.textContent = 'ä¿å­˜ä¸­...';
            statusSpan.style.display = 'inline';
            statusSpan.style.color = 'orange';
            
            try {
                // Confirm save
                if (confirm(`æ˜¯å¦ä¿å­˜ ${member} çš„ç¤¼ç‰©ä¿¡æ¯ä¿®æ”¹ï¼Ÿ`)) {
                    await upsertTeams([team]); // Save this specific team only
                    statusSpan.textContent = 'å·²ä¿å­˜';
                    statusSpan.style.color = 'green';
                    setTimeout(() => statusSpan.style.display = 'none', 2000);
                } else {
                    // Revert if cancelled? Or just don't save to cloud but keep in UI?
                    // User requirement: "æç¤ºæ˜¯å¦ä¿å­˜å½“å‰ä¿®æ”¹"
                    // If user cancels, we should probably revert UI or just leave it unsaved (risky).
                    // Reverting UI is safer to match state.
                    input.value = team.gifts[member][field]; // Revert (wait, we already updated local state above)
                    // Actually we should update local state ONLY after confirmation or if we treat local as draft.
                    // But for simplicity, let's keep local state updated, but cloud state not.
                    // If user says No, we just hide status and don't push to cloud.
                    // But next refresh will lose data. This is standard behavior for "Cancel Save".
                    statusSpan.style.display = 'none';
                }
            } catch (e) {
                console.error(e);
                statusSpan.textContent = 'ä¿å­˜å¤±è´¥';
                statusSpan.style.color = 'red';
            }
        }
    }

    /* Removed saveAllGifts and updateMemberGift as they are replaced by auto-save logic */
    /*
    function updateMemberGift(serial, member, field, value) { ... }
    async function saveAllGifts() { ... }
    */
    function openModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = "block";
        } else {
            console.error("Modal not found:", modalId);
        }
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = "none";
        }
    }

    function generateDeck() {
        const suits = [
            { symbol: 'â™ ', color: 'black', name: 'Spade', chinese: 'é»‘æ¡ƒ', short: 's' },
            { symbol: 'â™¥', color: 'red', name: 'Heart', chinese: 'çº¢æ¡ƒ', short: 'h' },
            { symbol: 'â™£', color: 'black', name: 'Club', chinese: 'æ¢…èŠ±', short: 'c' },
            { symbol: 'â™¦', color: 'red', name: 'Diamond', chinese: 'æ–¹å—', short: 'd' }
        ];
        const ranks = [
            { val: 2, label: '2' }, { val: 3, label: '3' }, { val: 4, label: '4' }, 
            { val: 5, label: '5' }, { val: 6, label: '6' }, { val: 7, label: '7' }, 
            { val: 8, label: '8' }, { val: 9, label: '9' }, { val: 10, label: '10', alias: 't' },
            { val: 11, label: 'J' }, { val: 12, label: 'Q' }, { val: 13, label: 'K' }, { val: 14, label: 'A', alias: '1' }
        ];

        deck = [];
        for (let s of suits) {
            for (let r of ranks) {
                // æ„å»ºæœç´¢å…³é”®è¯
                // ç§»é™¤è‹±æ–‡å…¨ç§°(Spade, Heart...)ï¼Œå› ä¸ºå®ƒä»¬åŒ…å« 'a' ä¼šå¯¼è‡´æœç´¢ 'A' æ—¶åŒ¹é…æ‰€æœ‰ç‰Œ
                // ä¿ç•™: ç¬¦å·(â™ ), ç‚¹æ•°(A), ä¸­æ–‡(é»‘æ¡ƒ), ç®€å†™(s), åˆ«å(t, 1)
                let keys = [
                    `${s.symbol}${r.label}`, // â™ A
                    r.label,                 // A
                    s.chinese,               // é»‘æ¡ƒ
                    s.short,                 // s
                    s.short + r.label,       // sA
                    r.label + s.short        // As
                ];
                if (r.alias) keys.push(r.alias);

                deck.push({
                    suit: s.symbol,
                    rank: r.val,
                    rankLabel: r.label,
                    color: s.color,
                    fullName: `${s.symbol}${r.label}`,
                    searchKey: keys.join(' ').toLowerCase()
                });
            }
        }
    }

    function renderDropdowns() {
        for (let i = 1; i <= 5; i++) {
            const list = document.getElementById(`list${i}`);
            list.innerHTML = '';
            deck.forEach(card => {
                const option = document.createElement('div');
                option.className = 'card-option';
                option.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span>`;
                option.onclick = (e) => {
                    e.stopPropagation();
                    selectCard(i, card);
                };
                // Store card data for filtering
                option.dataset.search = card.searchKey;
                list.appendChild(option);
            });
        }
    }

    function toggleDropdown(index) {
        const dropdown = document.getElementById(`dropdown${index}`);
        const isVisible = dropdown.classList.contains('show');
        
        closeAllDropdowns();
        
        if (!isVisible) {
            dropdown.classList.add('show');
            // Focus search box
            const input = dropdown.querySelector('.search-box');
            input.value = '';
            filterCards(index); // Reset filter
            setTimeout(() => input.focus(), 50);
        }
    }

    function closeAllDropdowns() {
        document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
    }

    function selectCard(index, card) {
        selectedCards[index] = card;
        
        // Update trigger UI
        const trigger = document.getElementById(`trigger${index}`);
        trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> â–¾`;
        trigger.classList.add('filled');
        
        closeAllDropdowns();
        // updateTextInput(); // Removed
    }

    function updateTextInput() {
        // Removed
    }

    function filterCards(index) {
        const input = document.querySelector(`#dropdown${index} .search-box`);
        const filter = input.value.toLowerCase();
        const list = document.getElementById(`list${index}`);
        const options = list.getElementsByClassName('card-option');

        for (let option of options) {
            const txtValue = option.dataset.search;
            if (txtValue.indexOf(filter) > -1) {
                option.style.display = "";
            } else {
                option.style.display = "none";
            }
        }
    }

    let handHistory = [];
    let currentEditingId = null;

    function handleFileUpload(event) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        const file = event.target.files[0];
        if (!file) return;

        // Close modal immediately if file is selected (we will process it)
        // Actually, user might want to see the text area populated first?
        // Requirement: "å¦‚æœé€‰æ‹©æ–‡ä»¶å¯¼å…¥æˆåŠŸåè‡ªåŠ¨å…³é—­æ‰¹é‡å¯¼å…¥äºŒçº§æ¡†"
        // So we should close it AFTER success.
        // But here we just read file. The actual import happens in processBulkImport called by reader.onload.
        // Wait, my implementation of reader.onload calls processBulkImport() directly.
        // So processBulkImport will handle closing.

        const reader = new FileReader();
        
        if (file.name.endsWith('.csv')) {
            reader.onload = function(e) {
                const text = e.target.result;
                document.getElementById('bulkInput').value = text;
                processBulkImport(true); // Pass flag to indicate auto-import from file
            };
            reader.readAsText(file);
        } else {
            // Excel
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    
                    // Convert to JSON (array of arrays) to be safe
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                    
                    // Convert to Tab Separated Values for our existing parser
                    // Replace newlines in cell data with space to prevent line breaking
                    const tsv = jsonData.map(row => 
                        row.map(cell => {
                            if (typeof cell === 'string') {
                                return cell.replace(/[\n\r]+/g, ' ');
                            }
                            return cell;
                        }).join('\t')
                    ).join('\n');
                    
                    document.getElementById('bulkInput').value = tsv;
                    processBulkImport(true); // Pass flag to indicate auto-import from file
                } catch (err) {
                    alert('è¯»å–Excelæ–‡ä»¶å¤±è´¥: ' + err.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Reset file input so same file can be selected again if needed
        event.target.value = '';
    }

    function processBulkImport(isFromFile = false) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        const input = document.getElementById('bulkInput').value.trim();
        if (!input) return;

        // Use a smarter split that respects quotes (standard CSV/TSV behavior) to handle multi-line fields in copy-paste scenarios
        // Regex: Split by newline if not followed by an odd number of quotes
        // But JS doesn't support variable length lookbehind, so we use lookahead for even quotes until end of string.
        // Actually, simple strategy: if a line has unclosed quote, merge with next.
        
        let rawLines = input.split(/\r?\n/);
        const lines = [];
        let currentLine = '';
        let inQuote = false;
        
        for (let line of rawLines) {
            // Count quotes in this line
            const quotes = (line.match(/"/g) || []).length;
            
            if (!inQuote) {
                if (quotes % 2 === 0) {
                    // Balanced, simple line
                    lines.push(line);
                } else {
                    // Unbalanced, start of multi-line
                    currentLine = line;
                    inQuote = true;
                }
            } else {
                currentLine += '\n' + line; // Restore newline
                if (quotes % 2 !== 0) {
                    // Found closing quote (odd number of quotes + previous odd = even)
                    lines.push(currentLine);
                    currentLine = '';
                    inQuote = false;
                }
                // If even quotes, we are still inside multiline quote
            }
        }
        if (currentLine) lines.push(currentLine); // Push remaining if any

        let successCount = 0;
        let errors = [];
        
        // é»˜è®¤åˆ—æ˜ å°„
        let colMap = { id: 0, team: 1, hand: 2 };
        let foundHeader = false;

        lines.forEach((line, index) => {
            line = line.trim();
            if (!line) return;
            
            // Handle CSV/TSV parsing manually to respect quotes
            let parts = [];
            
            if (line.includes('\t')) {
                parts = line.split('\t');
            } else {
                if (line.indexOf('"') === -1) {
                    parts = line.split(/[,ï¼Œ]/);
                } else {
                    parts = line.split(/[,ï¼Œ]/); // Simplified
                }
            }

            // Clean up parts
            parts = parts.map(p => {
                p = p.trim();
                if (p.startsWith('"') && p.endsWith('"')) {
                    p = p.slice(1, -1).replace(/""/g, '"');
                }
                return p;
            });

            parts = parts.map(p => p.replace(/[\n\r]+/g, ' '));
            
            // è¯†åˆ«è¡¨å¤´å¹¶åŠ¨æ€æ˜ å°„åˆ—
            if (index === 0) {
                let tempMap = {};
                let headerFound = false;
                
                parts.forEach((col, i) => {
                    const c = col.toLowerCase();
                    if (c.includes('åºå·') || c === 'id' || c === 'no') tempMap.id = i;
                    else if (c.includes('é˜Ÿä¼') || c.includes('team') || c === 'name') tempMap.team = i;
                    else if (c.includes('ç‰Œé¢') || c.includes('cards') || c === 'hand') tempMap.hand = i;
                });

                // å¦‚æœè‡³å°‘æ‰¾åˆ° åºå·+é˜Ÿä¼ æˆ– é˜Ÿä¼+ç‰Œé¢ï¼Œåˆ™è®¤ä¸ºæ˜¯è¡¨å¤´
                if ((tempMap.id !== undefined && tempMap.team !== undefined) || 
                    (tempMap.team !== undefined && tempMap.hand !== undefined)) {
                    
                    colMap = {
                        id: tempMap.id !== undefined ? tempMap.id : 0,
                        team: tempMap.team !== undefined ? tempMap.team : 1,
                        hand: tempMap.hand !== undefined ? tempMap.hand : 2
                    };
                    foundHeader = true;
                    return; // è·³è¿‡è¡¨å¤´
                }
                
                // å…¼å®¹æ—§é€»è¾‘ï¼ˆå¦‚æœæ²¡æœ‰ç²¾ç¡®åŒ¹é…ä½†çœ‹èµ·æ¥åƒè¡¨å¤´ï¼‰
                const firstCol = parts[0] || '';
                const secondCol = parts[1] || '';
                if (firstCol.includes('åºå·') || secondCol.includes('é˜Ÿä¼') || secondCol.includes('Team')) {
                    return; // è·³è¿‡è¡¨å¤´
                }
            }
            
            const maxIndex = Math.max(colMap.id, colMap.team, colMap.hand);
            if (parts.length <= maxIndex) {
                errors.push(`ç¬¬ ${index+1} è¡Œæ ¼å¼é”™è¯¯: åˆ—æ•°ä¸è¶³ (éœ€è‡³å°‘ ${maxIndex+1} åˆ—)`);
                return;
            }

            const serial = parts[colMap.id];
            const rawTeam = parts[colMap.team];
            let finalTeamName = rawTeam;
            
            // Validate against teamList if it has data
            if (teamList.length > 0) {
                const serialMatch = teamList.find(t => String(t.serial) === String(serial));
                
                if (serialMatch) {
                    // Found by serial - use the canonical name from the system
                    finalTeamName = serialMatch.name;
                } else {
                    // Serial not found in system
                    errors.push(`ç¬¬ ${index+1} è¡Œé”™è¯¯: åºå· ${serial} ä¸åœ¨é˜Ÿä¼ç®¡ç†åˆ—è¡¨ä¸­`);
                    return;
                }
            }
            
            let cardsStr = '';
            if (foundHeader) {
                cardsStr = parts[colMap.hand];
            } else {
                // å…¼å®¹æ—§æ¨¡å¼ï¼šå¦‚æœæ²¡æœ‰è¯†åˆ«åˆ°è¡¨å¤´ï¼Œå‡è®¾ä»ç¬¬3åˆ—å¼€å§‹éƒ½æ˜¯ç‰Œï¼ˆåº”å¯¹é€—å·åˆ†å‰²çš„æƒ…å†µï¼‰
                cardsStr = parts.slice(2).join(' ');
            }

            try {
                const cards = parseCards(cardsStr);
                const result = evaluateHand(cards);
                
                const newHand = {
                    id: Date.now().toString() + Math.random(), // Ensure unique ID
                    cards: cards,
                    serial: serial,
                    team: finalTeamName,
                    ...result
                };
                handHistory.push(newHand);
                successCount++;
            } catch (e) {
                errors.push(`ç¬¬ ${index+1} è¡Œ (${finalTeamName}) é”™è¯¯: ${e.message}`);
            }
        });

        // Re-sort and update table
        handHistory.sort((a, b) => b.score - a.score);
        updateTable();
        upsertHands(handHistory);
        
        // Show result
        if (errors.length > 0) {
            alert(`å¯¼å…¥å®Œæˆ: ${successCount} æˆåŠŸ\n\né”™è¯¯:\n${errors.join('\n')}`);
        } else {
            alert(`æˆåŠŸå¯¼å…¥ ${successCount} æ¡æ•°æ®`);
            document.getElementById('bulkInput').value = '';
            // Close modal if requested (e.g. from file upload) or always?
            // Requirement: "å¦‚æœé€‰æ‹©æ–‡ä»¶å¯¼å…¥æˆåŠŸåè‡ªåŠ¨å…³é—­"
            // Let's close it always on full success for better UX, or only if from file?
            // User said "å¦‚æœé€‰æ‹©æ–‡ä»¶å¯¼å…¥æˆåŠŸå...", implies manual paste might stay open?
            // But usually if success, closing is fine.
            // Let's stick to closing it always on full success as per previous implementation, 
            // but specifically ensure it handles the file upload case nicely.
            closeModal('importModal');
        }
    }

    function processHand() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        const errorMsg = document.getElementById('errorMsg');
        // const inputVal = document.getElementById('cardInput').value.trim(); // Removed
        const serialVal = document.getElementById('serialInput').value.trim();
        const teamVal = document.getElementById('teamInput').value.trim();
        
        errorMsg.style.display = 'none';

        try {
            if (!serialVal) throw new Error("è¯·é€‰æ‹©åºå·");
            if (!teamVal) throw new Error("è¯·é€‰æ‹©é˜Ÿä¼åç§°");

            let currentHand = [];

            // Use dropdowns
            for (let i = 1; i <= 5; i++) {
                if (!selectedCards[i]) {
                    throw new Error(`è¯·é€‰æ‹©ç¬¬ ${i} å¼ ç‰Œ`);
                }
                currentHand.push(selectedCards[i]);
            }
            
            // Check duplicates
            const uniqueCheck = new Set(currentHand.map(c => c.suit + c.rank));
            if (uniqueCheck.size !== 5) {
                throw new Error("ç‰Œé¢é‡å¤ï¼Œè¯·æ£€æŸ¥");
            }
            
            const result = evaluateHand(currentHand);
            
            if (currentEditingId) {
                // Update existing
                const index = handHistory.findIndex(h => h.id === currentEditingId);
                if (index !== -1) {
                    handHistory[index] = {
                        ...handHistory[index],
                        cards: currentHand,
                        serial: serialVal,
                        team: teamVal,
                        ...result
                    };
                }
                cancelEdit(); // Reset UI
            } else {
                const newHand = { id: Date.now().toString(), cards: currentHand, serial: serialVal, team: teamVal, ...result };
                handHistory.push(newHand);
                upsertHands([newHand]);
            }

            // æ’åºï¼šåˆ†æ•°ä»é«˜åˆ°ä½
            handHistory.sort((a, b) => b.score - a.score);

            updateTable();
            
            // Clear inputs if not editing (if editing, cancelEdit already cleared)
            if (!currentEditingId) {
                // document.getElementById('cardInput').value = ''; // Removed
                document.getElementById('serialInput').value = '';
                document.getElementById('teamInput').value = '';
                // Clear dropdowns
                for (let i = 1; i <= 5; i++) {
                     selectedCards[i] = null;
                     const trigger = document.getElementById(`trigger${i}`);
                     trigger.innerHTML = `... â–¾`;
                     trigger.classList.remove('filled');
                }
            }
            
        } catch (e) {
            errorMsg.textContent = e.message;
            errorMsg.style.display = 'block';
        }
    }
    
    function parseCards(input) {
        // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…æ‰€æœ‰å¯èƒ½çš„ç‰Œç»„åˆ
        // Suits: â™ â™¥â™£â™¦sShHcCdD
        // Ranks: 10, 2-9, tTjJqQkKaA, 1
        const suitRegex = "[â™ â™¥â™£â™¦sShHcCdD]";
        const rankRegex = "(?:10|[2-9]|[tTjJqQkKaA]|1)";
        
        // æ¨¡å¼1: èŠ±è‰² + ç‚¹æ•° (ä¾‹å¦‚: â™ A, s10)
        // æ¨¡å¼2: ç‚¹æ•° + èŠ±è‰² (ä¾‹å¦‚: As, 10s)
        const cardRegex = new RegExp(`(${suitRegex}${rankRegex})|(${rankRegex}${suitRegex})`, 'g');
        
        const parts = input.match(cardRegex) || [];
        
        if (parts.length !== 5) {
             throw new Error(`å¿…é¡»è¾“å…¥5å¼ ç‰Œï¼Œå½“å‰è¯†åˆ«åˆ° ${parts.length} å¼ `);
        }

        const parsedCards = [];
        
        // Helper to find card in deck
        const findCard = (suitChar, rankStr) => {
             // Normalize suitChar to standard symbol or match deck properties
             // rankStr could be '10', 'A', 't', etc.
             
             // Map input suit to deck suit symbol
             const suitMap = {
                 's': 'â™ ', 'S': 'â™ ', 'â™ ': 'â™ ',
                 'h': 'â™¥', 'H': 'â™¥', 'â™¥': 'â™¥',
                 'c': 'â™£', 'C': 'â™£', 'â™£': 'â™£',
                 'd': 'â™¦', 'D': 'â™¦', 'â™¦': 'â™¦'
             };
             
             const targetSuit = suitMap[suitChar];
             if (!targetSuit) return null;

             // Map rank string to value/label
             const rankMap = {
                 '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                 't': 10, 'T': 10,
                 'j': 11, 'J': 11,
                 'q': 12, 'Q': 12,
                 'k': 13, 'K': 13,
                 'a': 14, 'A': 14, '1': 14
             };
             const targetRankVal = rankMap[rankStr];
             if (!targetRankVal) return null;

             return deck.find(c => c.suit === targetSuit && c.rank === targetRankVal);
        };

        for (let part of parts) {
            let suitChar = '';
            let rankStr = '';
            
            // Regex: Suit first or Rank first
            // Suit: [â™ â™¥â™£â™¦sShHcCdD]
            // Rank: [2-9]|10|[tTjJqQkKaA]|1
            
            const matchPrefix = part.match(/^([â™ â™¥â™£â™¦sShHcCdD])([2-9]|10|[tTjJqQkKaA]|1)$/);
            const matchSuffix = part.match(/^([2-9]|10|[tTjJqQkKaA]|1)([â™ â™¥â™£â™¦sShHcCdD])$/);

            if (matchPrefix) {
                suitChar = matchPrefix[1];
                rankStr = matchPrefix[2];
            } else if (matchSuffix) {
                rankStr = matchSuffix[1];
                suitChar = matchSuffix[2];
            } else {
                throw new Error(`æ— æ³•è¯†åˆ«çš„ç‰Œ: ${part}`);
            }

            const card = findCard(suitChar, rankStr);
            if (!card) {
                throw new Error(`æ— æ³•è¯†åˆ«çš„ç‰Œ: ${part}`);
            }
            parsedCards.push(card);
        }
        return parsedCards;
    }

    function evaluateHand(cards) {
        // æ’åºç‰Œé¢ (ä»å¤§åˆ°å°)
        const sortedCards = [...cards].sort((a, b) => b.rank - a.rank);
        const ranks = sortedCards.map(c => c.rank);
        const suits = sortedCards.map(c => c.suit);

        // æ£€æŸ¥åŒèŠ±
        const isFlush = suits.every(s => s === suits[0]);

        // æ£€æŸ¥é¡ºå­
        let isStraight = true;
        for (let i = 0; i < 4; i++) {
            if (ranks[i] - ranks[i+1] !== 1) {
                isStraight = false;
                break;
            }
        }
        // ç‰¹æ®Šæƒ…å†µ: A-5-4-3-2 (A=14, 2=2)
        // æ­¤æ—¶ ranks æ˜¯ [14, 5, 4, 3, 2]
        if (!isStraight && ranks[0] === 14 && ranks[1] === 5 && ranks[2] === 4 && ranks[3] === 3 && ranks[4] === 2) {
            isStraight = true;
            // ä¸ºäº†æ¯”è¾ƒå¤§å°ï¼Œè¿™é‡ŒæŠŠå®ƒå½“ä½œ 5-high straight
            // ä½†æ˜¯åœ¨åˆ†æ•°è®¡ç®—æ—¶éœ€è¦ç‰¹æ®Šå¤„ç†ï¼ŒæŠŠAå½“ä½œ1æ¥å¤„ç†
        }

        // ç»Ÿè®¡ç‚¹æ•°é¢‘ç‡
        const rankCounts = {};
        ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
        
        // è·å–å››æ¡ã€ä¸‰æ¡ã€å¯¹å­
        const counts = Object.values(rankCounts);
        const isFourOfAKind = counts.includes(4);
        const isThreeOfAKind = counts.includes(3);
        const pairCount = counts.filter(c => c === 2).length;

        let handTypeIndex = 0; // 0-9, å¯¹åº” HAND_TYPES ç´¢å¼•
        let score = 0;

        // è®¡ç®—åŸºç¡€åˆ†æ•° (Base Score)
        // æ¯ä¸€çº§ç›¸å·® 1,000,000,000 (10^9) ä¿è¯çº§åˆ«å‹åˆ¶
        // çº§åˆ«å†…æ¯”è¾ƒä½¿ç”¨ HEX ç±»ä¼¼æ€æƒ³: 
        // c1*16^4 + c2*16^3 + ...
        // è¿™é‡Œç®€å•ç”¨ 100è¿›åˆ¶

        const getKickersValue = (cardRanks) => {
            let val = 0;
            let power = 1;
            for (let i = cardRanks.length - 1; i >= 0; i--) {
                val += cardRanks[i] * power;
                power *= 100;
            }
            return val;
        };

        if (isFlush && isStraight) {
            if (ranks[0] === 14 && ranks[1] === 13) { // Royal Flush
                handTypeIndex = 9;
                score = 9 * 10000000000;
            } else { // Straight Flush
                handTypeIndex = 8;
                // å¤„ç† A-5-4-3-2 çš„æƒ…å†µï¼Œæ­¤æ—¶æœ€å¤§ç‰Œæ˜¯ 5
                let highRank = ranks[0];
                if (ranks[0] === 14 && ranks[4] === 2) highRank = 5;
                score = 8 * 10000000000 + highRank;
            }
        } else if (isFourOfAKind) {
            handTypeIndex = 7;
            const quadRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 4));
            const kicker = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 1));
            score = 7 * 10000000000 + quadRank * 100 + kicker;
        } else if (isThreeOfAKind && pairCount === 1) { // Full House
            handTypeIndex = 6;
            const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
            const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
            score = 6 * 10000000000 + tripRank * 100 + pairRank;
        } else if (isFlush) {
            handTypeIndex = 5;
            score = 5 * 10000000000 + getKickersValue(ranks);
        } else if (isStraight) {
            handTypeIndex = 4;
            let highRank = ranks[0];
            if (ranks[0] === 14 && ranks[4] === 2) highRank = 5;
            score = 4 * 10000000000 + highRank;
        } else if (isThreeOfAKind) {
            handTypeIndex = 3;
            const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
            const kickers = ranks.filter(r => r !== tripRank);
            score = 3 * 10000000000 + tripRank * 10000 + getKickersValue(kickers);
        } else if (pairCount === 2) {
            handTypeIndex = 2;
            const pairs = Object.keys(rankCounts).filter(key => rankCounts[key] === 2).map(Number).sort((a,b) => b-a);
            const kicker = ranks.find(r => !pairs.includes(r));
            score = 2 * 10000000000 + pairs[0] * 10000 + pairs[1] * 100 + kicker;
        } else if (pairCount === 1) {
            handTypeIndex = 1;
            const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
            const kickers = ranks.filter(r => r !== pairRank);
            score = 1 * 10000000000 + pairRank * 1000000 + getKickersValue(kickers);
        } else {
            handTypeIndex = 0;
            score = getKickersValue(ranks);
        }

        return {
            handTypeName: HAND_TYPES[handTypeIndex].name,
            score: score
        };
    }

    function editEntry(id) {
        const entry = handHistory.find(h => h.id === id);
        if (!entry) return;

        currentEditingId = id;
        
        // Populate inputs
        document.getElementById('serialInput').value = entry.serial;
        document.getElementById('teamInput').value = entry.team;
        
        // Populate cards
        entry.cards.forEach((card, i) => {
             selectedCards[i+1] = card;
             const trigger = document.getElementById(`trigger${i+1}`);
             trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> â–¾`;
             trigger.classList.add('filled');
        });
        // updateTextInput(); // Removed

        // Update UI state
        document.getElementById('actionBtn').textContent = 'æ›´æ–°';
        document.getElementById('actionBtn').style.backgroundColor = 'var(--xmas-light-green)';
        document.getElementById('cancelBtn').style.display = 'inline-block';
        
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function cancelEdit() {
        currentEditingId = null;
        
        // Clear inputs
        document.getElementById('serialInput').value = '';
        document.getElementById('teamInput').value = '';
        // document.getElementById('cardInput').value = ''; // Removed
        
        // Clear dropdowns
        for (let i = 1; i <= 5; i++) {
             selectedCards[i] = null;
             const trigger = document.getElementById(`trigger${i}`);
             trigger.innerHTML = `... â–¾`;
             trigger.classList.remove('filled');
        }

        // Reset UI state
        document.getElementById('actionBtn').textContent = 'è®¡ç®— & æ’å';
        document.getElementById('actionBtn').style.backgroundColor = 'var(--xmas-green)';
        document.getElementById('cancelBtn').style.display = 'none';
        document.getElementById('errorMsg').style.display = 'none';
    }

    function clearData() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
            handHistory = [];
            if (supabaseClient && currentYear) supabaseClient.from('hands').delete().eq('year', currentYear);
            cancelEdit();
            updateTable();
        }
    }

    function updateTable() {
        const tbody = document.querySelector('#rankingTable tbody');
        tbody.innerHTML = '';

        let effectiveRank = 1;

        handHistory.forEach((entry, index) => {
            const tr = document.createElement('tr');
            
            // Determine effective rank (handle ties)
            if (index > 0 && entry.score === handHistory[index-1].score) {
                // Tie with previous: effectiveRank remains unchanged
            } else {
                // No tie: effectiveRank is the current position
                effectiveRank = index + 1;
            }

            // æ’å
            const tdRank = document.createElement('td');
            tdRank.textContent = effectiveRank;
            tr.appendChild(tdRank);
            
            // åºå·
            const tdSerial = document.createElement('td');
            tdSerial.textContent = entry.serial;
            tr.appendChild(tdSerial);
            
            // é˜Ÿä¼åç§°
            const tdTeam = document.createElement('td');
            if (isImage(entry.team)) {
                const img = document.createElement('img');
                img.src = entry.team;
                img.style.height = '30px';
                tdTeam.appendChild(img);
            } else {
                tdTeam.textContent = entry.team;
            }
            tr.appendChild(tdTeam);

            // ç‰Œå‹åç§°
            const tdType = document.createElement('td');
            tdType.textContent = entry.handTypeName;
            tr.appendChild(tdType);

            // ç‰Œé¢
            const tdCards = document.createElement('td');
            entry.cards.forEach(card => {
                const span = document.createElement('span');
                span.className = `card ${card.color === 'red' ? 'suit-red' : 'suit-black'}`;
                span.textContent = `${card.suit}${card.rankLabel}`;
                tdCards.appendChild(span);
            });
            tr.appendChild(tdCards);

            // ç§¯åˆ†
            const tdPoints = document.createElement('td');
            // Points calculation based on effective rank
            // Rank 1 gets totalTeams points
            // Rank N gets totalTeams - N + 1 points
            const points = totalTeams - effectiveRank + 1;
            
            tdPoints.textContent = points;
            tdPoints.style.fontWeight = 'bold';
            tdPoints.style.color = points > 0 ? 'var(--xmas-green)' : 'var(--xmas-red)';
            tr.appendChild(tdPoints);

            // åˆ†æ•° (Debugç”¨ï¼Œä¹Ÿå¯ä»¥æ˜¾ç¤º)
            const tdScore = document.createElement('td');
            tdScore.textContent = entry.score.toLocaleString();
            tr.appendChild(tdScore);
            
            // æ“ä½œ
            if (isAdmin) {
                const tdAction = document.createElement('td');
                const editBtn = document.createElement('button');
                editBtn.textContent = 'ç¼–è¾‘';
                editBtn.style.padding = '5px 10px';
                editBtn.style.fontSize = '12px';
                editBtn.onclick = () => editEntry(entry.id);
                tdAction.appendChild(editBtn);
                tr.appendChild(tdAction);
            }

            tbody.appendChild(tr);
        });
    }

    function exportRanking() {
        if (handHistory.length === 0) {
            alert('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
            return;
        }

        // Prepare data for export
        let effectiveRank = 1;
        const data = handHistory.map((entry, index) => {
            // Determine effective rank (handle ties)
            if (index > 0 && entry.score === handHistory[index-1].score) {
                // Tie: effectiveRank remains unchanged
            } else {
                effectiveRank = index + 1;
            }

            const points = totalTeams - effectiveRank + 1;
            
            // æ ¼å¼åŒ–ç‰Œé¢å­—ç¬¦ä¸²ï¼Œç§»é™¤é¢œè‰²æ ‡è®°ï¼Œçº¯æ–‡æœ¬
            const cardStr = entry.cards.map(c => `${c.suit}${c.rankLabel}`).join(' ');
            
            return {
                "æ’å": effectiveRank,
                "åºå·": entry.serial,
                "é˜Ÿä¼åç§°": isImage(entry.team) ? "[å›¾ç‰‡é˜Ÿä¼]" : entry.team,
                "ç‰Œå‹åç§°": entry.handTypeName,
                "ç‰Œé¢": cardStr,
                "ç§¯åˆ†": points,
                "åˆ†æ•°": entry.score
            };
        });

        // Create worksheet
        const ws = XLSX.utils.json_to_sheet(data);
        
        // Adjust column widths
        const wscols = [
            {wch: 6},  // æ’å
            {wch: 10}, // åºå·
            {wch: 20}, // é˜Ÿä¼åç§°
            {wch: 20}, // ç‰Œå‹åç§°
            {wch: 25}, // ç‰Œé¢
            {wch: 8},  // ç§¯åˆ†
            {wch: 15}  // åˆ†æ•°
        ];
        ws['!cols'] = wscols;

        // Create workbook
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "æ’è¡Œæ¦œ");

        // Generate filename with timestamp
        const date = new Date();
        const dateStr = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        const timeStr = `${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}`;
        const filename = `å¾·å·æ‰‘å…‹æ’è¡Œæ¦œ_${dateStr}_${timeStr}.xlsx`;

        // Export
        try {
            XLSX.writeFile(wb, filename);
        } catch (e) {
            alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }

    // å¯åŠ¨
    init();
</script>

</body>
</html>
