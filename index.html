<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ£è¯å¤§å†’é™©ç»Ÿè®¡</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Christmas Theme Palette */
        :root {
            --xmas-red: #D42426;
            --xmas-green: #165B33;
            --xmas-light-green: #2E8B57;
            --xmas-gold: #F8B229;
            --xmas-bg: #f0f2f5;
            --xmas-white: #ffffff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--xmas-bg);
            /* Simple snow pattern */
            background-image: radial-gradient(#e6e9ef 15%, transparent 16%), radial-gradient(#e6e9ef 15%, transparent 16%);
            background-size: 60px 60px;
            background-position: 0 0, 30px 30px;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background-color: var(--xmas-white);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 1400px;
            border-top: 6px solid var(--xmas-red);
            position: relative;
        }
        /* Decorative ribbon effect */
        .container::before {
            content: "ğŸ„";
            position: absolute;
            top: -25px;
            left: 20px;
            font-size: 40px;
            z-index: 10;
        }
        .container::after {
            content: "ğŸ…";
            position: absolute;
            top: -25px;
            right: 20px;
            font-size: 40px;
            z-index: 10;
        }

        h1 {
            color: var(--xmas-red);
            text-align: center;
            margin-bottom: 25px;
            font-weight: 800;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            letter-spacing: 1px;
            border-bottom: 2px dashed var(--xmas-green);
            padding-bottom: 10px;
            display: inline-block;
            width: 100%;
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 2px solid #eee;
            margin-bottom: 20px;
            justify-content: center;
        }
        .tab-btn {
            padding: 12px 24px;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            transition: all 0.3s;
            font-size: 15px;
        }
        .tab-btn:hover {
            color: var(--xmas-light-green);
            background-color: rgba(46, 139, 87, 0.05);
            border-radius: 5px 5px 0 0;
        }
        .tab-btn.active {
            color: var(--xmas-green);
            border-bottom-color: var(--xmas-red);
        }
        .tab-content {
            display: none;
            animation: fadeIn 0.4s ease-out;
        }
        .tab-content.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Card Selector Styles */
        .card-selectors {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
            background: #f9fdf9;
            padding: 15px;
            border-radius: 8px;
            border: 1px dashed #d1e7dd;
        }
        
        .card-input-group {
            display: flex;
            flex-direction: column;
            width: 120px;
            position: relative;
        }

        .card-label {
            font-size: 14px;
            color: var(--xmas-green);
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }

        .card-select-trigger {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 42px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .card-select-trigger:hover {
            border-color: var(--xmas-light-green);
            box-shadow: 0 0 0 3px rgba(46, 139, 87, 0.1);
        }

        .card-select-trigger.filled {
            background-color: #e8f5e9;
            border-color: #a5d6a7;
            color: #1b5e20;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            width: 200px;
            max-height: 300px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            display: none;
            overflow-y: auto;
            padding: 5px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .search-box {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #eee;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .search-box:focus {
            outline: none;
            border-color: var(--xmas-light-green);
        }

        .card-option {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s;
        }

        .card-option:hover {
            background-color: #f1f8e9;
        }

        .card-option.selected {
            background-color: #e8f5e9;
            color: var(--xmas-green);
        }
        
        .action-area {
            text-align: center;
            margin: 25px 0;
        }

        button {
            padding: 12px 40px;
            font-size: 16px;
            background-color: var(--xmas-green);
            color: white;
            border: none;
            border-radius: 25px; /* Rounder buttons */
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(22, 91, 51, 0.2);
            font-weight: 600;
        }
        button:hover {
            background-color: var(--xmas-light-green);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(22, 91, 51, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 20px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 0 1px #eee;
        }
        th, td {
            padding: 14px 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        th {
            background-color: var(--xmas-green);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 14px;
            letter-spacing: 0.5px;
        }
        tr:last-child td {
            border-bottom: none;
        }
        table tr { position: relative; }
        tr:hover td { background-color: inherit; }
        tr:hover::after {
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            border: 2px solid rgba(46, 139, 87, 0.55);
            border-radius: 8px;
            pointer-events: none;
        }

        .card {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 4px;
            background: #fff;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .suit-red { color: var(--xmas-red); }
        .suit-black { color: #292b2c; }
        
        .error-msg {
            color: var(--xmas-red);
            margin-top: 10px;
            display: none;
            text-align: center;
            padding: 10px;
            background: #fff5f5;
            border-radius: 4px;
            border: 1px solid #ffebee;
        }

        /* Modal Styles */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.5); 
            backdrop-filter: blur(3px);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto; 
            padding: 25px;
            border: none;
            width: 90%; 
            max-width: 600px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            animation: modalFadeIn 0.3s;
            border-top: 5px solid var(--xmas-green);
        }

        @keyframes modalFadeIn {
            from {opacity: 0; transform: translateY(-20px);}
            to {opacity: 1; transform: translateY(0);}
        }

        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            transition: color 0.2s;
        }

        .close-modal:hover,
        .close-modal:focus {
            color: var(--xmas-red);
            text-decoration: none;
            cursor: pointer;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            box-shadow: none;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }

        /* Mobile Optimization */
        @media (max-width: 768px) {
            body {
                padding: 10px 5px;
                background-size: 30px 30px;
            }
            .container {
                padding: 15px 10px;
                width: 100%;
                box-sizing: border-box;
            }
            .container::before, .container::after {
                font-size: 24px;
                top: -15px;
            }
            h1 {
                font-size: 22px;
                margin-bottom: 15px;
            }
            
            /* Scrollable Tabs */
            .tabs {
                justify-content: flex-start;
                overflow-x: auto;
                white-space: nowrap;
                padding-bottom: 5px;
                margin-bottom: 15px;
                -webkit-overflow-scrolling: touch;
                border-bottom: 1px solid #eee;
            }
            .tab-btn {
                padding: 10px 15px;
                font-size: 14px;
                flex-shrink: 0;
            }
            
            /* Stack inputs */
            .input-group {
                flex-direction: column !important;
                align-items: stretch !important;
            }
            .input-group select, 
            .input-group input {
                width: 100% !important;
                box-sizing: border-box;
                margin-bottom: 8px;
            }
            
            /* Compact Card Selectors - Grid Layout */
            .card-selectors {
                gap: 8px;
                padding: 10px;
                display: grid;
                grid-template-columns: repeat(3, 1fr); /* 3 per row */
            }
            .card-input-group {
                width: auto; /* Let grid handle width */
                min-width: 0;
            }
            
            .card-label {
                font-size: 12px;
            }
            .card-select-trigger {
                padding: 5px;
                font-size: 13px;
                min-height: 40px;
            }
            
            /* Fix Dropdown Overflow */
            .dropdown-menu {
                width: 180px; 
                max-width: 85vw;
            }
            /* Align right for right-side items to prevent overflow */
            .card-input-group:nth-child(3n) .dropdown-menu,
            .card-input-group:nth-child(3n-1) .dropdown-menu {
                right: 0;
                left: auto;
            }

            /* Table Scroll */
            .table-responsive {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                border-radius: 8px;
                box-shadow: 0 0 0 1px #eee;
                margin-bottom: 15px;
            }
            table {
                min-width: 600px;
                margin-top: 0;
                box-shadow: none;
                border-radius: 0;
            }
            th, td {
                padding: 8px 6px;
                font-size: 13px;
                white-space: nowrap;
            }
            
            /* Modal adjust */
            .modal-content {
                width: 90%;
                margin: 15% auto;
                padding: 20px;
                max-height: 85vh;
                overflow-y: auto;
            }
            
            /* Toolbar Buttons Grid */
            .toolbar {
                flex-wrap: wrap;
                gap: 8px;
            }
            .toolbar button {
                flex: 1 1 calc(50% - 8px); /* 2 buttons per row */
                padding: 10px 5px;
                font-size: 13px;
            }
            
            /* Search Container Stack */
            .search-container {
                flex-direction: column;
                align-items: stretch;
                padding: 12px;
            }
            .search-container input, 
            .search-container button,
            .search-container .hand-type-btn {
                width: 100% !important;
                max-width: none;
                margin-bottom: 8px;
            }
            
            /* Year Modal Specifics */
            .year-modal-body {
                flex-direction: column !important;
                align-items: stretch !important;
            }
            .year-modal-body select,
            .year-modal-body input,
            .year-modal-body button {
                width: 100% !important;
                margin-bottom: 10px;
            }

            /* Prevent Zoom on Focus */
            select, input, textarea {
                font-size: 16px !important;
            }
            /* Wish Input Group Grid */
            #wishFormSection .input-group {
                display: grid !important;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
            #wishFormSection .input-group input {
                width: 100% !important;
                min-width: 0;
            }
        }
        /* Team List Styles */
        .team-group-header {
            background-color: #f8f9fa;
            padding: 10px 15px;
            font-weight: bold;
            color: #495057;
            border-left: 4px solid var(--xmas-red);
            margin-top: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .team-list-table {
            width: 100%;
            margin-bottom: 10px;
        }
        .team-list-table td {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .tag {
            display: inline-block;
            background: #e8f5e9; /* Light green */
            color: var(--xmas-green);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-right: 5px;
            border: 1px solid #c8e6c9;
        }

        /* Search Area Styles */
        .search-container {
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 5px rgba(0,0,0,0.02);
        }
        
        .search-input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 20px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        
        .search-input:focus {
            border-color: var(--xmas-green);
            box-shadow: 0 0 0 3px rgba(22, 91, 51, 0.1);
        }
        
        .btn-icon {
            margin-right: 5px;
        }
        
        /* Custom Button Colors */
        .btn-success { background-color: var(--xmas-green) !important; }
        .btn-info { background-color: var(--xmas-light-green) !important; }
        .btn-danger { background-color: var(--xmas-red) !important; }
        .btn-secondary { background-color: #6c757d !important; }
        
        .hand-type-btn {
            width: 140px;
            padding: 8px 15px;
            border: 1px solid #ced4da;
            border-radius: 20px;
            background: white;
            color: #495057;
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .hand-type-btn:hover {
            border-color: var(--xmas-green);
        }

        /* Header Buttons */
        .header-btn {
            background-color: rgba(255, 255, 255, 0.9);
            color: var(--xmas-green);
            border: 1px solid var(--xmas-green);
            border-radius: 20px;
            padding: 8px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            font-weight: 600;
        }

        .header-btn:hover {
            background-color: var(--xmas-green);
            color: white;
            box-shadow: 0 4px 8px rgba(22, 91, 51, 0.2);
            transform: translateY(-1px);
        }
        
        .header-btn.settings-btn {
            border-color: var(--xmas-red);
            color: var(--xmas-red);
        }
        
        .header-btn.settings-btn:hover {
            background-color: var(--xmas-red);
            color: white;
        }
        
        @media (max-width: 768px) {
            .header-buttons {
                position: absolute;
                top: 15px;
                right: 15px;
            }
            .header-btn {
                padding: 6px 10px;
                font-size: 12px;
            }
            .header-btn .btn-text {
                display: none;
            }
        }

        /* Large Screen Optimization */
        @media (min-width: 1200px) {
            .search-container {
                display: grid;
                grid-template-columns: 80px 1fr 1fr 240px 160px 100px; /* Increased Wish column */
                gap: 12px; /* Slightly reduced gap */
                align-items: center;
            }
            .search-container input.search-input,
            .search-container button,
            .search-container .hand-type-btn {
                width: 100% !important;
                margin-bottom: 0;
            }
            /* Min-Max Wrapper (4th child) */
            .search-container > div:nth-child(4) {
                display: flex;
                width: 100%;
                gap: 5px;
                align-items: center;
            }
            /* Target inputs inside Min-Max wrapper specifically to prevent overflow */
            .search-container > div:nth-child(4) input.search-input {
                width: auto !important; /* Allow flex to control width */
                flex: 1;
                min-width: 0; /* Important for flex shrinking */
            }
            /* Hand Type Wrapper (5th child) */
            .search-container > div:nth-child(5) {
                width: 100%;
            }
            /* Dropdown menu width adjustment */
            .search-container .dropdown-menu {
                width: 200px; /* Keep fixed width or match parent */
            }
        }
        
        /* Christmas Loader Styles */
        .christmas-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.98);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 0.5s;
        }

        .loader-content {
            text-align: center;
        }

        .santa-icon {
            font-size: 80px;
            animation: bounce 1s infinite alternate;
        }

        .loading-text {
            font-size: 24px;
            font-weight: bold;
            color: var(--xmas-red);
            margin-top: 20px;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif; /* Cute font */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .snowflakes {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .flake {
            font-size: 24px;
            animation: spin 2s linear infinite;
            color: #87CEEB;
        }

        .flake:nth-child(2) { animation-delay: 0.2s; color: #B0E0E6; }
        .flake:nth-child(3) { animation-delay: 0.4s; color: #ADD8E6; }

        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-20px); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<div id="pageLoader" class="christmas-loader">
    <div class="loader-content">
        <div class="santa-icon">ğŸ…</div>
        <div class="loading-text">æ­£åœ¨åŠ è½½åœ£è¯æƒŠå–œ...</div>
        <div class="snowflakes">
            <div class="flake">â„ï¸</div>
            <div class="flake">â„ï¸</div>
            <div class="flake">â„ï¸</div>
        </div>
    </div>
</div>

<div class="container">
    <div class="header-buttons" style="position: absolute; right: 20px; top: 20px; display: flex; gap: 10px;">
        <button onclick="openYearModal()" class="header-btn year-btn" title="åˆ‡æ¢å¹´ä»½">
            ğŸ“… <span class="btn-text">åˆ‡æ¢å¹´ä»½</span>
        </button>
        <button id="headerSettingsBtn" onclick="openModal('settingsModal')" class="header-btn settings-btn" title="è®¾ç½®" style="display: none;">
            âš™ï¸ <span class="btn-text">è®¾ç½®</span>
        </button>
        <button id="btnSaveSnapshot" onclick="openSnapshotModal('save')" class="header-btn" title="å¦å­˜å¿«ç…§" style="display: none;">
            ğŸ’¾ <span class="btn-text">å¦å­˜å¿«ç…§</span>
        </button>
        <button id="btnLoadSnapshot" onclick="openSnapshotModal('load')" class="header-btn" title="è¯»å–å¿«ç…§" style="display: none;">
            ğŸ“¥ <span class="btn-text">è¯»å–å¿«ç…§</span>
        </button>
    </div>
    <h1>åœ£è¯å¤§å†’é™©ç»Ÿè®¡</h1>
    
    <div class="tabs">
        <div class="tab-btn active" onclick="switchTab('teams')">é˜Ÿä¼åˆ—è¡¨</div>
        <div class="tab-btn" onclick="switchTab('calc')">ç‰Œå‹æ’è¡Œ</div>
        <div class="tab-btn" onclick="switchTab('wishes')">å¿ƒæ„¿æ’è¡Œ</div>
        <div class="tab-btn" onclick="switchTab('final')">æœ€ç»ˆæ’è¡Œ</div>
        <div class="tab-btn" onclick="switchTab('gifts')">ç¤¼ç‰©é€‰æ‹©</div>
        <!-- <div class="tab-btn" onclick="switchTab('changes')" style="display: none;" id="tabBtnChanges">æ’åå˜åŒ–</div> -->
    </div>

    <!-- Final Ranking Tab -->
    <div id="tab-final" class="tab-content">
        <div class="toolbar">
            <button id="btnFinalExport" onclick="exportFinalRanking()" class="btn-secondary btn-success"><span class="btn-icon">ğŸ“¤</span>å¯¼å‡ºæ€»æ¦œ</button>
        </div>
        
        <div style="margin-bottom: 10px; padding: 10px; background: #fff; border-radius: 5px; border: 1px solid #eee; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; font-size: 13px;">
            <strong style="color: var(--xmas-green);">ç¤¼ç‰©æ¡£ä½å›¾ç¤º:</strong>
            <span id="tierLegendContainer" style="display: flex; gap: 10px; flex-wrap: wrap;">
                <!-- Generated by JS -->
            </span>
        </div>

        <!-- Search Inputs -->
        <div class="search-container">
            <input type="text" id="searchSerial" class="search-input" placeholder="åºå·" style="width: 80px;" oninput="updateFinalRanking()">
            <input type="text" id="searchTeam" class="search-input" placeholder="é˜Ÿä¼åç§° (æ¨¡ç³Š)" style="width: 150px;" oninput="updateFinalRanking()">
            <input type="text" id="searchMembers" class="search-input" placeholder="æˆå‘˜ (æ¨¡ç³Š)" style="width: 150px;" oninput="updateFinalRanking()">
            <div style="display: flex; align-items: center; gap: 5px;">
                <input type="number" id="searchWishMin" class="search-input" placeholder="å¿ƒæ„¿åˆ†Min" style="width: 100px;" oninput="updateFinalRanking()">
                <span style="color: #999;">-</span>
                <input type="number" id="searchWishMax" class="search-input" placeholder="Max" style="width: 100px;" oninput="updateFinalRanking()">
        </div>
        
        <div style="position: relative; display: inline-block;">
            <button onclick="toggleHandTypeDropdown()" id="handTypeDropdownBtn" class="hand-type-btn">
                <span>é€‰æ‹©ç‰Œå‹</span>
                <span style="font-size: 12px;">â–¼</span>
            </button>
            <div id="handTypeDropdown" class="dropdown-menu" style="width: 180px;">
                <div style="padding: 8px; border-bottom: 1px solid #eee;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-weight: bold; font-size: 14px;">
                        <input type="checkbox" onclick="toggleAllHandTypes(this)" style="margin-right: 8px;"> å…¨é€‰
                    </label>
                </div>
                <div id="handTypeList" style="max-height: 250px; overflow-y: auto;">
                    <!-- JS Generated -->
                </div>
            </div>
        </div>

        <button onclick="clearFinalSearch()" class="btn-secondary" style="padding: 8px 20px;">é‡ç½®</button>
    </div>

        <div class="table-responsive">
            <table id="finalRankingTable">
                <thead>
                    <tr>
                        <th>æœ€ç»ˆæ’å</th>
                        <th>åºå·</th>
                        <th>é˜Ÿä¼åç§°</th>
                        <th>æˆå‘˜</th>
                        <th>å¿ƒæ„¿æ€»è®¡</th>
                        <th>å¿ƒæ„¿ç§¯åˆ†</th>
                        <th>ç‰Œå‹åç§°</th>
                        <th>ç‰Œé¢</th>
                        <th>ç‰Œå‹ç§¯åˆ†</th>
                        <th>æœ€ç»ˆåˆ†æ•°</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Dynamic Content -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Rank Change Tab (Disabled) -->
    <!--
    <div id="tab-changes" class="tab-content">
        <div class="toolbar" style="margin-bottom: 10px; display:flex; gap:10px;">
            <button onclick="renderRankChangeTab()" class="btn-secondary"><span class="btn-icon">ğŸ”„</span>åˆ·æ–°</button>
        </div>
        <div id="rankChangeContainer" class="table-responsive"></div>
    </div>
    -->
    <!-- Snapshot Modal -->
    <div id="snapshotModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('snapshotModal')">&times;</span>
            <h2 style="margin-top: 0; color: var(--xmas-green);">æ•°æ®å¿«ç…§</h2>
            
            <div id="snapshotModeSave" style="display:none;">
                <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                    <input type="text" id="snapshotNameInput" placeholder="å¿«ç…§åç§° (é»˜è®¤å½“å‰æ—¶é—´)" style="flex:1; padding:10px; border:1px solid #ccc; border-radius:5px;">
                    <button onclick="saveDataSnapshot()" class="btn-secondary btn-success" style="padding:8px 20px;">ä¿å­˜å¿«ç…§</button>
                </div>
                <p style="font-size:12px; color:#666;">è¯´æ˜ï¼šä¿å­˜å½“å‰å¹´ä»½çš„æ‰€æœ‰é˜Ÿä¼ã€å¿ƒæ„¿ã€æ‰‹ç‰Œã€ç¤¼ç‰©é…ç½®ç­‰æ•°æ®ä¸ºä¸€ä¸ªå¿«ç…§ã€‚</p>
            </div>
            
            <div id="snapshotModeLoad" style="display:none;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <h3 style="margin:0; font-size:16px; color:#495057;">å·²æœ‰å¿«ç…§</h3>
                    <button onclick="refreshSnapshotList()" class="btn-secondary" style="padding:5px 10px; font-size:12px;">åˆ·æ–°</button>
                </div>
                <div id="snapshotListContainer" style="max-height:300px; overflow:auto; border:1px solid #eee; border-radius:6px; padding:8px;">
                    <!-- Filled by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Gift Selection Tab -->
    <div id="tab-gifts" class="tab-content">
        <div class="toolbar" style="margin-bottom: 20px; display:flex; gap:10px;">
            <button onclick="viewGiftImages()" class="btn-secondary"><span class="btn-icon">ğŸ–¼ï¸</span>æŸ¥çœ‹ç¤¼ç‰©å‚è€ƒå›¾</button>
            <button id="btnGiftExport" onclick="exportGiftSelection()" class="btn-secondary btn-success" style="padding: 8px 20px;">ğŸ“¤ å¯¼å‡ºç¤¼ç‰©é€‰æ‹©</button>
        </div>
        
        <div class="search-container" style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
            <input type="text" id="searchGiftTeam" class="search-input" placeholder="é˜Ÿä¼åç§° (æ¨¡ç³Š)" oninput="renderGiftSelection()" style="flex: 1; min-width: 150px;">
            <input type="text" id="searchGiftMember" class="search-input" placeholder="æˆå‘˜ (æ¨¡ç³Š)" oninput="renderGiftSelection()" style="flex: 1; min-width: 150px;">
        </div>
        
        <div class="table-responsive">
            <table id="giftSelectionTable">
                <thead>
                    <tr>
                        <th>æœ€ç»ˆæ’å</th>
                        <th>ç¤¼ç‰©æ¡£ä½</th>
                        <th>é˜Ÿä¼åç§°</th>
                        <th>ç¤¼ç‰©é€‰æ‹© (æˆå‘˜å¯¹åº”ç¼–å·)</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Dynamic Content -->
                </tbody>
            </table>
        </div>
    </div>
    
    <!-- Gift Images Modal (for viewing) -->
    <div id="giftImagesModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close-modal" onclick="closeModal('giftImagesModal')">&times;</span>
            <h2 style="margin-top: 0; color: var(--xmas-green);">ç¤¼ç‰©å‚è€ƒå›¾</h2>
            <div id="giftImagesViewContainer" style="display: flex; flex-wrap: wrap; gap: 15px; justify-content: center;">
                <!-- Generated by JS -->
            </div>
        </div>
    </div>

    <!-- Calculator Tab -->
    <div id="tab-calc" class="tab-content">
        <div class="toolbar" id="calcToolbar">
            <button id="btnCalcImport" onclick="openModal('importModal')" class="btn-secondary" style="padding: 8px 20px;">ğŸ“‚ æ‰¹é‡å¯¼å…¥</button>
            <button id="btnExportRanking" onclick="exportRanking()" class="btn-secondary btn-info" style="padding: 8px 20px; font-size: 14px;">ğŸ“¤ å¯¼å‡ºè¡¨æ ¼</button>
            <button id="btnClearHandData" onclick="clearData()" class="btn-secondary btn-danger" style="padding: 8px 20px; font-size: 14px;">æ¸…ç©ºæ•°æ®</button>
        </div>

        <!-- Batch Hand Form -->
        <div id="calcFormSection" style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; font-size: 16px; color: var(--xmas-green);">å½•å…¥/ç¼–è¾‘ç‰Œå‹</h3>
                <button onclick="addHandRow()" class="btn-secondary" style="padding: 5px 15px; font-size: 12px;">+ æ·»åŠ ä¸€è¡Œ</button>
            </div>
            
            <div id="handRowsContainer">
                <!-- Dynamic Rows -->
            </div>

            <div style="text-align: center; margin-top: 15px;">
                <button id="cancelBtn" onclick="cancelEdit()" style="padding: 8px 25px; background-color: #6c757d; margin-right: 10px; display: none;">å–æ¶ˆç¼–è¾‘</button>
                <button id="actionBtn" onclick="processBatchHands()" style="padding: 8px 25px;">æ‰¹é‡è®¡ç®— & æ’å</button>
            </div>
            <div id="errorMsg" class="error-msg"></div>
        </div>

    <!-- Bulk Import Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('importModal')">&times;</span>
            <h2 style="margin-top: 0; color: var(--xmas-green);">æ‰¹é‡å¯¼å…¥ (Excel/CSV)</h2>
            
            <div style="margin-top: 20px;">
                <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border: 1px dashed #ccc; border-radius: 5px;">
                    <p style="margin: 0 0 10px 0; font-size: 14px; font-weight: bold;">ä¸Šä¼ æ–‡ä»¶å¯¼å…¥:</p>
                    <input type="file" id="fileInput" accept=".xlsx, .xls, .csv" onchange="handleFileUpload(event)" style="width: 100%;">
                </div>

                <p style="font-size: 14px; color: #666; margin-bottom: 5px;">æˆ–ç²˜è´´å†…å®¹ (æ ¼å¼: åºå· | é˜Ÿä¼åç§° | ç‰Œé¢)</p>
                <textarea id="bulkInput" rows="10" style="width: 100%; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 5px; font-family: monospace;" placeholder="ä¾‹å¦‚:
1	TeamA	â™ A â™¥K â™£Q â™¦J â™ 10
2	TeamB	As Ks Qs Js Ts"></textarea>
                <div style="margin-top: 15px; text-align: right;">
                    <button onclick="processBulkImport()" class="btn-secondary btn-success" style="padding: 10px 30px;">å¼€å§‹å¯¼å…¥</button>
                </div>
            </div>
        </div>
    </div>

    <div id="calcExportBar" style="display: none;">
        <!-- Deprecated: buttons moved to toolbar -->
    </div>


    <div class="table-responsive">
        <table id="rankingTable">
            <thead>
                <tr>
                    <th>æ’å</th>
                    <th>åºå·</th>
                    <th>é˜Ÿä¼åç§°</th>
                    <th>ç‰Œå‹åç§°</th>
                    <th>ç‰Œé¢</th>
                    <th>ç§¯åˆ†</th>
                    <th>åˆ†æ•°</th>
                    <th>æ“ä½œ</th>
                </tr>
            </thead>
            <tbody>
                <!-- ç»“æœå°†æ’å…¥è¿™é‡Œ -->
            </tbody>
        </table>
    </div> <!-- End table-responsive -->
    </div> <!-- End tab-calc -->

    <!-- Wish Calculation Tab -->
    <div id="tab-wishes" class="tab-content">
        <div class="toolbar" id="wishToolbar">
            <button id="btnWishImport" onclick="openModal('wishImportModal')" class="btn-secondary" style="padding: 8px 20px;">ğŸ“‚ æ‰¹é‡å¯¼å…¥</button>
            <button id="btnWishExport" onclick="exportWishRanking()" class="btn-secondary btn-success" style="padding: 8px 20px;">ğŸ“¤ å¯¼å‡ºæ’è¡Œ</button>
            <button id="btnWishClear" onclick="clearWishData()" class="btn-secondary btn-danger" style="padding: 8px 20px; font-size: 14px;">æ¸…ç©ºæ•°æ®</button>
        </div>

        <!-- Wish Form (Batch Mode) -->
        <div id="wishFormSection" style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; font-size: 16px; color: var(--xmas-green);">å½•å…¥/ç¼–è¾‘å¿ƒæ„¿</h3>
                <button onclick="addWishRow()" class="btn-secondary" style="padding: 5px 15px; font-size: 12px;">+ æ·»åŠ ä¸€è¡Œ</button>
            </div>
            
            <div id="wishRowsContainer">
                <!-- Dynamic Rows -->
            </div>

            <div style="text-align: center; margin-top: 15px;">
                <button id="cancelWishEditBtn" onclick="cancelWishEdit()" style="padding: 8px 25px; background-color: #6c757d; margin-right: 10px; display: none;">å–æ¶ˆç¼–è¾‘</button>
                <button id="saveWishBtn" onclick="saveAllWishes()" style="padding: 8px 25px;">æ‰¹é‡ä¿å­˜</button>
            </div>
        </div>

        <div class="table-responsive">
            <table id="wishRankingTable">
                <thead>
                    <tr>
                        <th>æ’å</th>
                        <th>åºå·</th>
                        <th>é˜Ÿä¼åç§°</th>
                        <th>1é¢—</th>
                        <th>2é¢—</th>
                        <th>3é¢—</th>
                        <th>4é¢—</th>
                        <th>5é¢—</th>
                        <th>å¿ƒæ„¿æ€»è®¡</th>
                        <th>ç§¯åˆ†</th>
                        <th>æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Dynamic Content -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Team Management Tab -->
    <div id="tab-teams" class="tab-content active">
        <div class="toolbar" id="teamToolbar">
            <button id="btnTeamImport" onclick="openModal('teamImportModal')" class="btn-secondary" style="padding: 8px 20px;">ğŸ“‚ æ‰¹é‡å¯¼å…¥</button>
            <button id="btnTeamExport" onclick="exportTeams()" class="btn-secondary btn-success" style="padding: 8px 20px;">ğŸ“¤ å¯¼å‡ºé˜Ÿä¼</button>
            <button id="btnTeamClear" onclick="clearTeamData()" class="btn-secondary btn-danger" style="padding: 8px 20px; font-size: 14px;">æ¸…ç©ºåˆ—è¡¨</button>
        </div>

        <!-- Add Team Form (Batch Mode) -->
        <div id="teamFormSection" style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; font-size: 16px; color: var(--xmas-green);">æ·»åŠ /ç¼–è¾‘é˜Ÿä¼</h3>
                <button onclick="addTeamRow()" class="btn-secondary" style="padding: 5px 15px; font-size: 12px;">+ æ·»åŠ ä¸€è¡Œ</button>
            </div>
            
            <div id="teamRowsContainer">
                <!-- Dynamic Rows -->
            </div>

            <div style="text-align: center; margin-top: 15px;">
                <button id="cancelTeamEditBtn" onclick="cancelTeamEdit()" style="padding: 8px 25px; background-color: #6c757d; margin-right: 10px; display: none;">å–æ¶ˆç¼–è¾‘</button>
                <button id="saveTeamBtn" onclick="saveAllTeams()" style="padding: 8px 25px;">æ‰¹é‡ä¿å­˜</button>
            </div>
        </div>

        <!-- Team List -->
        <div id="teamListContainer">
            <!-- Dynamic Content -->
        </div>
    </div>

</div>
<div id="yearModal" class="modal">
  <div class="modal-content">
    <span class="close-modal" onclick="closeModal('yearModal')">&times;</span>
    <h3 style="margin-top:0; color: var(--xmas-green);">é€‰æ‹©å¹´ä»½</h3>
  <div class="year-modal-body" style="display:flex; gap:10px; align-items:center;">
      <select id="yearSelect" class="search-input" style="width:140px;"></select>
      <input type="password" id="yearPasscode" class="search-input" placeholder="ç®¡ç†å£ä»¤ï¼ˆå¯é€‰ï¼‰" style="width:160px;">
      <button onclick="confirmYearSelection()" style="padding:8px 20px;">ç¡®å®š</button>
      <button id="adminLogoutBtn" onclick="adminLogout()" style="padding:8px 20px; display:none;">ç™»å‡º</button>
  </div>
  </div>
</div>



<!-- Settings Modal -->
<div id="settingsModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal" onclick="closeModal('settingsModal')">&times;</span>
        <h2 style="margin-top: 0; color: var(--xmas-green);">è®¾ç½®</h2>
        
        <div style="margin-top: 20px;">
            <div class="input-group" style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">é˜Ÿä¼æ€»æ•° (ç”¨äºç§¯åˆ†è®¡ç®—):</label>
                <input type="number" id="totalTeamsInput" value="49" onchange="updateTotalTeams()" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <p style="font-size: 12px; color: #666; margin-top: 5px;">é»˜è®¤ä¸º49é˜Ÿã€‚ç¬¬ä¸€åç§¯åˆ† = é˜Ÿä¼æ€»æ•°ï¼Œæœ€åä¸€å1åˆ†ã€‚</p>
            </div>
            
            <hr style="margin: 20px 0; border: 0; border-top: 1px dashed #ccc;">
            
            <h3 style="font-size: 16px; color: var(--xmas-green);">ç¤¼ç‰©æ¡£ä½é…ç½®</h3>
            <div id="giftTiersConfig" style="margin-bottom: 15px;">
                <!-- Generated by JS -->
            </div>
            
            <hr style="margin: 20px 0; border: 0; border-top: 1px dashed #ccc;">
            
            <h3 style="font-size: 16px; color: var(--xmas-green);">ç¤¼ç‰©å›¾ç‰‡ç®¡ç†</h3>
            <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border: 1px dashed #ccc; border-radius: 5px;">
                 <label style="display: block; margin-bottom: 5px; font-weight: bold;">ä¸Šä¼ å‚è€ƒå›¾ç‰‡:</label>
                 <input type="file" id="giftImageInput" accept="image/*" onchange="handleGiftImageUpload(event)" style="width: 100%; margin-bottom: 10px;">
                 <div id="giftImagePreviewContainer" style="display: flex; flex-wrap: wrap; gap: 10px;"></div>
            </div>
        </div>
    </div>
</div>

<!-- Wish Import Modal -->
<div id="wishImportModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeModal('wishImportModal')">&times;</span>
        <h2 style="margin-top: 0; color: var(--xmas-green);">æ‰¹é‡å¯¼å…¥å¿ƒæ„¿ (Excel)</h2>
        
        <div style="margin-top: 20px;">
            <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border: 1px dashed #ccc; border-radius: 5px;">
                <p style="margin: 0 0 10px 0; font-size: 14px; font-weight: bold;">ä¸Šä¼ æ–‡ä»¶å¯¼å…¥:</p>
                <input type="file" id="wishFileInput" accept=".xlsx, .xls" onchange="handleWishFileUpload(event)" style="width: 100%;">
            </div>
            <p style="font-size: 12px; color: #666;">æ”¯æŒæ ¼å¼: åºå· | é˜Ÿä¼åç§° | 1é¢—å¿ƒæ„¿ | 2é¢—å¿ƒæ„¿ | 3é¢—å¿ƒæ„¿ | 4é¢—å¿ƒæ„¿ | 5é¢—å¿ƒæ„¿</p>
        </div>
    </div>
</div>

<!-- Team Import Modal -->
<div id="teamImportModal" class="modal">
    <div class="modal-content">
        <span class="close-modal" onclick="closeModal('teamImportModal')">&times;</span>
        <h2 style="margin-top: 0; color: var(--xmas-green);">æ‰¹é‡å¯¼å…¥é˜Ÿä¼</h2>
        
        <div style="margin-top: 20px;">
            <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border: 1px dashed #ccc; border-radius: 5px;">
                <p style="margin: 0 0 10px 0; font-size: 14px; font-weight: bold;">ä¸Šä¼ æ–‡ä»¶å¯¼å…¥ (Excel):</p>
                <input type="file" id="teamFileInput" accept=".xlsx, .xls" onchange="handleTeamFileUpload(event)" style="width: 100%;">
            </div>
            <p style="font-size: 12px; color: #666;">æ”¯æŒæ ¼å¼: åºå· | é˜Ÿä¼åç§° | æˆå‘˜1 | æˆå‘˜2... | é˜Ÿä¼äººæ•° | é¢„çº¦æ—¶é—´</p>
        </div>
    </div>
</div>


<script>
    const SUPABASE_URL = 'https://ixdgydcuaretfutmsyhz.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml4ZGd5ZGN1YXJldGZ1dG1zeWh6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4NjMwNjQsImV4cCI6MjA4MDQzOTA2NH0.xs37WIBXOQcqKXfa1dK_JT9vyabw6xmz4jaWob7KEOo';
    let supabaseClient = null;
    let currentYear = null;
    let isAdmin = false;
    // ç‰Œé¢å®šä¹‰
    const SUITS = {
        's': 'â™ ', 'S': 'â™ ', 'â™ ': 'â™ ',
        'h': 'â™¥', 'H': 'â™¥', 'â™¥': 'â™¥',
        'c': 'â™£', 'C': 'â™£', 'â™£': 'â™£',
        'd': 'â™¦', 'D': 'â™¦', 'â™¦': 'â™¦'
    };
    
    const RANKS = {
        '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
        'T': 10, 't': 10,
        'J': 11, 'j': 11,
        'Q': 12, 'q': 12,
        'K': 13, 'k': 13,
        'A': 14, 'a': 14
    };

    const RANK_NAMES = {
        2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '10',
        11: 'J', 12: 'Q', 13: 'K', 14: 'A'
    };

    const HAND_TYPES = [
        { name: "é«˜ç‰Œ", value: 1 },
        { name: "å¯¹å­", value: 2 },
        { name: "ä¸¤å¯¹", value: 3 },
        { name: "ä¸‰æ¡", value: 4 },
        { name: "é¡ºå­", value: 5 },
        { name: "åŒèŠ±", value: 6 },
        { name: "è‘«èŠ¦", value: 7 },
        { name: "å››æ¡", value: 8 },
        { name: "åŒèŠ±é¡º", value: 9 },
        { name: "çš‡å®¶åŒèŠ±é¡º", value: 10 }
    ];
    
    // å…¨å±€çŠ¶æ€ï¼šä¿å­˜æ¯ä¸ªä½ç½®é€‰ä¸­çš„ç‰Œ
    // æ ¼å¼: { 1: { suit: 'â™ ', rank: 14, name: 'â™ A' }, ... }
    let selectedCards = {
        1: null, 2: null, 3: null, 4: null, 5: null
    };
    
    let deck = [];
    let totalTeams = 49;
    let wishList = []; // Stores wish data: { serial, team, wishes: [c1,c2,c3,c4,c5], total, points }
    
    // Gift Tiers Default Configuration
    let giftTiers = [
        { min: 1, max: 4, name: "1000æ¡£", color: "#F8BBD0", value: 1000 }, // Pink
        { min: 5, max: 10, name: "800æ¡£", color: "#BBDEFB", value: 800 },  // Blue
        { min: 11, max: 20, name: "600æ¡£", color: "#C8E6C9", value: 600 }, // Green
        { min: 21, max: 44, name: "400æ¡£", color: "#FFF9C4", value: 400 }, // Yellow
        { min: 45, max: 50, name: "200æ¡£", color: "#F5F5F5", value: 200 }  // Gray
    ];
    let giftImages = []; // Array of base64 strings or objects { url: ..., desc: ... }
    let previousRanks = { hand: {}, wish: {}, final: {} }; // Stores previous rankings for change tracking
    let rankBaseline = { name: null, hand: {}, wish: {}, final: {}, timestamp: null }; // Persisted baseline for rank change compare

    function openYearModal() {
        const sel = document.getElementById('yearSelect');
        if (sel.options.length === 0) {
            const now = new Date().getFullYear();
            for (let y = now - 5; y <= now + 1; y++) {
                const opt = document.createElement('option');
                opt.value = y;
                opt.textContent = y;
                sel.appendChild(opt);
            }
            sel.value = String(now);
        }
        // Adjust admin UI in modal
        const passInput = document.getElementById('yearPasscode');
        const logoutBtn = document.getElementById('adminLogoutBtn');
        if (isAdmin) {
            if (passInput) passInput.style.display = 'none';
            if (logoutBtn) logoutBtn.style.display = '';
        } else {
            if (passInput) passInput.style.display = '';
            if (logoutBtn) logoutBtn.style.display = 'none';
        }
        openModal('yearModal');
    }

    async function confirmYearSelection() {
        const y = parseInt(document.getElementById('yearSelect').value);
        if (!y || isNaN(y)) return;
        currentYear = y;
        
        const passInput = document.getElementById('yearPasscode');
        const pass = (passInput && passInput.value) ? passInput.value.trim() : '';
        
        // If already admin and no pass provided, keep admin state
        if (pass.length > 0) {
            if (pass === 'sd502502') {
                isAdmin = true;
                try { localStorage.setItem('isAdmin', 'true'); } catch (e) {}
            } else {
                alert('ç®¡ç†å£ä»¤é”™è¯¯ï¼');
                return;
            }
        } else {
            // Do not change isAdmin if already true
            if (!isAdmin) {
                isAdmin = false;
                try { localStorage.setItem('isAdmin', 'false'); } catch (e) {}
            }
        }

        // Show loader
        const loader = document.getElementById('pageLoader');
        if (loader) {
            loader.style.display = 'flex';
            // Ensure opacity is reset (since init() fades it out)
            requestAnimationFrame(() => {
                loader.style.opacity = '1';
            });
        }

        closeModal('yearModal');
        await initSupabase();
        await loadYearData(y);
        updateHeaderYear();
        updateCalculatorDropdowns();
        renderWishDropdowns();
        updateTable();
        updateFinalRanking();
        applyRoleUI();

        // Hide loader with a small delay
        if (loader) {
            // Fade out effect
            loader.style.opacity = '0';
            setTimeout(() => {
                loader.style.display = 'none';
            }, 500);
        }
    }

    function applyRoleUI() {
        const show = (el) => { if (el) el.style.display = ''; };
        const hide = (el) => { if (el) el.style.display = 'none'; };

        // Toggle Action Columns in static tables
        const rankingTh = document.querySelector('#rankingTable thead th:last-child');
        const wishTh = document.querySelector('#wishRankingTable thead th:last-child');

        if (isAdmin) {
            if (rankingTh) rankingTh.style.display = '';
            if (wishTh) wishTh.style.display = '';

            show(document.getElementById('headerSettingsBtn'));
            show(document.getElementById('btnCalcSettings'));
            show(document.getElementById('btnCalcImport'));
            show(document.getElementById('calcFormSection')); // Show wrapper
            show(document.getElementById('btnClearHandData'));
            show(document.getElementById('btnExportRanking'));

            show(document.getElementById('btnWishSettings'));
            show(document.getElementById('btnWishImport'));
            show(document.getElementById('btnWishClear'));
            show(document.getElementById('wishFormSection'));
            show(document.getElementById('btnWishExport'));

            show(document.getElementById('btnTeamImport'));
            show(document.getElementById('btnTeamClear'));
            show(document.getElementById('teamFormSection'));
            show(document.getElementById('btnTeamExport'));
            show(document.getElementById('tabBtnChanges'));
            show(document.getElementById('btnSaveSnapshot'));
            show(document.getElementById('btnLoadSnapshot'));
            show(document.getElementById('btnFinalExport'));
            show(document.getElementById('btnGiftExport'));
            const passInput = document.getElementById('yearPasscode');
            const logoutBtn = document.getElementById('adminLogoutBtn');
            if (passInput) passInput.style.display = 'none';
            if (logoutBtn) logoutBtn.style.display = '';
        } else {
            if (rankingTh) rankingTh.style.display = 'none';
            if (wishTh) wishTh.style.display = 'none';

            hide(document.getElementById('headerSettingsBtn'));
            hide(document.getElementById('btnCalcSettings'));
            hide(document.getElementById('btnCalcImport'));
            hide(document.getElementById('calcFormSection')); // Hide wrapper
            hide(document.getElementById('btnClearHandData'));
            hide(document.getElementById('btnExportRanking'));

            hide(document.getElementById('btnWishSettings'));
            hide(document.getElementById('btnWishImport'));
            hide(document.getElementById('btnWishClear'));
            hide(document.getElementById('wishFormSection'));
            hide(document.getElementById('btnWishExport'));

            hide(document.getElementById('btnTeamImport'));
            hide(document.getElementById('btnTeamClear'));
            hide(document.getElementById('teamFormSection'));
            hide(document.getElementById('btnTeamExport'));
            hide(document.getElementById('tabBtnChanges'));
            hide(document.getElementById('btnSaveSnapshot'));
            hide(document.getElementById('btnLoadSnapshot'));
            hide(document.getElementById('btnFinalExport'));
            hide(document.getElementById('btnGiftExport'));
            const passInput = document.getElementById('yearPasscode');
            const logoutBtn = document.getElementById('adminLogoutBtn');
            if (passInput) passInput.style.display = '';
            if (logoutBtn) logoutBtn.style.display = 'none';
        }
    }

    function adminLogout() {
        isAdmin = false;
        try { localStorage.setItem('isAdmin','false'); } catch (e) {}
        applyRoleUI();

        // Refresh tables to remove action buttons
        renderTeamList();
        renderWishRanking();
        updateTable();

        closeModal('yearModal');
        alert('å·²é€€å‡ºç®¡ç†å‘˜');
    }

    function updateHeaderYear() {
        const h1 = document.querySelector('h1');
        if (h1 && currentYear) {
            h1.textContent = `${currentYear}å¹´åœ£è¯å¤§å†’é™©ç»Ÿè®¡`;
            document.title = `${currentYear}å¹´åœ£è¯å¤§å†’é™©ç»Ÿè®¡`;
        }
    }

    async function initSupabase() {
        if (!supabaseClient) {
            supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }
    }

    async function loadYearData(year) {
        if (!supabaseClient) return;

        // Reset settings to defaults to prevent data carry-over from previous year
        totalTeams = 49;
        giftTiers = [
            { min: 1, max: 4, name: "1000æ¡£", color: "#F8BBD0", value: 1000 },
            { min: 5, max: 10, name: "800æ¡£", color: "#BBDEFB", value: 800 },
            { min: 11, max: 20, name: "600æ¡£", color: "#C8E6C9", value: 600 },
            { min: 21, max: 44, name: "400æ¡£", color: "#FFF9C4", value: 400 },
            { min: 45, max: 50, name: "200æ¡£", color: "#F5F5F5", value: 200 }
        ];
        giftImages = [];
        rankBaseline = { name: null, hand: {}, wish: {}, final: {}, timestamp: null };

        const { data: teams } = await supabaseClient.from('teams').select('*').eq('year', year).order('sort_key', { ascending: true });
        const { data: wishes } = await supabaseClient.from('wishes').select('*').eq('year', year);
        const { data: hands } = await supabaseClient.from('hands').select('*').eq('year', year);
        
        // Load Settings (Tiers & Images)
        const { data: settings } = await supabaseClient.from('settings').select('*').eq('year', year);
        if (settings) {
            const tiersSetting = settings.find(s => s.key === 'gift_tiers');
            if (tiersSetting) giftTiers = tiersSetting.value;
            
            const imagesSetting = settings.find(s => s.key === 'gift_images');
            if (imagesSetting) giftImages = imagesSetting.value;

            const baselineSetting = settings.find(s => s.key === 'rank_baseline');
            if (baselineSetting && baselineSetting.value) {
                rankBaseline = baselineSetting.value;
            }

            const totalTeamsSetting = settings.find(s => s.key === 'total_teams');
            if (totalTeamsSetting && totalTeamsSetting.value) {
                totalTeams = parseInt(totalTeamsSetting.value) || totalTeams;
            }
        }

        teamList = (teams || []).map(t => ({ 
            id: `${year}-${t.serial}`, 
            serial: String(t.serial), 
            name: t.name, 
            members: t.members || [], 
            count: t.count || 0, 
            time: t.time || '', 
            sortKey: t.sort_key || 0,
            gifts: t.gifts || {} // Load gifts
        }));
        wishList = (wishes || []).map(w => ({ serial: String(w.serial), team: w.team_name || '', wishes: Array.isArray(w.wishes) ? w.wishes : (w.wishes ? Object.values(w.wishes) : [0,0,0,0,0]), total: w.total || 0 }));
        handHistory = (hands || []).map(h => ({ id: `${year}-${h.serial}`, serial: String(h.serial), team: h.team_name || '', handTypeName: h.hand_type_name || '', cards: Array.isArray(h.cards) ? h.cards : [], score: h.hand_raw_score || 0 }));
        
        renderTeamList();
        renderWishRanking();
        handHistory.sort((a, b) => b.score - a.score);
        updateTable();
        
        // Update UI components that depend on data
        renderGiftTiersConfig();
        renderGiftTierLegend();
        renderGiftImagesPreview();
        
        // Refresh active tab content if necessary
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab) {
            if (activeTab.id === 'tab-gifts') {
                renderGiftSelection();
            } else if (activeTab.id === 'tab-final') {
                updateFinalRanking();
            }
        }

        // Initialize ranks snapshot for change tracking
        snapshotRanks();
        isInitialLoad = false;
    }

    async function upsertTeams(rows) {
        if (!supabaseClient || !currentYear) return;
        const payload = rows.map(t => ({ 
            year: currentYear, 
            serial: String(t.serial), 
            name: t.name, 
            members: t.members, 
            count: t.count, 
            time: t.time, 
            sort_key: t.sortKey,
            gifts: t.gifts // Persist gifts
        }));
        await supabaseClient.from('teams').upsert(payload, { onConflict: 'year,serial' });
    }

    async function deleteTeamInCloud(serial) {
        if (!supabaseClient || !currentYear) return;
        await supabaseClient.from('teams').delete().eq('year', currentYear).eq('serial', String(serial));
    }

    async function upsertWishes(rows) {
        if (!supabaseClient || !currentYear) return;
        const payload = rows.map(w => ({ year: currentYear, serial: String(w.serial), team_name: w.team, wishes: w.wishes, total: w.total }));
        await supabaseClient.from('wishes').upsert(payload, { onConflict: 'year,serial' });
    }

    async function deleteWishInCloud(serial) {
        if (!supabaseClient || !currentYear) return;
        await supabaseClient.from('wishes').delete().eq('year', currentYear).eq('serial', String(serial));
    }

    async function upsertHands(rows) {
        if (!supabaseClient || !currentYear) return;
        const payload = rows.map(h => ({ year: currentYear, serial: String(h.serial), team_name: h.team, hand_type_name: h.handTypeName, cards: h.cards, hand_points: 0, hand_raw_score: h.score }));
        await supabaseClient.from('hands').upsert(payload, { onConflict: 'year,serial' });
    }

    async function deleteHandsInCloud(serial) {
        if (!supabaseClient || !currentYear) return;
        await supabaseClient.from('hands').delete().eq('year', currentYear).eq('serial', String(serial));
    }

    async function upsertFinalRanking(rows) {
        if (!supabaseClient || !currentYear) return;
        const payload = rows.map(r => ({ year: currentYear, serial: String(r.serial), team_name: r.team, members: r.members ? r.members.split(',').map(m => m.trim()).filter(Boolean) : [], wish_total: r.wishTotal, wish_points: r.wishPoints, hand_type_name: r.handTypeName, hand_cards: r.handCards, hand_points: r.handPoints, hand_raw_score: r.handRawScore, final_score: r.finalScore, rank: r.rank }));
        await supabaseClient.from('final_rankings').upsert(payload, { onConflict: 'year,serial' });
    }

    // --- Snapshot Helpers ---
    function generateDefaultSnapshotName() {
        const d = new Date();
        const pad = (n) => String(n).padStart(2,'0');
        return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
    }

    async function openSnapshotModal(mode) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        document.getElementById('snapshotModeSave').style.display = mode === 'save' ? 'block' : 'none';
        document.getElementById('snapshotModeLoad').style.display = mode === 'load' ? 'block' : 'none';
        const input = document.getElementById('snapshotNameInput');
        if (mode === 'save' && input) input.value = generateDefaultSnapshotName();
        openModal('snapshotModal');
        if (mode === 'load') await refreshSnapshotList();
    }

    async function saveDataSnapshot() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if (!supabaseClient || !currentYear) { alert('æœåŠ¡å™¨æœªåˆå§‹åŒ–'); return; }
        const name = (document.getElementById('snapshotNameInput').value || '').trim() || generateDefaultSnapshotName();
        const key = `data_snapshot:${name}`;
        const payload = {
            year: currentYear,
            totalTeams,
            teams: teamList,
            wishes: wishList,
            hands: handHistory,
            giftTiers,
            giftImages
        };
        try {
            await supabaseClient.from('settings').upsert({ year: currentYear, key, value: payload }, { onConflict: 'year,key' });
            alert(`å¿«ç…§ä¿å­˜æˆåŠŸï¼š${name}`);
            closeModal('snapshotModal');
        } catch (e) {
            alert('ä¿å­˜å¤±è´¥ï¼š' + e.message);
        }
    }

    async function refreshSnapshotList() {
        const container = document.getElementById('snapshotListContainer');
        if (!container) return;
        container.innerHTML = '<div style="color:#888;">åŠ è½½ä¸­...</div>';
        try {
            const { data } = await supabaseClient.from('settings').select('*').eq('year', currentYear).ilike('key', 'data_snapshot:%');
            renderSnapshotList(data || []);
        } catch (e) {
            container.innerHTML = '<div style="color:red;">åŠ è½½å¤±è´¥</div>';
        }
    }

    function renderSnapshotList(rows) {
        const container = document.getElementById('snapshotListContainer');
        container.innerHTML = '';
        if (!rows || rows.length === 0) {
            container.innerHTML = '<div style="color:#888;">æš‚æ— å¿«ç…§</div>';
            return;
        }
        rows.sort((a,b) => String(b.key).localeCompare(String(a.key)));
        rows.forEach(r => {
            const wrap = document.createElement('div');
            wrap.style.display = 'flex';
            wrap.style.justifyContent = 'space-between';
            wrap.style.alignItems = 'center';
            wrap.style.padding = '6px 8px';
            wrap.style.borderBottom = '1px solid #eee';
            const name = String(r.key).replace('data_snapshot:','');
            wrap.innerHTML = `
                <div>
                    <strong>${name}</strong>
                </div>
                <div>
                    <button class="btn-secondary" style="padding:4px 10px; font-size:12px; margin-right:6px;" onclick="compareSnapshot('${name}')">å¯¹æ¯”</button>
                    <button class="btn-secondary" style="padding:4px 10px; font-size:12px;" onclick="applySnapshot('${name}')">åº”ç”¨</button>
                    <button class="btn-secondary" style="padding:4px 10px; font-size:12px; margin-left:6px;" onclick="exportSnapshot('${name}')">å¯¼å‡º</button>
                </div>
            `;
            container.appendChild(wrap);
        });
    }

    async function applySnapshot(name) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if (!supabaseClient || !currentYear) return;
        if (!confirm(`ç¡®å®šè¦åŠ è½½å¿«ç…§ "${name}" å¹¶è¦†ç›–å½“å‰é¡µé¢æ•°æ®å—ï¼Ÿ`)) return;
        if (!confirm('äºŒæ¬¡ç¡®è®¤ï¼šæ­¤æ“ä½œå°†è¦†ç›–å½“å‰æ˜¾ç¤ºçš„æ•°æ®å¹¶åŒæ­¥åˆ°æœåŠ¡å™¨ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ')) return;
        try {
            const { data } = await supabaseClient.from('settings').select('*').eq('year', currentYear).eq('key', `data_snapshot:${name}`).limit(1);
            if (!data || data.length === 0) { alert('æœªæ‰¾åˆ°å¿«ç…§'); return; }
            const snap = data[0].value || {};
            // Replace in-memory
            totalTeams = snap.totalTeams || totalTeams;
            teamList = Array.isArray(snap.teams) ? snap.teams : [];
            wishList = Array.isArray(snap.wishes) ? snap.wishes : [];
            handHistory = Array.isArray(snap.hands) ? snap.hands : [];
            giftTiers = Array.isArray(snap.giftTiers) ? snap.giftTiers : giftTiers;
            giftImages = Array.isArray(snap.giftImages) ? snap.giftImages : giftImages;

            // Replace server tables for current year
            await supabaseClient.from('teams').delete().eq('year', currentYear);
            await supabaseClient.from('wishes').delete().eq('year', currentYear);
            await supabaseClient.from('hands').delete().eq('year', currentYear);
            await upsertTeams(teamList);
            await upsertWishes(wishList);
            await upsertHands(handHistory);
            await saveAppSettings(); // persist giftTiers & giftImages

            // Re-render UI
            renderTeamList();
            renderWishRanking();
            handHistory.sort((a,b)=>b.score-a.score);
            updateTable();
            updateHeaderYear();
            updateCalculatorDropdowns();
            renderGiftTiersConfig();
            renderGiftTierLegend();
            renderGiftImagesPreview();
            await supabaseClient.from('settings').upsert({ year: currentYear, key: 'rank_baseline', value: { name: null, hand: {}, wish: {}, final: {}, timestamp: new Date().toISOString() } }, { onConflict: 'year,key' });
            rankBaseline = { name: null, hand: {}, wish: {}, final: {}, timestamp: new Date().toISOString() };
            alert('å¿«ç…§å·²åº”ç”¨å¹¶ä¿å­˜åˆ°æœåŠ¡å™¨');
            closeModal('snapshotModal');
            setTimeout(() => { location.reload(); }, 500);
        } catch (e) {
            alert('åº”ç”¨å¿«ç…§å¤±è´¥ï¼š' + e.message);
        }
    }

    async function compareSnapshot(name) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if (!supabaseClient || !currentYear) return;
        try {
            const { data } = await supabaseClient.from('settings').select('*').eq('year', currentYear).eq('key', `data_snapshot:${name}`).limit(1);
            if (!data || data.length === 0) { alert('æœªæ‰¾åˆ°å¿«ç…§'); return; }
            const snap = data[0].value || {};
            const tt = snap.totalTeams || totalTeams || 50;
            
            // Wish ranks
            const wishRanks = {};
            const wishSorted = Array.isArray(snap.wishes) ? [...snap.wishes].sort((a,b)=> (b.total||0) - (a.total||0)) : [];
            let r = 1;
            wishSorted.forEach((w,i)=>{
                if (i>0 && (w.total||0) === (wishSorted[i-1].total||0)) { /* tie */ } else { r = i+1; }
                wishRanks[String(w.serial)] = r;
            });
            
            // Hand ranks
            const handRanks = {};
            const handSorted = Array.isArray(snap.hands) ? [...snap.hands].sort((a,b)=> (b.score||0) - (a.score||0)) : [];
            r = 1;
            handSorted.forEach((h,i)=>{
                if (i>0 && (h.score||0) === (handSorted[i-1].score||0)) { } else { r = i+1; }
                handRanks[String(h.serial)] = r;
            });
            
            // Final ranks from points (wishPoints + handPoints)
            const serials = new Set([...Object.keys(wishRanks), ...Object.keys(handRanks)]);
            const finals = [];
            serials.forEach(s=>{
                const wr = wishRanks[s];
                const hr = handRanks[s];
                const wishPoints = wr ? (tt - wr + 1) : 0;
                const handPoints = hr ? (tt - hr + 1) : 0;
                finals.push({ serial: s, score: wishPoints + handPoints });
            });
            finals.sort((a,b)=> b.score - a.score);
            const finalRanks = {};
            r = 1;
            finals.forEach((f,i)=>{
                if (i>0 && f.score === finals[i-1].score) { } else { r = i+1; }
                finalRanks[f.serial] = r;
            });
            
            // Persist baseline
            const baselineValue = { name, hand: handRanks, wish: wishRanks, final: finalRanks, timestamp: new Date().toISOString() };
            await supabaseClient.from('settings').upsert({ year: currentYear, key: 'rank_baseline', value: baselineValue }, { onConflict: 'year,key' });
            rankBaseline = baselineValue;
            
            // Re-render UI with new baseline
            renderTeamList();
            renderWishRanking();
            updateTable();
            alert(`å·²è®¾ç½®å¿«ç…§ "${name}" ä¸ºæ’åå¯¹æ¯”åŸºçº¿`);
            setTimeout(() => { location.reload(); }, 500);
        } catch (e) {
            alert('å¯¹æ¯”å¤±è´¥ï¼š' + e.message);
        }
    }

    async function exportSnapshot(name) {
        if (!supabaseClient || !currentYear) { alert('æœåŠ¡å™¨æœªåˆå§‹åŒ–'); return; }
        try {
            const { data } = await supabaseClient.from('settings').select('*').eq('year', currentYear).eq('key', `data_snapshot:${name}`).limit(1);
            if (!data || data.length === 0) { alert('æœªæ‰¾åˆ°å¿«ç…§'); return; }
            const snap = data[0].value || {};
            
            const wb = XLSX.utils.book_new();
            
            // Teams
            const teams = Array.isArray(snap.teams) ? snap.teams : [];
            const teamsRows = teams.map(t => ({
                åºå·: t.serial,
                é˜Ÿä¼åç§°: (typeof t.name === 'string') ? (t.name.startsWith('data:image') ? '[å›¾ç‰‡é˜Ÿä¼]' : t.name) : '',
                æˆå‘˜: Array.isArray(t.members) ? t.members.join(', ') : '',
                äººæ•°: t.count || 0,
                é¢„çº¦æ—¶é—´: t.time || '',
                æ’åºé”®: t.sortKey || 0
            }));
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(teamsRows), 'Teams');
            
            // Wishes
            const wishes = Array.isArray(snap.wishes) ? snap.wishes : [];
            const wishesRows = wishes.map(w => ({
                åºå·: w.serial,
                é˜Ÿä¼åç§°: (typeof w.team === 'string') ? (w.team.startsWith('data:image') ? '[å›¾ç‰‡é˜Ÿä¼]' : w.team) : '',
                å¿ƒæ„¿1: (w.wishes && w.wishes[0]) || 0,
                å¿ƒæ„¿2: (w.wishes && w.wishes[1]) || 0,
                å¿ƒæ„¿3: (w.wishes && w.wishes[2]) || 0,
                å¿ƒæ„¿4: (w.wishes && w.wishes[3]) || 0,
                å¿ƒæ„¿5: (w.wishes && w.wishes[4]) || 0,
                æ€»è®¡: w.total || 0
            }));
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(wishesRows), 'Wishes');
            
            // Hands
            const hands = Array.isArray(snap.hands) ? snap.hands : [];
            const handsRows = hands.map(h => {
                let cardsStr = '';
                const cards = Array.isArray(h.cards) ? h.cards : [];
                cardsStr = cards.map(c => {
                    if (c && typeof c === 'object' && c.suit && c.rankLabel) return `${c.suit}${c.rankLabel}`;
                    if (typeof c === 'string') return c;
                    return '';
                }).filter(Boolean).join(' ');
                return {
                    åºå·: h.serial,
                    é˜Ÿä¼åç§°: (typeof h.team === 'string') ? (h.team.startsWith('data:image') ? '[å›¾ç‰‡é˜Ÿä¼]' : h.team) : '',
                    ç‰Œå‹åç§°: h.handTypeName || '',
                    ç‰Œé¢: cardsStr,
                    åˆ†æ•°: h.score || 0
                };
            });
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(handsRows), 'Hands');
            
            // Gift Tiers
            const tiers = Array.isArray(snap.giftTiers) ? snap.giftTiers : [];
            const tierRows = tiers.map(t => ({ åç§°: t.name, Min: t.min, Max: t.max, é¢œè‰²: t.color, å€¼: t.value }));
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(tierRows), 'GiftTiers');
            
            // Gift Images (meta)
            const images = Array.isArray(snap.giftImages) ? snap.giftImages : [];
            const imageRows = images.map(i => {
                let urlVal = i.url || '';
                // Excel cell limit is 32767 characters. If base64 is too long, truncate/replace it.
                if (urlVal.length > 32000) {
                    urlVal = '[å›¾ç‰‡æ•°æ®è¿‡é•¿ï¼Œæ— æ³•å¯¼å‡ºåˆ°Excel]';
                }
                return { æè¿°: i.desc || '', URLæˆ–Base64: urlVal };
            });
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(imageRows), 'GiftImages');
            
            // --- Gift Selection (Calculated) ---
            const tt = snap.totalTeams || 0;
            
            // 1. Wish Ranks
            const wishRanks = {};
            const wishSorted = Array.isArray(snap.wishes) ? [...snap.wishes].sort((a,b)=> (b.total||0) - (a.total||0)) : [];
            let rWish = 1;
            wishSorted.forEach((w,i)=>{
                if (i>0 && (w.total||0) === (wishSorted[i-1].total||0)) { /* tie */ } else { rWish = i+1; }
                wishRanks[String(w.serial)] = rWish;
            });
            
            // 2. Hand Ranks
            const handRanks = {};
            const handSorted = Array.isArray(snap.hands) ? [...snap.hands].sort((a,b)=> (b.score||0) - (a.score||0)) : [];
            let rHand = 1;
            handSorted.forEach((h,i)=>{
                if (i>0 && (h.score||0) === (handSorted[i-1].score||0)) { } else { rHand = i+1; }
                handRanks[String(h.serial)] = rHand;
            });
            
            // 3. Final Ranks
            const allSerials = new Set();
            // Only consider teams that have both wish and hand data (same rule as main logic)
            Object.keys(wishRanks).forEach(s => {
                if (handRanks[s]) allSerials.add(s);
            });

            const finals = [];
            allSerials.forEach(s => {
                const wr = wishRanks[s];
                const hr = handRanks[s];
                const wishPoints = tt - wr + 1;
                const handPoints = tt - hr + 1;
                finals.push({ serial: s, score: wishPoints + handPoints });
            });
            
            finals.sort((a,b)=> b.score - a.score);
            
            // 4. Build Gift Selection Data
            const giftSelectionRows = [];
            let rFinal = 1;
            finals.forEach((f, i) => {
                if (i>0 && f.score === finals[i-1].score) { } else { rFinal = i+1; }
                const rank = rFinal;
                
                const team = Array.isArray(snap.teams) ? snap.teams.find(t => String(t.serial) === String(f.serial)) : null;
                if (!team) return;
                
                // Find Tier
                const tiers = Array.isArray(snap.giftTiers) ? snap.giftTiers : [];
                const tier = tiers.find(t => rank >= t.min && rank <= t.max);
                const tierName = tier ? tier.name : '-';
                
                const teamName = (typeof team.name === 'string') ? (team.name.startsWith('data:image') ? '[å›¾ç‰‡é˜Ÿä¼]' : team.name) : '';
                const members = Array.isArray(team.members) ? team.members : [];
                const gifts = team.gifts || {};
                
                if (members.length > 0) {
                    members.forEach(member => {
                        const g = gifts[member] || {};
                        const giftId = g.id ? String(g.id) : '';
                        const remark = g.remark ? String(g.remark) : '';
                        giftSelectionRows.push({
                            "æœ€ç»ˆæ’å": rank,
                            "ç¤¼ç‰©æ¡£ä½": tierName,
                            "é˜Ÿä¼åç§°": teamName,
                            "æˆå‘˜åç§°": member,
                            "ç¤¼ç‰©é€‰æ‹©": giftId,
                            "å¤‡æ³¨": remark
                        });
                    });
                } else {
                     giftSelectionRows.push({
                        "æœ€ç»ˆæ’å": rank,
                        "ç¤¼ç‰©æ¡£ä½": tierName,
                        "é˜Ÿä¼åç§°": teamName,
                        "æˆå‘˜åç§°": "æ— æˆå‘˜ä¿¡æ¯",
                        "ç¤¼ç‰©é€‰æ‹©": "",
                        "å¤‡æ³¨": ""
                    });
                }
            });
            
            const wsGift = XLSX.utils.json_to_sheet(giftSelectionRows);
            wsGift['!cols'] = [
                { wch: 8 },  // æœ€ç»ˆæ’å
                { wch: 10 }, // ç¤¼ç‰©æ¡£ä½
                { wch: 20 }, // é˜Ÿä¼åç§°
                { wch: 15 }, // æˆå‘˜åç§°
                { wch: 15 }, // ç¤¼ç‰©é€‰æ‹©
                { wch: 20 }  // å¤‡æ³¨
            ];
            XLSX.utils.book_append_sheet(wb, wsGift, 'GiftSelection');

            // Settings
            const settingsRows = [{ å¹´ä»½: snap.year || currentYear, é˜Ÿä¼æ€»æ•°: snap.totalTeams || 0, å¿«ç…§å: name, å¯¼å‡ºæ—¶é—´: new Date().toLocaleString() }];
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(settingsRows), 'Settings');
            
            const filename = `å¿«ç…§_${name}.xlsx`;
            XLSX.writeFile(wb, filename);
        } catch (e) {
            alert('å¯¼å‡ºå¤±è´¥ï¼š' + e.message);
        }
    }

    function updateTotalTeams() {
        const input = document.getElementById('totalTeamsInput');
        const val = parseInt(input.value);
        if (!isNaN(val) && val > 0) {
            totalTeams = val;
            updateTable();
            renderWishRanking(); // Also update wish ranking
            if (isAdmin) { saveAppSettings(); }
        }
    }

    // Tab Switching
    function switchTab(tabId) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
        
        document.getElementById('tab-' + tabId).classList.add('active');
        // Find button
        const btns = document.querySelectorAll('.tab-btn');
        if (tabId === 'teams') {
            btns[0].classList.add('active');
        }
        if (tabId === 'calc') {
            btns[1].classList.add('active');
            updateCalculatorDropdowns();
        }
        if (tabId === 'wishes') {
            btns[2].classList.add('active');
            renderWishDropdowns();
        }
        if (tabId === 'final') {
            btns[3].classList.add('active');
            updateFinalRanking();
        }
        if (tabId === 'gifts') {
            btns[4].classList.add('active');
            renderGiftSelection();
        }
        if (tabId === 'changes') {
            const idx = 5;
            btns[idx].classList.add('active');
            renderRankChangeTab();
        }
    }

    function getFinalRankingData() {
        // 1. Ensure Wish Points are up to date
        // Note: We don't call renderWishRanking() here to avoid side effects (DOM updates) if just exporting.
        // But we need the points. wishList entries have points if renderWishRanking ran.
        // To be safe, we can force update wishList points without rendering? 
        // Actually, let's just recalculate points locally to be purely functional.
        
        // Calculate Wish Points
        // Sort a copy to avoid mutating global wishList unexpectedly if that matters (though usually we want them synced)
        const sortedWishes = [...wishList].sort((a, b) => b.total - a.total);
        const wishPointsMap = {};
        let wishRank = 1;
        sortedWishes.forEach((entry, index) => {
            if (index > 0 && entry.total === sortedWishes[index-1].total) {
                // Tie
            } else {
                wishRank = index + 1;
            }
            const points = totalTeams - wishRank + 1;
            wishPointsMap[entry.serial] = {
                points: points,
                total: entry.total,
                team: entry.team
            };
        });

        // Calculate Hand Points
        const sortedHands = [...handHistory].sort((a, b) => b.score - a.score);
        const handPointsMap = {};
        let handRank = 1;
        sortedHands.forEach((entry, index) => {
            if (index > 0 && entry.score === sortedHands[index-1].score) {
                // Tie
            } else {
                handRank = index + 1;
            }
            const points = totalTeams - handRank + 1;
            handPointsMap[entry.serial] = {
                points: points,
                handTypeName: entry.handTypeName,
                cards: entry.cards,
                team: entry.team,
                score: entry.score // Include raw score for tie-breaking
            };
        });

        // Aggregate
        const allSerials = new Set();
        teamList.forEach(t => allSerials.add(t.serial));
        wishList.forEach(w => allSerials.add(w.serial));
        handHistory.forEach(h => allSerials.add(h.serial));

        const ranking = [];

        allSerials.forEach(serial => {
            const teamEntry = teamList.find(t => t.serial === serial);
            const wishData = wishPointsMap[serial];
            const handData = handPointsMap[serial];

            // åªæœ‰å½“â€œæ‰‘å…‹æ‰‹ç‰Œæ¦œâ€å’Œâ€œå¿ƒæ„¿æ¦œâ€éƒ½æœ‰æ•°æ®æ—¶æ‰è®¡å…¥
            if (!wishData || !handData) {
                return;
            }

            // Name resolution
            let teamName = "æœªçŸ¥é˜Ÿä¼";
            if (teamEntry) teamName = teamEntry.name;
            else if (handData) teamName = handData.team;
            else if (wishData) teamName = wishData.team;

            const members = teamEntry ? teamEntry.members.join(', ') : "";
            const wishTotal = wishData ? wishData.total : 0;
            const wishPoints = wishData ? wishData.points : 0; // 0 points if not in wish list
            
            const handTypeName = handData ? handData.handTypeName : "-";
            const handCards = handData ? handData.cards : [];
            const handPoints = handData ? handData.points : 0;
            const handRawScore = handData ? handData.score : 0;

            const finalScore = wishPoints + handPoints;

            ranking.push({
                serial: serial,
                team: teamName,
                members: members,
                wishTotal: wishTotal,
                wishPoints: wishPoints,
                handTypeName: handTypeName,
                handCards: handCards,
                handPoints: handPoints,
                handRawScore: handRawScore,
                finalScore: finalScore
            });
        });

        // Sort by Final Score, then by Hand Raw Score
        ranking.sort((a, b) => {
            if (b.finalScore !== a.finalScore) {
                return b.finalScore - a.finalScore;
            }
            // Tie-breaker: Hand Strength
            return b.handRawScore - a.handRawScore;
        });
        
        // Assign Final Ranks
        let finalRank = 1;
        ranking.forEach((item, index) => {
            // Check for tie in both Final Score AND Hand Raw Score
            if (index > 0 && 
                item.finalScore === ranking[index-1].finalScore && 
                item.handRawScore === ranking[index-1].handRawScore) {
                // Tie
            } else {
                finalRank = index + 1;
            }
            item.rank = finalRank;
        });

        return ranking;
    }

    // Hand Type Filter Logic
    let selectedHandTypes = [];

    function initHandTypeFilter() {
        const container = document.getElementById('handTypeList');
        if (!container) return;
        container.innerHTML = '';
        
        HAND_TYPES.forEach(type => {
            const div = document.createElement('div');
            div.style.padding = '8px';
            div.style.borderBottom = '1px solid #f5f5f5';
            
            div.innerHTML = `
                <label style="cursor: pointer; display: flex; align-items: center; width: 100%; margin: 0;">
                    <input type="checkbox" value="${type.name}" onchange="updateHandTypeSelection()" style="margin-right: 8px;"> 
                    ${type.name}
                </label>
            `;
            container.appendChild(div);
        });
    }

    function toggleHandTypeDropdown() {
        const dropdown = document.getElementById('handTypeDropdown');
        const current = dropdown.style.display;
        
        // Close card dropdowns (remove .show class)
        if (typeof closeAllDropdowns === 'function') {
            closeAllDropdowns();
        }
        
        // Clear inline display style from other dropdowns (fix for potential conflicts)
        document.querySelectorAll('.dropdown-menu').forEach(d => {
            if (d !== dropdown) d.style.display = ''; 
        });

        // Toggle current
        dropdown.style.display = (current === 'block') ? 'none' : 'block';
        
        if (dropdown.style.display === 'block') {
            setTimeout(() => {
                document.addEventListener('click', closeHandTypeDropdownOutside);
            }, 0);
        }
    }

    function closeHandTypeDropdownOutside(e) {
        const dropdown = document.getElementById('handTypeDropdown');
        const btn = document.getElementById('handTypeDropdownBtn');
        if (dropdown && !dropdown.contains(e.target) && !btn.contains(e.target)) {
            dropdown.style.display = 'none';
            document.removeEventListener('click', closeHandTypeDropdownOutside);
        }
    }

    function updateHandTypeSelection() {
        const checkboxes = document.querySelectorAll('#handTypeList input[type="checkbox"]');
        selectedHandTypes = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
        
        const btn = document.getElementById('handTypeDropdownBtn');
        const span = btn.querySelector('span');
        
        if (selectedHandTypes.length === 0) {
            span.textContent = 'é€‰æ‹©ç‰Œå‹';
            btn.style.borderColor = '#ccc';
            btn.style.background = 'white';
            btn.style.color = '#333';
        } else if (selectedHandTypes.length === HAND_TYPES.length) {
            span.textContent = 'å…¨éƒ¨ç‰Œå‹';
            btn.style.borderColor = '#165B33';
            btn.style.background = '#e8f5e9';
            btn.style.color = '#165B33';
        } else {
            span.textContent = `å·²é€‰ ${selectedHandTypes.length} é¡¹`;
            btn.style.borderColor = '#165B33';
            btn.style.background = '#e8f5e9';
            btn.style.color = '#165B33';
        }
        
        // Check/Uncheck "Select All" based on selection
        const allCb = document.querySelector('#handTypeDropdown input[onclick*="toggleAllHandTypes"]');
        if (allCb) {
             allCb.checked = (checkboxes.length > 0 && selectedHandTypes.length === checkboxes.length);
        }

        updateFinalRanking();
    }

    function toggleAllHandTypes(source) {
        const checkboxes = document.querySelectorAll('#handTypeList input[type="checkbox"]');
        checkboxes.forEach(cb => cb.checked = source.checked);
        updateHandTypeSelection();
    }

    function filterFinalRanking(data) {
        const sSerial = document.getElementById('searchSerial').value.trim().toLowerCase();
        const sTeam = document.getElementById('searchTeam').value.trim().toLowerCase();
        const sMembers = document.getElementById('searchMembers').value.trim().toLowerCase();
        const sWishMin = parseFloat(document.getElementById('searchWishMin').value);
        const sWishMax = parseFloat(document.getElementById('searchWishMax').value);
        
        return data.filter(item => {
            // Serial: Exact match (if provided)
            if (sSerial && String(item.serial).toLowerCase() !== sSerial) return false;

            // Team Name: Fuzzy match
            if (sTeam && !String(item.team).toLowerCase().includes(sTeam)) return false;

            // Members: Fuzzy match
            if (sMembers && !String(item.members).toLowerCase().includes(sMembers)) return false;

            // Wish Score Range
            if (!isNaN(sWishMin) && item.wishTotal < sWishMin) return false;
            if (!isNaN(sWishMax) && item.wishTotal > sWishMax) return false;

            // Hand Type: Multi-select
            if (selectedHandTypes.length > 0 && !selectedHandTypes.includes(item.handTypeName)) return false;

            return true;
        });
    }

    function clearFinalSearch() {
        document.getElementById('searchSerial').value = '';
        document.getElementById('searchTeam').value = '';
        document.getElementById('searchMembers').value = '';
        document.getElementById('searchWishMin').value = '';
        document.getElementById('searchWishMax').value = '';
        
        // Reset Hand Type Filter
        const checkboxes = document.querySelectorAll('#handTypeList input[type="checkbox"]');
        checkboxes.forEach(cb => cb.checked = false);
        const allCb = document.querySelector('#handTypeDropdown input[onclick*="toggleAllHandTypes"]');
        if (allCb) allCb.checked = false;
        
        updateHandTypeSelection();
    }

    function updateFinalRanking() {
        const data = getFinalRankingData();
        const filteredData = filterFinalRanking(data);
        const tbody = document.querySelector('#finalRankingTable tbody');
        const thead = document.querySelector('#finalRankingTable thead tr');
        
        // Ensure "Gift Tier" header exists
        if (!thead.querySelector('.th-gift-tier')) {
            const th = document.createElement('th');
            th.className = 'th-gift-tier';
            th.textContent = 'ç¤¼ç‰©æ¡£ä½';
            // Insert after Rank (1st column)
            thead.insertBefore(th, thead.children[1]);
        }
        
        tbody.innerHTML = '';

        filteredData.forEach(item => {
            const tr = document.createElement('tr');
            
            // Determine Gift Tier based on Rank
            const tier = giftTiers.find(t => item.rank >= t.min && item.rank <= t.max);
            const tierName = tier ? tier.name : "-";
            const tierColor = tier ? tier.color : "";
            
            if (tierColor) {
                tr.style.backgroundColor = tierColor;
            }
            
            // æœ€ç»ˆæ’å
            tr.innerHTML += `<td>${item.rank}${getRankChangeHtml(item.serial, item.rank, 'final')}</td>`;
            
            // ç¤¼ç‰©æ¡£ä½
            tr.innerHTML += `<td>${tierName}</td>`;
            
            // åºå·
            tr.innerHTML += `<td>${item.serial}</td>`;
            // é˜Ÿä¼åç§°
            const nameDisplay = isImage(item.team) ? `<img src="${item.team}" style="height:30px; vertical-align:middle;">` : item.team;
            tr.innerHTML += `<td>${nameDisplay}</td>`;
            // æˆå‘˜
            tr.innerHTML += `<td>${item.members}</td>`;
            // å¿ƒæ„¿æ€»è®¡
            tr.innerHTML += `<td>${item.wishTotal}</td>`;
            // å¿ƒæ„¿ç§¯åˆ†
            tr.innerHTML += `<td>${item.wishPoints}</td>`;
            // ç‰Œå‹åç§°
            tr.innerHTML += `<td>${item.handTypeName}</td>`;
            // ç‰Œé¢
            const cardTd = document.createElement('td');
            if (item.handCards.length > 0) {
                 item.handCards.forEach(c => {
                     const s = document.createElement('span');
                     s.className = `card ${c.color === 'red' ? 'suit-red' : 'suit-black'}`;
                     s.textContent = `${c.suit}${c.rankLabel}`;
                     cardTd.appendChild(s);
                 });
            } else {
                cardTd.textContent = "-";
            }
            tr.appendChild(cardTd);
            
            // ç‰Œå‹ç§¯åˆ†
            tr.innerHTML += `<td>${item.handPoints}</td>`;
            // æœ€ç»ˆåˆ†æ•°
            tr.innerHTML += `<td style="font-weight:bold; color:#d9534f; font-size:1.1em;">${item.finalScore}</td>`;
            
            tbody.appendChild(tr);
        });
    }

    function exportFinalRanking() {
        const data = getFinalRankingData();
        if (data.length === 0) {
            alert('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
            return;
        }

        const exportData = data.map(item => {
            const cardStr = item.handCards.map(c => `${c.suit}${c.rankLabel}`).join(' ');
            return {
                "æœ€ç»ˆæ’å": item.rank,
                "åºå·": item.serial,
                "é˜Ÿä¼åç§°": isImage(item.team) ? "[å›¾ç‰‡é˜Ÿä¼]" : item.team,
                "æˆå‘˜": item.members,
                "å¿ƒæ„¿æ€»è®¡": item.wishTotal,
                "å¿ƒæ„¿ç§¯åˆ†": item.wishPoints,
                "ç‰Œå‹åç§°": item.handTypeName,
                "ç‰Œé¢": cardStr,
                "ç‰Œå‹ç§¯åˆ†": item.handPoints,
                "æœ€ç»ˆåˆ†æ•°": item.finalScore
            };
        });

        upsertFinalRanking(data);
        const ws = XLSX.utils.json_to_sheet(exportData);
        
        // Column widths
        const wscols = [
            {wch: 8},  // æ’å
            {wch: 10}, // åºå·
            {wch: 20}, // é˜Ÿä¼
            {wch: 30}, // æˆå‘˜
            {wch: 10}, // å¿ƒæ„¿æ€»è®¡
            {wch: 10}, // å¿ƒæ„¿ç§¯åˆ†
            {wch: 15}, // ç‰Œå‹
            {wch: 20}, // ç‰Œé¢
            {wch: 10}, // ç‰Œå‹ç§¯åˆ†
            {wch: 10}  // æœ€ç»ˆåˆ†æ•°
        ];
        ws['!cols'] = wscols;

        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "æœ€ç»ˆæ€»æ¦œ");
        
        const date = new Date();
        const dateStr = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        const timeStr = `${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}`;
        
        try {
             XLSX.writeFile(wb, `æœ€ç»ˆæ€»æ¦œ_${dateStr}_${timeStr}.xlsx`);
        } catch (e) {
             alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }

    function updateCalculatorDropdowns() {
        const serialSelect = document.getElementById('serialInput');
        const teamSelect = document.getElementById('teamInput');
        
        // Save current selection
        const currentSerial = serialSelect.value;
        const currentTeam = teamSelect.value;

        serialSelect.innerHTML = '<option value="">åºå·</option>';
        teamSelect.innerHTML = '<option value="">é˜Ÿä¼åç§°</option>';
        
        // Sort by serial
        const sortedList = [...teamList].sort((a, b) => {
            const na = parseInt(a.serial);
            const nb = parseInt(b.serial);
            if (!isNaN(na) && !isNaN(nb)) return na - nb;
            return String(a.serial).localeCompare(String(b.serial));
        });

        sortedList.forEach(team => {
            const optSerial = document.createElement('option');
            optSerial.value = team.serial;
            optSerial.textContent = team.serial;
            serialSelect.appendChild(optSerial);
            
            const optName = document.createElement('option');
            optName.value = team.name;
            optName.textContent = isImage(team.name) ? `åºå· ${team.serial} - [å›¾ç‰‡é˜Ÿä¼]` : team.name;
            teamSelect.appendChild(optName);
        });

        // Restore selection if valid
        if (currentSerial && sortedList.some(t => t.serial === currentSerial)) serialSelect.value = currentSerial;
        if (currentTeam && sortedList.some(t => t.name === currentTeam)) teamSelect.value = currentTeam;
    }

    function syncTeamInput(source) {
        const serialSelect = document.getElementById('serialInput');
        const teamSelect = document.getElementById('teamInput');
        
        if (source === 'serial') {
            const serial = serialSelect.value;
            const team = teamList.find(t => t.serial === serial);
            if (team) {
                teamSelect.value = team.name;
            } else {
                teamSelect.value = "";
            }
        } else if (source === 'team') {
            const name = teamSelect.value;
            const team = teamList.find(t => t.name === name);
            if (team) {
                serialSelect.value = team.serial;
            } else {
                serialSelect.value = "";
            }
        }
    }

    // Team Management
    let teamList = [];
    let currentTeamImageData = null;
    let currentEditingTeamId = null;

    function isImage(str) {
        return typeof str === 'string' && str.startsWith('data:image');
    }

    // Deprecated old image handler
    function handleTeamImageSelect(input) {}

    // Deprecated
    function clearTeamImage() {}

    let teamRowImages = {}; // { rowId: base64Data }
    
    function addTeamRow(data = null) {
        const container = document.getElementById('teamRowsContainer');
        if (!container) return;
        
        const rowId = 'row_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        const div = document.createElement('div');
        div.className = 'team-row';
        div.id = rowId;
        div.style.borderBottom = '1px dashed #ccc';
        div.style.paddingBottom = '10px';
        div.style.marginBottom = '10px';
        
        const serial = data ? data.serial : '';
        const name = data && !isImage(data.name) ? data.name : '';
        const members = data ? data.members.join(' ') : '';
        const time = data ? data.time : '';
        
        // Image handling
        let imagePreviewStyle = 'none';
        let inputDisabled = false;
        let inputPlaceholder = 'é˜Ÿä¼åç§°';
        let imgSrc = '';
        
        if (data && isImage(data.name)) {
            teamRowImages[rowId] = data.name;
            imagePreviewStyle = 'flex';
            inputDisabled = true;
            inputPlaceholder = '(å·²é€‰æ‹©å›¾ç‰‡é˜Ÿå)';
            imgSrc = data.name;
        }

        div.innerHTML = `
            <div class="input-group" style="margin-bottom: 10px; width: 100%; display: flex; gap: 10px; align-items: center;">
                <input type="text" class="team-serial" placeholder="åºå·" value="${serial}" style="width: 80px; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <div style="flex: 1; display: flex; gap: 5px; align-items: center;">
                    <input type="text" class="team-name" placeholder="${inputPlaceholder}" value="${name}" ${inputDisabled ? 'disabled' : ''} style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                    <input type="file" id="file_${rowId}" accept="image/*" style="display:none" onchange="handleTeamRowImage('${rowId}', this)">
                    <button onclick="document.getElementById('file_${rowId}').click()" style="padding: 5px 10px; font-size: 12px;">ä¸Šä¼ å›¾ç‰‡</button>
                    <div id="preview_${rowId}" style="display:${imagePreviewStyle}; align-items: center; gap: 5px;">
                        <img src="${imgSrc}" style="height: 30px; border: 1px solid #ddd;">
                        <button onclick="clearTeamRowImage('${rowId}')" style="padding: 0 5px; color: red;">&times;</button>
                    </div>
                </div>
            </div>
            <div class="input-group" style="margin-bottom: 5px; width: 100%; display: flex; gap: 10px; align-items: center;">
                <input type="text" class="team-members" placeholder="æˆå‘˜ (ç”¨é€—å·æˆ–ç©ºæ ¼åˆ†éš”)" value="${members}" style="flex: 2; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <input type="text" class="team-time" placeholder="é¢„çº¦æ—¶é—´" value="${time}" style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <button onclick="removeTeamRow('${rowId}')" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">åˆ é™¤</button>
            </div>
        `;
        
        container.appendChild(div);
    }

    function removeTeamRow(rowId) {
        const row = document.getElementById(rowId);
        if (row) row.remove();
        delete teamRowImages[rowId];
    }

    function handleTeamRowImage(rowId, input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            teamRowImages[rowId] = e.target.result;
            const row = document.getElementById(rowId);
            const nameInput = row.querySelector('.team-name');
            const previewDiv = document.getElementById('preview_' + rowId);
            const img = previewDiv.querySelector('img');
            
            img.src = e.target.result;
            previewDiv.style.display = 'flex';
            nameInput.disabled = true;
            nameInput.placeholder = '(å·²é€‰æ‹©å›¾ç‰‡é˜Ÿå)';
            nameInput.value = '';
        };
        reader.readAsDataURL(file);
    }

    function clearTeamRowImage(rowId) {
        delete teamRowImages[rowId];
        const row = document.getElementById(rowId);
        const nameInput = row.querySelector('.team-name');
        const previewDiv = document.getElementById('preview_' + rowId);
        const fileInput = document.getElementById('file_' + rowId);
        
        fileInput.value = '';
        previewDiv.style.display = 'none';
        nameInput.disabled = false;
        nameInput.placeholder = 'é˜Ÿä¼åç§°';
    }

    function editTeam(id) {
        const team = teamList.find(t => t.id === id);
        if (!team) return;

        currentEditingTeamId = id;
        
        // Clear existing rows
        document.getElementById('teamRowsContainer').innerHTML = '';
        teamRowImages = {};
        
        // Add single row with data
        addTeamRow(team);

        // Update UI state
        document.getElementById('saveTeamBtn').textContent = 'æ›´æ–°é˜Ÿä¼';
        document.getElementById('saveTeamBtn').style.backgroundColor = 'var(--xmas-green)';
        document.getElementById('cancelTeamEditBtn').style.display = 'inline-block';
        
        // Scroll to form
        document.querySelector('.toolbar').scrollIntoView({ behavior: 'smooth' });
    }

    function cancelTeamEdit() {
        currentEditingTeamId = null;
        
        // Reset rows
        document.getElementById('teamRowsContainer').innerHTML = '';
        teamRowImages = {};
        addTeamRow(); // Add one empty row
        
        // Reset UI state
        document.getElementById('saveTeamBtn').textContent = 'æ‰¹é‡ä¿å­˜';
        document.getElementById('saveTeamBtn').style.backgroundColor = ''; 
        document.getElementById('cancelTeamEditBtn').style.display = 'none';
    }

    function saveAllTeams() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        
        const rows = document.querySelectorAll('.team-row');
        if (rows.length === 0) return;
        
        let newTeams = [];
        let errors = [];
        
        rows.forEach((row, index) => {
            const rowId = row.id;
            const serial = row.querySelector('.team-serial').value.trim();
            let name = row.querySelector('.team-name').value.trim();
            const membersStr = row.querySelector('.team-members').value.trim();
            const time = row.querySelector('.team-time').value.trim();
            
            if (teamRowImages[rowId]) {
                name = teamRowImages[rowId];
            }
            
            if (!serial && !name && !membersStr && !time) return; // Skip empty rows
            
            if (!serial || !name || !time) {
                errors.push(`ç¬¬ ${index + 1} è¡Œï¼šè¯·å¡«å†™å®Œæ•´ä¿¡æ¯(åºå·ã€åç§°ã€æ—¶é—´)`);
                return;
            }
            
            const members = membersStr.split(/[,ï¼Œ\s]+/).filter(m => m);
            
            newTeams.push({
                serial, name, members, time,
                count: members.length,
                sortKey: parseTimeKey(time)
            });
        });
        
        if (errors.length > 0) {
            alert(errors.join('\n'));
            return;
        }
        
        if (newTeams.length === 0) {
            alert('æ²¡æœ‰æœ‰æ•ˆæ•°æ®');
            return;
        }

        if (currentEditingTeamId) {
            // Edit Mode (Single)
            const teamData = newTeams[0];
            const index = teamList.findIndex(t => t.id === currentEditingTeamId);
            if (index !== -1) {
                 const conflict = teamList.find(t => t.serial === teamData.serial && t.id !== currentEditingTeamId);
                 if (conflict) {
                     alert(`åºå· ${teamData.serial} å·²è¢«å ç”¨`);
                     return;
                 }
                 
                 snapshotRanks();
                 insertRankSnapshot('single', 'team', teamData.serial, 'æ›´æ–°é˜Ÿä¼', { name: teamData.name });

                 teamList[index] = { ...teamList[index], ...teamData };
                 upsertTeams([teamList[index]]);
                 cancelTeamEdit();
                 alert('æ›´æ–°æˆåŠŸ');
            }
        } else {
            // Batch Mode
            // Check conflicts
            let conflicts = [];
            newTeams.forEach(t => {
                const conflict = teamList.find(ex => ex.serial === t.serial);
                if (conflict) conflicts.push(t.serial);
            });
            
            if (conflicts.length > 0) {
                if (!confirm(`åºå· ${conflicts.join(', ')} å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) return;
            }
            
            snapshotRanks();
            insertRankSnapshot('batch', 'team', 'batch', 'æ‰¹é‡æ·»åŠ é˜Ÿä¼', { count: newTeams.length });

            let teamsToSync = [];
            newTeams.forEach(t => {
                const idx = teamList.findIndex(ex => ex.serial === t.serial);
                const newTeamObj = { id: idx >= 0 ? teamList[idx].id : Date.now().toString() + Math.random(), ...t };
                if (idx >= 0) {
                    teamList[idx] = newTeamObj;
                } else {
                    teamList.push(newTeamObj);
                }
                teamsToSync.push(newTeamObj);
            });
            
            upsertTeams(teamsToSync);
            
            // Reset
            document.getElementById('teamRowsContainer').innerHTML = '';
            teamRowImages = {};
            addTeamRow();
            
            alert(`æˆåŠŸä¿å­˜ ${newTeams.length} ä¸ªé˜Ÿä¼`);
        }
        
        renderTeamList();
        updateCalculatorDropdowns(); 
    }

    // Initialize first row
    setTimeout(addTeamRow, 1000);
    
    function saveTeam() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        
        // Snapshot current ranks before modification
        snapshotRanks();
        insertRankSnapshot('single', 'team', document.getElementById('teamSerial').value.trim(), 'ä¿å­˜é˜Ÿä¼', { name: document.getElementById('teamName').value.trim() });

        const serial = document.getElementById('teamSerial').value.trim();
        let name = document.getElementById('teamName').value.trim();
        const membersStr = document.getElementById('teamMembers').value.trim();
        const time = document.getElementById('teamTime').value.trim();
        
        // Use image if selected
        if (currentTeamImageData) {
            name = currentTeamImageData;
        }

        if (!serial || !name || !time) {
            alert('è¯·å¡«å†™åºå·ã€é˜Ÿä¼åç§°(æˆ–ä¸Šä¼ å›¾ç‰‡)å’Œé¢„çº¦æ—¶é—´');
            return;
        }
        
        const members = membersStr.split(/[,ï¼Œ\s]+/).filter(m => m);
        
        const teamData = {
            serial: serial,
            name: name,
            members: members,
            count: members.length,
            time: time,
            sortKey: parseTimeKey(time)
        };
        
        if (currentEditingTeamId) {
            // Editing existing team
            const index = teamList.findIndex(t => t.id === currentEditingTeamId);
            if (index !== -1) {
                // Check serial conflict with OTHER teams
                const conflict = teamList.find(t => t.serial === serial && t.id !== currentEditingTeamId);
                if (conflict) {
                    alert(`åºå· ${serial} å·²è¢«é˜Ÿä¼ "${isImage(conflict.name) ? '[å›¾ç‰‡é˜Ÿä¼]' : conflict.name}" å ç”¨ï¼Œè¯·æ›´æ¢åºå·`);
                    return;
                }
                
                // Update
                teamList[index] = {
                    ...teamList[index],
                    ...teamData
                };
                cancelTeamEdit();
            }
        } else {
            // Adding new team
            const team = {
                id: Date.now().toString(),
                ...teamData
            };
            
            // Check if serial exists
            const existIdx = teamList.findIndex(t => t.serial === serial);
            if (existIdx >= 0) {
                if (confirm(`åºå· ${serial} å·²å­˜åœ¨ (${isImage(teamList[existIdx].name) ? '[å›¾ç‰‡é˜Ÿå]' : teamList[existIdx].name})ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) {
                    teamList[existIdx] = {
                        ...teamList[existIdx], // Keep ID
                        ...teamData
                    };
                } else {
                    return;
                }
            } else {
                teamList.push(team);
            }
            
            // Clear inputs
            document.getElementById('teamSerial').value = '';
            document.getElementById('teamName').value = '';
            document.getElementById('teamMembers').value = '';
            document.getElementById('teamTime').value = '';
            clearTeamImage();
        }
        
        renderTeamList();
        upsertTeams([teamData]);
    }
    
    function clearTeamData() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if (confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰é˜Ÿä¼æ•°æ®å—ï¼Ÿ')) {
            teamList = [];
            if (supabaseClient && currentYear) supabaseClient.from('teams').delete().eq('year', currentYear);
            renderTeamList();
        }
    }
    
    function parseTimeKey(timeStr) {
        // Format: 11.24(å‘¨ä¸€)ä¸‹åˆ18:00
        // Regex to find Month.Day and Hour:Minute
        // Support variants: 11.24, 11æœˆ24æ—¥, 18:00, 18ç‚¹00
        try {
            const dateMatch = timeStr.match(/(\d{1,2})[.\æœˆ](\d{1,2})/);
            // Support : ï¼š or ç‚¹ for time separator
            const timeMatch = timeStr.match(/(\d{1,2})[:ï¼šç‚¹](\d{0,2})/);
            
            let val = 0;
            if (dateMatch) {
                val += parseInt(dateMatch[1]) * 1000000; // Month
                val += parseInt(dateMatch[2]) * 10000;   // Day
            }
            if (timeMatch) {
                let hour = parseInt(timeMatch[1]);
                // If minute part is empty (e.g. "18ç‚¹"), treat as 0
                let minute = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
                if (isNaN(minute)) minute = 0;
                
                val += hour * 100;
                val += minute;
            }
            return val;
        } catch (e) {
            return 0;
        }
    }
    
    function getDayLabel(timeStr) {
        // Extract "11.24(å‘¨ä¸€)" part
        const match = timeStr.match(/(\d{1,2}[.\æœˆ]\d{1,2}(?:\(å‘¨[ä¸€äºŒä¸‰å››äº”å…­æ—¥]\))?)/);
        return match ? match[1] : 'å…¶ä»–æ—¶é—´';
    }

    function renderTeamList() {
        const container = document.getElementById('teamListContainer');
        container.innerHTML = '';
        
        // Sort by time
        teamList.sort((a, b) => a.sortKey - b.sortKey);
        
        // Group by Day
        const groups = {};
        teamList.forEach(team => {
            const day = getDayLabel(team.time);
            if (!groups[day]) groups[day] = [];
            groups[day].push(team);
        });
        
        Object.keys(groups).forEach(day => {
            const groupDiv = document.createElement('div');
            
            const header = document.createElement('div');
            header.className = 'team-group-header';
            header.textContent = day;
            groupDiv.appendChild(header);
            
            const table = document.createElement('table');
            table.className = 'team-list-table';
            table.innerHTML = `
                <thead>
                    <tr style="background:#fff; border-bottom:2px solid #eee; font-size:12px; color:#888;">
                        <th style="text-align:left; width:80px;">æ—¶é—´</th>
                        <th style="text-align:left; width:60px;">åºå·</th>
                        <th style="text-align:left; width:150px;">é˜Ÿä¼åç§°</th>
                        <th style="text-align:left;">æˆå‘˜</th>
                        <th style="text-align:center; width:50px;">äººæ•°</th>
                        ${isAdmin ? '<th style="text-align:center; width:60px;">æ“ä½œ</th>' : ''}
                    </tr>
                </thead>
                <tbody></tbody>
            `;
            
            const tbody = table.querySelector('tbody');
            groups[day].forEach(team => {
                const tr = document.createElement('tr');
                // Extract just time part for display if possible, or show full?
                // User requirement: "åˆ—è¡¨æŒ‰ç…§é¢„çº¦æ—¶é—´æ’åº"
                // Let's show the time part (e.g. 18:00) in first col
                const timeMatch = team.time.match(/\d{1,2}[:ï¼š]\d{1,2}/);
                const shortTime = timeMatch ? timeMatch[0] : team.time;
                
                const membersHtml = team.members.map(m => `<span class="tag">${m}</span>`).join('');
                
                const nameDisplay = isImage(team.name) ? `<img src="${team.name}" style="height:30px; vertical-align:middle;">` : team.name;

                tr.innerHTML = `
                    <td>${shortTime}</td>
                    <td><span style="font-weight:bold; color:#007bff;">${team.serial}</span></td>
                    <td>${nameDisplay}</td>
                    <td>${membersHtml}</td>
                    <td style="text-align:center;">${team.count}</td>
                    ${isAdmin ? `<td style="text-align:center;">\n                        <button onclick=\"editTeam('${team.id}')\" style=\"padding:2px 5px; font-size:12px; background:#007bff; margin-right:5px;\">ç¼–è¾‘</button>\n                        <button onclick=\"deleteTeam('${team.id}')\" style=\"padding:2px 5px; font-size:12px; background:#dc3545;\">åˆ é™¤</button>\n                    </td>` : ''}
                `;
                tbody.appendChild(tr);
            });
            
            groupDiv.appendChild(table);
            container.appendChild(groupDiv);
        });
    }
    
    function deleteTeam(id) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if (confirm('ç¡®å®šåˆ é™¤æ­¤é˜Ÿä¼å—ï¼Ÿ')) {
            // Snapshot current ranks before modification
            snapshotRanks();
            const del = teamList.find(t => t.id === id);
            insertRankSnapshot('single', 'team', del ? del.serial : '', 'åˆ é™¤é˜Ÿä¼', { name: del ? del.name : '' });

            teamList = teamList.filter(t => t.id !== id);
            if (del) deleteTeamInCloud(del.serial);
            renderTeamList();
        }
    }

    function exportTeams() {
        if (teamList.length === 0) {
            alert('æ²¡æœ‰é˜Ÿä¼æ•°æ®å¯å¯¼å‡º');
            return;
        }

        // Sort by time (same as display)
        const sortedList = [...teamList].sort((a, b) => a.sortKey - b.sortKey);

        const data = sortedList.map(team => {
            return {
                "åºå·": team.serial,
                "é˜Ÿä¼åç§°": isImage(team.name) ? "[å›¾ç‰‡é˜Ÿä¼]" : team.name,
                "æˆå‘˜": team.members.join(', '),
                "äººæ•°": team.count,
                "é¢„çº¦æ—¶é—´": team.time
            };
        });

        const ws = XLSX.utils.json_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "é˜Ÿä¼åˆ—è¡¨");

        // Generate filename
        const date = new Date();
        const dateStr = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        const timeStr = `${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}`;
        const filename = `é˜Ÿä¼åˆ—è¡¨_${dateStr}_${timeStr}.xlsx`;

        try {
            XLSX.writeFile(wb, filename);
        } catch (e) {
            alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }

    function handleTeamFileUpload(event) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        snapshotRanks();
        insertRankSnapshot('bulk', 'team', '', 'æ‰¹é‡å¯¼å…¥é˜Ÿä¼', { source: 'file' });
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                
                let successCount = 0;
                
                // Analyze header to find columns
                let startRow = 0;
                let colSerial = -1;
                let colName = -1;
                let colTime = -1;
                let headerRow = [];
                
                // Find header row
                for(let i=0; i<Math.min(20, jsonData.length); i++) { // Increased search range
                    // Handle sparse arrays by using Array.from to fill holes with undefined, then map
                    const rawRow = jsonData[i] || [];
                    const row = Array.from(rawRow).map(c => String(c || '').trim());
                    
                    // Check for key columns
                    if (row.some(c => c.includes('é˜Ÿä¼åç§°') || c.includes('Team'))) {
                        startRow = i + 1;
                        headerRow = row;
                        colSerial = row.findIndex(c => c.includes('åºå·') || c.includes('No') || c.includes('ID'));
                        colName = row.findIndex(c => c.includes('é˜Ÿä¼åç§°') || c.includes('Team'));
                        colTime = row.findIndex(c => c.includes('é¢„çº¦æ—¶é—´') || c.includes('Time') || c.includes('Date'));
                        break;
                    }
                }
                
                if (colName === -1) {
                    throw new Error("æœªæ‰¾åˆ°'é˜Ÿä¼åç§°'åˆ—ï¼Œè¯·æ£€æŸ¥è¡¨å¤´");
                }
                if (colTime === -1) {
                    // Try to guess if not found explicitly? 
                    // Maybe look for a column with date-like strings in first data row?
                    // For now, let's assume it exists or warn.
                    console.warn("æœªæ‰¾åˆ°'é¢„çº¦æ—¶é—´'åˆ—ï¼Œå°†è·³è¿‡æ—¶é—´è§£æ");
                }
                
                for (let i = startRow; i < jsonData.length; i++) {
                    const row = jsonData[i];
                    if (!row || row.length === 0) continue;
                    
                    // Helper to safely get cell value
                    const getVal = (idx) => {
                        if (idx < 0 || idx >= row.length) return '';
                        return String(row[idx] || '').trim().replace(/[\r\n]+/g, ' '); // Replace newlines with space
                    };
                    
                    const serial = colSerial !== -1 ? getVal(colSerial) : '';
                    let name = getVal(colName);
                    const time = colTime !== -1 ? getVal(colTime) : '';
                    
                    if (!name && serial) {
                        name = "(éœ€è¡¥å……å›¾ç‰‡)";
                    }
                    
                    if (!name) continue; // Skip if no name
                    
                    // Collect members
                    const members = [];
                    // Scan cols between Name and Time (or end of row if Time not found)
                    const endCol = colTime !== -1 ? colTime : row.length;
                    
                    if (colName < endCol) {
                        for (let j = colName + 1; j < endCol; j++) {
                            // Check header for "Count" or "äººæ•°"
                            // But be careful: sometimes users put names in columns labeled "äººæ•°" (e.g. "é¢†é˜Ÿäººæ•°" but filled with name)
                            // So only skip if header implies count AND value looks like a number
                            const isCountHeader = headerRow[j] && (headerRow[j].includes('äººæ•°') || headerRow[j].includes('Count'));
                            
                            const val = getVal(j);
                            
                            if (isCountHeader) {
                                // If header says count, skip only if value is numeric or like "4äºº"
                                // If it's a name (NaN), keep it
                                if (!isNaN(val) || /^\d+\s*äºº?$/.test(val)) {
                                    continue;
                                }
                            }
                            
                            // Skip empty, "äººæ•°" literal in data (unlikely if header check works), or pure numbers (double check)
                            if (val && !val.includes('äººæ•°')) {
                                // Heuristic: Member names are usually not single digits. 
                                // But strictly, we should rely on header check.
                                // If header check passed, we accept it unless it looks very wrong.
                                // Let's keep the length check but be careful.
                                if (isNaN(val) || val.length > 1) {
                                    members.push(val);
                                }
                            }
                        }
                    }
                    
                    const newTeam = {
                        id: Date.now().toString() + Math.random(),
                        serial: serial || (teamList.length + 1).toString(), // Fallback serial
                        name: name,
                        members: members,
                        count: members.length,
                        time: time,
                        sortKey: parseTimeKey(time)
                    };
                    teamList.push(newTeam);
                    successCount++;
                }
                
                renderTeamList();
                upsertTeams(teamList);
                alert(`æˆåŠŸå¯¼å…¥ ${successCount} æ”¯é˜Ÿä¼`);
                closeModal('teamImportModal');
                
            } catch (err) {
                console.error(err);
                alert('å¯¼å…¥å¤±è´¥: ' + err.message);
            }
        };
        reader.readAsArrayBuffer(file);
        event.target.value = '';
    }


    // --- Wish Calculation Functions (Old) ---
    // let currentEditingWishSerial = null; // Removed to avoid conflict with Batch implementation
    
    // Deprecated old functions (overridden by Batch implementation below)
    function renderWishDropdowns() {}
    function syncWishInput(source) {}
    function saveWish() {}
    function cancelWishEdit() {} 
    function editWish(serial) {} 
    // function cancelWishEdit() {} // Overridden below
    // function editWish(serial) {} // Overridden below

    /*
    function cancelWishEdit() {
        document.getElementById('wishSerialInput').value = "";
        document.getElementById('wishTeamInput').value = "";
        document.getElementById('wish1').value = "";
        document.getElementById('wish2').value = "";
        document.getElementById('wish3').value = "";
        document.getElementById('wish4').value = "";
        document.getElementById('wish5').value = "";
        
        document.getElementById('saveWishBtn').textContent = 'ä¿å­˜æ•°æ®';
        document.getElementById('cancelWishEditBtn').style.display = 'none';
        currentEditingWishSerial = null;
    }

    function editWish(serial) {
        const wish = wishList.find(w => w.serial === serial);
        if (!wish) return;
        
        document.getElementById('wishSerialInput').value = wish.serial;
        // Trigger sync to set team name (or set manually)
        // syncWishInput('serial'); 
        // Better set manually to ensure correct
        const team = teamList.find(t => t.serial === serial);
        if (team) document.getElementById('wishTeamInput').value = team.name;
        else document.getElementById('wishTeamInput').value = wish.team; // Fallback
        
        document.getElementById('wish1').value = wish.wishes[0] || '';
        document.getElementById('wish2').value = wish.wishes[1] || '';
        document.getElementById('wish3').value = wish.wishes[2] || '';
        document.getElementById('wish4').value = wish.wishes[3] || '';
        document.getElementById('wish5').value = wish.wishes[4] || '';
        
        document.getElementById('saveWishBtn').textContent = 'æ›´æ–°æ•°æ®';
        document.getElementById('cancelWishEditBtn').style.display = 'inline-block';
        
        // Use global from new batch logic or define locally if still needed for old logic? 
        // Actually this old logic tries to use currentEditingWishSerial which we commented out.
        // So this whole block is dead code anyway since UI calls new functions.
        // But to be safe let's just comment out body.
    }
    */

    function deleteWish(serial) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if(confirm('ç¡®å®šåˆ é™¤è¯¥é˜Ÿä¼çš„å¿ƒæ„¿æ•°æ®å—ï¼Ÿ')) {
            // Snapshot current ranks before modification
            snapshotRanks();
            insertRankSnapshot('single', 'wish', serial, 'åˆ é™¤å¿ƒæ„¿', {});

            wishList = wishList.filter(w => w.serial !== serial);
            deleteWishInCloud(serial);
            renderWishRanking();
        }
    }

    function clearWishData() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if(confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰å¿ƒæ„¿æ•°æ®å—ï¼Ÿ')) {
            wishList = [];
            if (supabaseClient && currentYear) supabaseClient.from('wishes').delete().eq('year', currentYear);
            renderWishRanking();
        }
    }

    function renderWishRanking() {
        const tbody = document.querySelector('#wishRankingTable tbody');
        tbody.innerHTML = '';
        
        // Sort by total wishes (descending)
        wishList.sort((a, b) => b.total - a.total);
        
        let effectiveRank = 1;
        
        wishList.forEach((entry, index) => {
             // Tie handling
             if (index > 0 && entry.total === wishList[index-1].total) {
                 // Tie
             } else {
                 effectiveRank = index + 1;
             }
             
             const points = totalTeams - effectiveRank + 1;
             entry.rank = effectiveRank;
             entry.points = points;
             
             const tr = document.createElement('tr');
             
             const nameDisplay = isImage(entry.team) ? `<img src="${entry.team}" style="height:30px; vertical-align:middle;">` : entry.team;
             
            tr.innerHTML = `
               <td>${effectiveRank}${getRankChangeHtml(entry.serial, effectiveRank, 'wish')}</td>
               <td>${entry.serial}</td>
               <td>${nameDisplay}</td>
               <td>${entry.wishes[0]}</td>
               <td>${entry.wishes[1]}</td>
               <td>${entry.wishes[2]}</td>
               <td>${entry.wishes[3]}</td>
               <td>${entry.wishes[4]}</td>
               <td style="font-weight:bold;">${entry.total}</td>
               <td style="color:${points > 0 ? '#28a745' : 'inherit'}; font-weight:bold;">${points}</td>
               ${isAdmin ? `<td>\n                   <button onclick=\"editWish('${entry.serial}')\" style=\"padding:2px 5px; font-size:12px; background:#007bff; margin-right:5px;\">ç¼–è¾‘</button>\n                   <button onclick=\"deleteWish('${entry.serial}')\" style=\"padding:2px 5px; font-size:12px; background:#dc3545;\">åˆ é™¤</button>\n               </td>` : ''}
            `;
             tbody.appendChild(tr);
        });
    }

    function handleWishFileUpload(event) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        snapshotRanks();
        insertRankSnapshot('bulk', 'wish', '', 'æ‰¹é‡å¯¼å…¥å¿ƒæ„¿', { source: 'file' });
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                
                let successCount = 0;
                let startRow = 0;
                let colSerial = -1;
                let colName = -1;
                let colW1 = -1;
                
                // Find headers
                for(let i=0; i<Math.min(20, jsonData.length); i++) {
                    const rawRow = jsonData[i] || [];
                    const row = Array.from(rawRow).map(c => String(c || '').trim());
                    if (row.some(c => c.includes('åºå·') || c.includes('é˜Ÿä¼åç§°'))) {
                        startRow = i + 1;
                        colSerial = row.findIndex(c => c.includes('åºå·'));
                        colName = row.findIndex(c => c.includes('é˜Ÿä¼åç§°'));
                        colW1 = row.findIndex(c => c.includes('1é¢—') || c.includes('1æ˜Ÿ'));
                        break;
                    }
                }
                
                if (colSerial === -1 || colName === -1) {
                    throw new Error("æœªæ‰¾åˆ°'åºå·'æˆ–'é˜Ÿä¼åç§°'åˆ—");
                }
                
                for (let i = startRow; i < jsonData.length; i++) {
                    const rawRow = jsonData[i] || [];
                    const row = Array.from(rawRow).map(c => String(c || '').trim());
                    
                    const serial = row[colSerial];
                    let team = row[colName];
                    
                    if (!serial && !team) continue;
                    
                    // Normalize team name
                    if (teamList.length > 0) {
                         const normalize = str => String(str || '').replace(/\s+/g, '');
                         const canonical = teamList.find(t => String(t.serial) === String(serial) && normalize(t.name) === normalize(team));
                         if (canonical) team = canonical.name;
                    }
                    
                    const wishes = [0, 0, 0, 0, 0];
                    if (colW1 !== -1) {
                        for (let j = 0; j < 5; j++) {
                            if (colW1 + j < rawRow.length) {
                                const val = parseInt(rawRow[colW1 + j]);
                                wishes[j] = isNaN(val) ? 0 : val;
                            }
                        }
                    }
                    
                    const total = wishes.reduce((a,b) => a+b, 0);
                    
                    // Update or Add
                    const existingIdx = wishList.findIndex(w => w.serial === serial);
                    const entry = {
                        serial: serial,
                        team: team,
                        wishes: wishes,
                        total: total
                    };
                    
                    if (existingIdx !== -1) {
                        wishList[existingIdx] = entry;
                    } else {
                        wishList.push(entry);
                    }
                    successCount++;
                }
                
                renderWishRanking();
                upsertWishes(wishList);
                alert(`æˆåŠŸå¯¼å…¥ ${successCount} æ¡å¿ƒæ„¿æ•°æ®`);
                closeModal('wishImportModal');
                
            } catch (err) {
                console.error(err);
                alert('å¯¼å…¥å¤±è´¥: ' + err.message);
            }
        };
        reader.readAsArrayBuffer(file);
        event.target.value = '';
    }

    function exportWishRanking() {
        if (wishList.length === 0) {
            alert('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
            return;
        }
        
        const data = wishList.map(entry => {
            return {
                "æ’å": entry.rank,
                "åºå·": entry.serial,
                "é˜Ÿä¼åç§°": isImage(entry.team) ? "[å›¾ç‰‡é˜Ÿä¼]" : entry.team,
                "1é¢—å¿ƒæ„¿": entry.wishes[0],
                "2é¢—å¿ƒæ„¿": entry.wishes[1],
                "3é¢—å¿ƒæ„¿": entry.wishes[2],
                "4é¢—å¿ƒæ„¿": entry.wishes[3],
                "5é¢—å¿ƒæ„¿": entry.wishes[4],
                "å¿ƒæ„¿æ€»è®¡": entry.total,
                "ç§¯åˆ†": entry.points
            };
        });
        
        const ws = XLSX.utils.json_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "å¿ƒæ„¿æ’è¡Œ");
        
        try {
             XLSX.writeFile(wb, `å¿ƒæ„¿æ’è¡Œ_${new Date().getTime()}.xlsx`);
        } catch (e) {
             alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }

    async function init() {
        // Restore admin state
        try { isAdmin = (localStorage.getItem('isAdmin') === 'true'); } catch (e) {}
        initHandTypeFilter();
        generateDeck();
        renderDropdowns();
        updateCalculatorDropdowns();
        renderWishDropdowns();
        currentYear = new Date().getFullYear();
        await initSupabase();
        await loadYearData(currentYear);
        updateHeaderYear();
        applyRoleUI();
        renderGiftTiersConfig(); // Init tiers config UI
        renderGiftTierLegend(); // Init legend
        
        // Hide Loader
        const loader = document.getElementById('pageLoader');
        if (loader) {
            loader.style.opacity = '0';
            setTimeout(() => loader.style.display = 'none', 500);
        }
        
        // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰èœå•
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.card-input-group')) {
                closeAllDropdowns();
            }
            // Click outside modal to close
            if (event.target.classList.contains('modal')) {
                event.target.style.display = "none";
            }
        });
    }

    // --- Gift Tiers & Images Logic ---

    function renderGiftTiersConfig() {
        const container = document.getElementById('giftTiersConfig');
        container.innerHTML = '';
        
        giftTiers.forEach((tier, index) => {
            const div = document.createElement('div');
            div.style.display = 'flex';
            div.style.gap = '5px';
            div.style.marginBottom = '5px';
            div.style.alignItems = 'center';
            
            div.innerHTML = `
                <input type="text" placeholder="åç§°" value="${tier.name}" onchange="updateGiftTier(${index}, 'name', this.value)" style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                <input type="number" placeholder="Min" value="${tier.min}" onchange="updateGiftTier(${index}, 'min', this.value)" style="width: 50px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                <span>-</span>
                <input type="number" placeholder="Max" value="${tier.max}" onchange="updateGiftTier(${index}, 'max', this.value)" style="width: 50px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                <input type="color" value="${tier.color}" onchange="updateGiftTier(${index}, 'color', this.value)" style="width: 40px; height: 30px; border: none; background: none; cursor: pointer;">
                <button onclick="removeGiftTier(${index})" style="padding: 2px 5px; color: red; border: none; background: none; cursor: pointer;">&times;</button>
            `;
            container.appendChild(div);
        });
        
        const addBtn = document.createElement('button');
        addBtn.textContent = '+ æ·»åŠ æ¡£ä½';
        addBtn.className = 'btn-secondary';
        addBtn.style.padding = '5px 10px';
        addBtn.style.fontSize = '12px';
        addBtn.onclick = addGiftTier;
        container.appendChild(addBtn);
        
        // Also update settings in cloud if changed? Or just rely on "Save" button? 
        // We don't have a global "Save Settings" button, changes are usually immediate or auto-saved.
        // Let's add an auto-save for settings later or just save now.
        saveAppSettings();
    }
    
    function updateGiftTier(index, field, value) {
        if (field === 'min' || field === 'max') value = parseInt(value) || 0;
        giftTiers[index][field] = value;
        renderGiftTierLegend();
        saveAppSettings();
    }
    
    function addGiftTier() {
        giftTiers.push({ min: 0, max: 0, name: "æ–°æ¡£ä½", color: "#ffffff", value: 0 });
        renderGiftTiersConfig();
    }
    
    function removeGiftTier(index) {
        giftTiers.splice(index, 1);
        renderGiftTiersConfig();
    }
    
    function renderGiftTierLegend() {
        const container = document.getElementById('tierLegendContainer');
        if (!container) return;
        container.innerHTML = '';
        giftTiers.forEach(tier => {
            const span = document.createElement('span');
            span.style.display = 'inline-flex';
            span.style.alignItems = 'center';
            span.style.gap = '5px';
            span.innerHTML = `<span style="width: 15px; height: 15px; background-color: ${tier.color}; border: 1px solid #ccc; display: inline-block;"></span> ${tier.name} (${tier.min}-${tier.max})`;
            container.appendChild(span);
        });
    }

    async function handleGiftImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Convert to Base64
        const reader = new FileReader();
        reader.onload = async function(e) {
            const base64 = e.target.result;
            // Add to giftImages
            giftImages.push({
                id: Date.now().toString(),
                url: base64, // Storing base64 directly for simplicity as requested "upload gift images" without external storage bucket setup instructions
                desc: file.name
            });
            renderGiftImagesPreview();
            await saveGiftImages();
            event.target.value = ''; // Reset
        };
        reader.readAsDataURL(file);
    }
    
    function renderGiftImagesPreview() {
        const container = document.getElementById('giftImagePreviewContainer');
        container.innerHTML = '';
        giftImages.forEach((img, index) => {
            const div = document.createElement('div');
            div.style.position = 'relative';
            div.style.display = 'inline-block'; // Ensure proper positioning context
            div.style.margin = '5px';
            div.innerHTML = `
                <img src="${img.url}" style="height: 60px; border: 1px solid #ccc; border-radius: 4px; display: block;">
                <button onclick="removeGiftImage(${index})" style="position: absolute; top: -8px; right: -8px; background: red; color: white; border-radius: 50%; width: 20px; height: 20px; border: none; cursor: pointer; font-size: 14px; line-height: 18px; padding: 0; display: flex; align-items: center; justify-content: center;">&times;</button>
            `;
            container.appendChild(div);
        });
        
        // Also update the view modal
        const viewContainer = document.getElementById('giftImagesViewContainer');
        if (viewContainer) {
            viewContainer.innerHTML = '';
            giftImages.forEach(img => {
                const wrapper = document.createElement('div');
                wrapper.style.cursor = 'zoom-in';
                wrapper.onclick = () => showEnlargedImage(img.url);
                
                const imgEl = document.createElement('img');
                imgEl.src = img.url;
                imgEl.style.maxWidth = '100%';
                imgEl.style.maxHeight = '400px';
                imgEl.style.border = '1px solid #ccc';
                imgEl.style.borderRadius = '4px';
                
                wrapper.appendChild(imgEl);
                viewContainer.appendChild(wrapper);
            });
        }
    }
    
    function showEnlargedImage(url) {
        // Create or reuse an overlay for zoomed image
        let overlay = document.getElementById('imageZoomOverlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'imageZoomOverlay';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0,0,0,0.9)'; // Darker bg
            overlay.style.zIndex = '2000';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.overflow = 'hidden'; // Prevent scrolling body
            
            // Pan/Zoom State
            let scale = 1;
            let panning = false;
            let pointX = 0;
            let pointY = 0;
            let startX = 0;
            let startY = 0;

            const img = document.createElement('img');
            img.style.maxWidth = '100%';
            img.style.maxHeight = '100%';
            img.style.boxShadow = '0 0 20px rgba(0,0,0,0.5)';
            img.style.transition = 'transform 0.1s ease-out'; // Smooth zoom
            img.style.cursor = 'grab';
            img.style.transformOrigin = 'center center'; // Ensure scaling from center
            img.draggable = false;
            
            // Zoom with wheel
            overlay.onwheel = (e) => {
                e.preventDefault();
                // Simply scale, don't adjust position based on mouse (simplifies logic and prevents jumping)
                // If we want mouse-centric zoom, we need complex offset calc.
                // Let's stick to center zoom + pan for stability.
                const delta = -e.deltaY;
                const oldScale = scale;
                (delta > 0) ? (scale *= 1.2) : (scale /= 1.2);
                
                if (scale < 1) scale = 1;
                if (scale > 5) scale = 5; 
                
                // If scaling down to 1, reset position
                if (scale === 1) {
                    pointX = 0;
                    pointY = 0;
                }
                
                updateTransform();
            };
            
            // Pan with mouse
            img.onmousedown = (e) => {
                e.preventDefault();
                startX = e.clientX - pointX;
                startY = e.clientY - pointY;
                panning = true;
                img.style.cursor = 'grabbing';
            };
            
            overlay.onmouseup = () => {
                panning = false;
                img.style.cursor = 'grab';
            };
            
            overlay.onmousemove = (e) => {
                if (!panning) return;
                e.preventDefault();
                pointX = e.clientX - startX;
                pointY = e.clientY - startY;
                updateTransform();
            };
            
            // Double click to reset or zoom
            img.ondblclick = (e) => {
                e.stopPropagation(); // Prevent overlay click close
                if (scale > 1) {
                    scale = 1;
                    pointX = 0;
                    pointY = 0;
                } else {
                    scale = 2;
                    // Center on click? Simplified to center
                    pointX = 0;
                    pointY = 0; 
                }
                updateTransform();
            }

            function updateTransform() {
                img.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
            }
            
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '20px';
            closeBtn.style.right = '20px';
            closeBtn.style.fontSize = '30px';
            closeBtn.style.color = 'white';
            closeBtn.style.background = 'none';
            closeBtn.style.border = 'none';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.zIndex = '2001';
            closeBtn.onclick = () => {
                overlay.style.display = 'none';
                resetZoom();
            };
            
            // Click background to close
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    overlay.style.display = 'none';
                    resetZoom();
                }
            };
            
            function resetZoom() {
                scale = 1;
                pointX = 0;
                pointY = 0;
                updateTransform();
            }

            overlay.appendChild(img);
            overlay.appendChild(closeBtn);
            document.body.appendChild(overlay);
        }
        
        const img = overlay.querySelector('img');
        img.src = url;
        overlay.style.display = 'flex';
    }
    
    function removeGiftImage(index) {
        giftImages.splice(index, 1);
        renderGiftImagesPreview();
        saveGiftImages();
    }
    
    function viewGiftImages() {
        renderGiftImagesPreview(); // Ensure up to date
        openModal('giftImagesModal');
    }
    
    async function saveAppSettings() {
        if (!supabaseClient || !currentYear || !isAdmin) return;
        
        // Save Tiers
        await supabaseClient.from('settings').upsert({ 
            year: currentYear, 
            key: 'gift_tiers', 
            value: giftTiers 
        }, { onConflict: 'year,key' });

        // Save Total Teams
        await supabaseClient.from('settings').upsert({ 
            year: currentYear, 
            key: 'total_teams', 
            value: totalTeams 
        }, { onConflict: 'year,key' });
    }

    async function saveGiftImages() {
        if (!supabaseClient || !currentYear || !isAdmin) return;
        if (Array.isArray(giftImages) && giftImages.length > 0) {
            await supabaseClient.from('settings').upsert({ 
                year: currentYear, 
                key: 'gift_images', 
                value: giftImages 
            }, { onConflict: 'year,key' });
        } else {
            await supabaseClient.from('settings').delete().eq('year', currentYear).eq('key', 'gift_images');
        }
    }
    
    // --- Gift Selection Logic ---
    
    function renderGiftSelection() {
        const tbody = document.querySelector('#giftSelectionTable tbody');
        tbody.innerHTML = '';
        
        let data = getFinalRankingData(); // Sorted by Rank

        // Filter Logic
        const sTeam = document.getElementById('searchGiftTeam')?.value.toLowerCase().trim() || '';
        const sMember = document.getElementById('searchGiftMember')?.value.toLowerCase().trim() || '';

        if (sTeam || sMember) {
            data = data.filter(item => {
                const matchTeam = !sTeam || item.team.toLowerCase().includes(sTeam);
                // item.members is string "m1, m2" joined in getFinalRankingData
                const matchMember = !sMember || item.members.toLowerCase().includes(sMember);
                return matchTeam && matchMember;
            });
        }
        
        data.forEach(item => {
            const tr = document.createElement('tr');
            
            // Tier
            const tier = giftTiers.find(t => item.rank >= t.min && item.rank <= t.max);
            const tierName = tier ? tier.name : "-";
            const tierColor = tier ? tier.color : "";
            
            if (tierColor) tr.style.backgroundColor = tierColor;
            
            tr.innerHTML += `<td style="width: 80px; text-align: center; font-weight: bold;">${item.rank}</td>`;
            tr.innerHTML += `<td style="width: 100px; text-align: center;">${tierName}</td>`;
            
             const nameDisplay = isImage(item.team) ? `<img src="${item.team}" style="height:30px; vertical-align:middle;">` : item.team;
            tr.innerHTML += `<td>${nameDisplay}</td>`;
            
            // Members & Gifts
            const tdGifts = document.createElement('td');
            
            // Get Team from teamList to access members and gift data
            const teamEntry = teamList.find(t => t.serial === item.serial);
            const members = teamEntry ? teamEntry.members : [];
            const gifts = teamEntry ? (teamEntry.gifts || {}) : {};
            
            if (members.length === 0) {
                tdGifts.textContent = "æ— æˆå‘˜ä¿¡æ¯";
            } else {
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.gap = '5px';
                
                members.forEach(member => {
                    const memberGift = gifts[member] || { id: '', remark: '' };
                    
                    const row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.gap = '10px';
                    
                    row.innerHTML = `
                        <span style="width: 80px; font-weight: bold; text-align: right;">${member}:</span>
                        <input type="text" placeholder="ç¤¼ç‰©ç¼–å·" value="${memberGift.id || ''}" 
                            onblur="handleGiftBlur(this, '${item.serial}', '${member}', 'id')"
                            style="width: 100px; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                        <input type="text" placeholder="å¤‡æ³¨" value="${memberGift.remark || ''}" 
                            onblur="handleGiftBlur(this, '${item.serial}', '${member}', 'remark')"
                            style="flex: 1; padding: 5px; border: 1px solid #ccc; border-radius: 3px;">
                        <span class="save-status" style="font-size: 12px; color: green; display: none;">å·²ä¿å­˜</span>
                    `;
                    container.appendChild(row);
                });
                tdGifts.appendChild(container);
            }
            
            tr.appendChild(tdGifts);
            tbody.appendChild(tr);
        });
    }
    
    function exportGiftSelection() {
        const data = getFinalRankingData();
        if (data.length === 0) {
            alert('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
            return;
        }
        
        let exportData = [];
        
        data.forEach(item => {
            const teamEntry = teamList.find(t => t.serial === item.serial);
            const members = teamEntry ? teamEntry.members : [];
            const gifts = teamEntry ? (teamEntry.gifts || {}) : {};
            const tier = giftTiers.find(t => item.rank >= t.min && item.rank <= t.max);
            const tierName = tier ? tier.name : '-';
            const teamName = isImage(item.team) ? "[å›¾ç‰‡é˜Ÿä¼]" : item.team;
            
            if (members.length > 0) {
                members.forEach(member => {
                    const g = gifts[member] || {};
                    const giftId = g.id ? String(g.id) : '';
                    const remark = g.remark ? String(g.remark) : '';
                    
                    exportData.push({
                        "æœ€ç»ˆæ’å": item.rank,
                        "ç¤¼ç‰©æ¡£ä½": tierName,
                        "é˜Ÿä¼åç§°": teamName,
                        "æˆå‘˜åç§°": member,
                        "ç¤¼ç‰©é€‰æ‹©": giftId,
                        "å¤‡æ³¨": remark
                    });
                });
            } else {
                exportData.push({
                    "æœ€ç»ˆæ’å": item.rank,
                    "ç¤¼ç‰©æ¡£ä½": tierName,
                    "é˜Ÿä¼åç§°": teamName,
                    "æˆå‘˜åç§°": "æ— æˆå‘˜ä¿¡æ¯",
                    "ç¤¼ç‰©é€‰æ‹©": "",
                    "å¤‡æ³¨": ""
                });
            }
        });

        const ws = XLSX.utils.json_to_sheet(exportData);
        ws['!cols'] = [
            { wch: 8 },  // æœ€ç»ˆæ’å
            { wch: 10 }, // ç¤¼ç‰©æ¡£ä½
            { wch: 20 }, // é˜Ÿä¼åç§°
            { wch: 15 }, // æˆå‘˜åç§°
            { wch: 15 }, // ç¤¼ç‰©é€‰æ‹©
            { wch: 20 }  // å¤‡æ³¨
        ];
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'ç¤¼ç‰©é€‰æ‹©');
        const date = new Date();
        const dateStr = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        const timeStr = `${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}`;
        try {
            XLSX.writeFile(wb, `ç¤¼ç‰©é€‰æ‹©_${dateStr}_${timeStr}.xlsx`);
        } catch (e) {
            alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }
    
    // Handle blur event for auto-save
    async function handleGiftBlur(input, serial, member, field) {
        const newValue = input.value;
        const team = teamList.find(t => t.serial === serial);
        if (!team) return;
        
        if (!team.gifts) team.gifts = {};
        if (!team.gifts[member]) team.gifts[member] = { id: '', remark: '' };
        
        // Only save if changed
        if (team.gifts[member][field] !== newValue) {
            team.gifts[member][field] = newValue;
            
            // Show saving status
            const statusSpan = input.parentNode.querySelector('.save-status');
            statusSpan.textContent = 'ä¿å­˜ä¸­...';
            statusSpan.style.display = 'inline';
            statusSpan.style.color = 'orange';
            
            try {
                // Confirm save
                if (confirm(`æ˜¯å¦ä¿å­˜ ${member} çš„ç¤¼ç‰©ä¿¡æ¯ä¿®æ”¹ï¼Ÿ`)) {
                    await upsertTeams([team]); // Save this specific team only
                    statusSpan.textContent = 'å·²ä¿å­˜';
                    statusSpan.style.color = 'green';
                    setTimeout(() => statusSpan.style.display = 'none', 2000);
                } else {
                    // Revert if cancelled? Or just don't save to cloud but keep in UI?
                    // User requirement: "æç¤ºæ˜¯å¦ä¿å­˜å½“å‰ä¿®æ”¹"
                    // If user cancels, we should probably revert UI or just leave it unsaved (risky).
                    // Reverting UI is safer to match state.
                    input.value = team.gifts[member][field]; // Revert (wait, we already updated local state above)
                    // Actually we should update local state ONLY after confirmation or if we treat local as draft.
                    // But for simplicity, let's keep local state updated, but cloud state not.
                    // If user says No, we just hide status and don't push to cloud.
                    // But next refresh will lose data. This is standard behavior for "Cancel Save".
                    statusSpan.style.display = 'none';
                }
            } catch (e) {
                console.error(e);
                statusSpan.textContent = 'ä¿å­˜å¤±è´¥';
                statusSpan.style.color = 'red';
            }
        }
    }

    /* Removed saveAllGifts and updateMemberGift as they are replaced by auto-save logic */
    /*
    function updateMemberGift(serial, member, field, value) { ... }
    async function saveAllGifts() { ... }
    */
    function openModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = "block";
            if (modalId === 'settingsModal') {
                const input = document.getElementById('totalTeamsInput');
                if (input) input.value = String(totalTeams);
            }
        } else {
            console.error("Modal not found:", modalId);
        }
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = "none";
        }
    }

    function generateDeck() {
        const suits = [
            { symbol: 'â™ ', color: 'black', name: 'Spade', chinese: 'é»‘æ¡ƒ', short: 's' },
            { symbol: 'â™¥', color: 'red', name: 'Heart', chinese: 'çº¢æ¡ƒ', short: 'h' },
            { symbol: 'â™£', color: 'black', name: 'Club', chinese: 'æ¢…èŠ±', short: 'c' },
            { symbol: 'â™¦', color: 'red', name: 'Diamond', chinese: 'æ–¹å—', short: 'd' }
        ];
        const ranks = [
            { val: 2, label: '2' }, { val: 3, label: '3' }, { val: 4, label: '4' }, 
            { val: 5, label: '5' }, { val: 6, label: '6' }, { val: 7, label: '7' }, 
            { val: 8, label: '8' }, { val: 9, label: '9' }, { val: 10, label: '10', alias: 't' },
            { val: 11, label: 'J' }, { val: 12, label: 'Q' }, { val: 13, label: 'K' }, { val: 14, label: 'A', alias: '1' }
        ];

        deck = [];
        for (let s of suits) {
            for (let r of ranks) {
                // æ„å»ºæœç´¢å…³é”®è¯
                // ç§»é™¤è‹±æ–‡å…¨ç§°(Spade, Heart...)ï¼Œå› ä¸ºå®ƒä»¬åŒ…å« 'a' ä¼šå¯¼è‡´æœç´¢ 'A' æ—¶åŒ¹é…æ‰€æœ‰ç‰Œ
                // ä¿ç•™: ç¬¦å·(â™ ), ç‚¹æ•°(A), ä¸­æ–‡(é»‘æ¡ƒ), ç®€å†™(s), åˆ«å(t, 1)
                let keys = [
                    `${s.symbol}${r.label}`, // â™ A
                    r.label,                 // A
                    s.chinese,               // é»‘æ¡ƒ
                    s.short,                 // s
                    s.short + r.label,       // sA
                    r.label + s.short        // As
                ];
                if (r.alias) keys.push(r.alias);

                deck.push({
                    suit: s.symbol,
                    rank: r.val,
                    rankLabel: r.label,
                    color: s.color,
                    fullName: `${s.symbol}${r.label}`,
                    searchKey: keys.join(' ').toLowerCase()
                });
            }
        }
    }

    function renderDropdowns() {
        for (let i = 1; i <= 5; i++) {
            const list = document.getElementById(`list${i}`);
            list.innerHTML = '';
            deck.forEach(card => {
                const option = document.createElement('div');
                option.className = 'card-option';
                option.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span>`;
                option.onclick = (e) => {
                    e.stopPropagation();
                    selectCard(i, card);
                };
                // Store card data for filtering
                option.dataset.search = card.searchKey;
                list.appendChild(option);
            });
        }
    }

    function toggleDropdown(index) {
        const dropdown = document.getElementById(`dropdown${index}`);
        const isVisible = dropdown.classList.contains('show');
        
        closeAllDropdowns();
        
        if (!isVisible) {
            dropdown.classList.add('show');
            // Focus search box
            const input = dropdown.querySelector('.search-box');
            input.value = '';
            filterCards(index); // Reset filter
            setTimeout(() => input.focus(), 50);
        }
    }

    function closeAllDropdowns() {
        document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
    }

    function selectCard(index, card) {
        selectedCards[index] = card;
        
        // Update trigger UI
        const trigger = document.getElementById(`trigger${index}`);
        trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> â–¾`;
        trigger.classList.add('filled');
        
        closeAllDropdowns();
        // updateTextInput(); // Removed
    }

    function updateTextInput() {
        // Removed
    }

    function filterCards(index) {
        const input = document.querySelector(`#dropdown${index} .search-box`);
        const filter = input.value.toLowerCase();
        const list = document.getElementById(`list${index}`);
        const options = list.getElementsByClassName('card-option');

        for (let option of options) {
            const txtValue = option.dataset.search;
            if (txtValue.indexOf(filter) > -1) {
                option.style.display = "";
            } else {
                option.style.display = "none";
            }
        }
    }

    let handHistory = [];
    let currentEditingId = null;

    function handleFileUpload(event) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        const file = event.target.files[0];
        if (!file) return;

        // Close modal immediately if file is selected (we will process it)
        // Actually, user might want to see the text area populated first?
        // Requirement: "å¦‚æœé€‰æ‹©æ–‡ä»¶å¯¼å…¥æˆåŠŸåè‡ªåŠ¨å…³é—­æ‰¹é‡å¯¼å…¥äºŒçº§æ¡†"
        // So we should close it AFTER success.
        // But here we just read file. The actual import happens in processBulkImport called by reader.onload.
        // Wait, my implementation of reader.onload calls processBulkImport() directly.
        // So processBulkImport will handle closing.

        const reader = new FileReader();
        
        if (file.name.endsWith('.csv')) {
            reader.onload = function(e) {
                const text = e.target.result;
                document.getElementById('bulkInput').value = text;
                processBulkImport(true); // Pass flag to indicate auto-import from file
            };
            reader.readAsText(file);
        } else {
            // Excel
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    
                    // Convert to JSON (array of arrays) to be safe
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                    
                    // Convert to Tab Separated Values for our existing parser
                    // Replace newlines in cell data with space to prevent line breaking
                    const tsv = jsonData.map(row => 
                        row.map(cell => {
                            if (typeof cell === 'string') {
                                return cell.replace(/[\n\r]+/g, ' ');
                            }
                            return cell;
                        }).join('\t')
                    ).join('\n');
                    
                    document.getElementById('bulkInput').value = tsv;
                    processBulkImport(true); // Pass flag to indicate auto-import from file
                } catch (err) {
                    alert('è¯»å–Excelæ–‡ä»¶å¤±è´¥: ' + err.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Reset file input so same file can be selected again if needed
        event.target.value = '';
    }

    function processBulkImport(isFromFile = false) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        
        // Snapshot current ranks before modification
        snapshotRanks();
        insertRankSnapshot('bulk', 'hand', '', 'æ‰¹é‡å¯¼å…¥æ‰‹ç‰Œ', { source: isFromFile ? 'file' : 'paste' });

        const input = document.getElementById('bulkInput').value.trim();
        if (!input) return;

        // Use a smarter split that respects quotes (standard CSV/TSV behavior) to handle multi-line fields in copy-paste scenarios
        // Regex: Split by newline if not followed by an odd number of quotes
        // But JS doesn't support variable length lookbehind, so we use lookahead for even quotes until end of string.
        // Actually, simple strategy: if a line has unclosed quote, merge with next.
        
        let rawLines = input.split(/\r?\n/);
        const lines = [];
        let currentLine = '';
        let inQuote = false;
        
        for (let line of rawLines) {
            // Count quotes in this line
            const quotes = (line.match(/"/g) || []).length;
            
            if (!inQuote) {
                if (quotes % 2 === 0) {
                    // Balanced, simple line
                    lines.push(line);
                } else {
                    // Unbalanced, start of multi-line
                    currentLine = line;
                    inQuote = true;
                }
            } else {
                currentLine += '\n' + line; // Restore newline
                if (quotes % 2 !== 0) {
                    // Found closing quote (odd number of quotes + previous odd = even)
                    lines.push(currentLine);
                    currentLine = '';
                    inQuote = false;
                }
                // If even quotes, we are still inside multiline quote
            }
        }
        if (currentLine) lines.push(currentLine); // Push remaining if any

        let successCount = 0;
        let errors = [];
        
        // é»˜è®¤åˆ—æ˜ å°„
        let colMap = { id: 0, team: 1, hand: 2 };
        let foundHeader = false;

        lines.forEach((line, index) => {
            line = line.trim();
            if (!line) return;
            
            // Handle CSV/TSV parsing manually to respect quotes
            let parts = [];
            
            if (line.includes('\t')) {
                parts = line.split('\t');
            } else {
                if (line.indexOf('"') === -1) {
                    parts = line.split(/[,ï¼Œ]/);
                } else {
                    parts = line.split(/[,ï¼Œ]/); // Simplified
                }
            }

            // Clean up parts
            parts = parts.map(p => {
                p = p.trim();
                if (p.startsWith('"') && p.endsWith('"')) {
                    p = p.slice(1, -1).replace(/""/g, '"');
                }
                return p;
            });

            parts = parts.map(p => p.replace(/[\n\r]+/g, ' '));
            
            // è¯†åˆ«è¡¨å¤´å¹¶åŠ¨æ€æ˜ å°„åˆ—
            if (index === 0) {
                let tempMap = {};
                let headerFound = false;
                
                parts.forEach((col, i) => {
                    const c = col.toLowerCase();
                    if (c.includes('åºå·') || c === 'id' || c === 'no') tempMap.id = i;
                    else if (c.includes('é˜Ÿä¼') || c.includes('team') || c === 'name') tempMap.team = i;
                    else if (c.includes('ç‰Œé¢') || c.includes('cards') || c === 'hand') tempMap.hand = i;
                });

                // å¦‚æœè‡³å°‘æ‰¾åˆ° åºå·+é˜Ÿä¼ æˆ– é˜Ÿä¼+ç‰Œé¢ï¼Œåˆ™è®¤ä¸ºæ˜¯è¡¨å¤´
                if ((tempMap.id !== undefined && tempMap.team !== undefined) || 
                    (tempMap.team !== undefined && tempMap.hand !== undefined)) {
                    
                    colMap = {
                        id: tempMap.id !== undefined ? tempMap.id : 0,
                        team: tempMap.team !== undefined ? tempMap.team : 1,
                        hand: tempMap.hand !== undefined ? tempMap.hand : 2
                    };
                    foundHeader = true;
                    return; // è·³è¿‡è¡¨å¤´
                }
                
                // å…¼å®¹æ—§é€»è¾‘ï¼ˆå¦‚æœæ²¡æœ‰ç²¾ç¡®åŒ¹é…ä½†çœ‹èµ·æ¥åƒè¡¨å¤´ï¼‰
                const firstCol = parts[0] || '';
                const secondCol = parts[1] || '';
                if (firstCol.includes('åºå·') || secondCol.includes('é˜Ÿä¼') || secondCol.includes('Team')) {
                    return; // è·³è¿‡è¡¨å¤´
                }
            }
            
            const maxIndex = Math.max(colMap.id, colMap.team, colMap.hand);
            if (parts.length <= maxIndex) {
                errors.push(`ç¬¬ ${index+1} è¡Œæ ¼å¼é”™è¯¯: åˆ—æ•°ä¸è¶³ (éœ€è‡³å°‘ ${maxIndex+1} åˆ—)`);
                return;
            }

            const serial = parts[colMap.id];
            const rawTeam = parts[colMap.team];
            let finalTeamName = rawTeam;
            
            // Validate against teamList if it has data
            if (teamList.length > 0) {
                const serialMatch = teamList.find(t => String(t.serial) === String(serial));
                
                if (serialMatch) {
                    // Found by serial - use the canonical name from the system
                    finalTeamName = serialMatch.name;
                } else {
                    // Serial not found in system
                    errors.push(`ç¬¬ ${index+1} è¡Œé”™è¯¯: åºå· ${serial} ä¸åœ¨é˜Ÿä¼ç®¡ç†åˆ—è¡¨ä¸­`);
                    return;
                }
            }
            
            let cardsStr = '';
            if (foundHeader) {
                cardsStr = parts[colMap.hand];
            } else {
                // å…¼å®¹æ—§æ¨¡å¼ï¼šå¦‚æœæ²¡æœ‰è¯†åˆ«åˆ°è¡¨å¤´ï¼Œå‡è®¾ä»ç¬¬3åˆ—å¼€å§‹éƒ½æ˜¯ç‰Œï¼ˆåº”å¯¹é€—å·åˆ†å‰²çš„æƒ…å†µï¼‰
                cardsStr = parts.slice(2).join(' ');
            }

            try {
                const cards = parseCards(cardsStr);
                const result = evaluateHand(cards);
                
                const newHand = {
                    id: Date.now().toString() + Math.random(), // Ensure unique ID
                    cards: cards,
                    serial: serial,
                    team: finalTeamName,
                    ...result
                };
                handHistory.push(newHand);
                successCount++;
            } catch (e) {
                errors.push(`ç¬¬ ${index+1} è¡Œ (${finalTeamName}) é”™è¯¯: ${e.message}`);
            }
        });

        // Re-sort and update table
        handHistory.sort((a, b) => b.score - a.score);
        updateTable();
        upsertHands(handHistory);
        
        // Show result
        if (errors.length > 0) {
            alert(`å¯¼å…¥å®Œæˆ: ${successCount} æˆåŠŸ\n\né”™è¯¯:\n${errors.join('\n')}`);
        } else {
            alert(`æˆåŠŸå¯¼å…¥ ${successCount} æ¡æ•°æ®`);
            document.getElementById('bulkInput').value = '';
            // Close modal if requested (e.g. from file upload) or always?
            // Requirement: "å¦‚æœé€‰æ‹©æ–‡ä»¶å¯¼å…¥æˆåŠŸåè‡ªåŠ¨å…³é—­"
            // Let's close it always on full success for better UX, or only if from file?
            // User said "å¦‚æœé€‰æ‹©æ–‡ä»¶å¯¼å…¥æˆåŠŸå...", implies manual paste might stay open?
            // But usually if success, closing is fine.
            // Let's stick to closing it always on full success as per previous implementation, 
            // but specifically ensure it handles the file upload case nicely.
            closeModal('importModal');
        }
    }

    function processHand() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        
        // Snapshot current ranks before modification
        snapshotRanks();
        insertRankSnapshot('single', 'hand', document.getElementById('serialInput').value.trim(), 'æ‰‹ç‰Œå½•å…¥', { team: document.getElementById('teamInput').value.trim(), mode: currentEditingId ? 'update' : 'insert' });

        const errorMsg = document.getElementById('errorMsg');
        // const inputVal = document.getElementById('cardInput').value.trim(); // Removed
        const serialVal = document.getElementById('serialInput').value.trim();
        const teamVal = document.getElementById('teamInput').value.trim();
        
        errorMsg.style.display = 'none';

        try {
            if (!serialVal) throw new Error("è¯·é€‰æ‹©åºå·");
            if (!teamVal) throw new Error("è¯·é€‰æ‹©é˜Ÿä¼åç§°");

            let currentHand = [];

            // Use dropdowns
            for (let i = 1; i <= 5; i++) {
                if (!selectedCards[i]) {
                    throw new Error(`è¯·é€‰æ‹©ç¬¬ ${i} å¼ ç‰Œ`);
                }
                currentHand.push(selectedCards[i]);
            }
            
            // Check duplicates
            const uniqueCheck = new Set(currentHand.map(c => c.suit + c.rank));
            if (uniqueCheck.size !== 5) {
                throw new Error("ç‰Œé¢é‡å¤ï¼Œè¯·æ£€æŸ¥");
            }
            
            const result = evaluateHand(currentHand);
            
            if (currentEditingId) {
                // Update existing
                const index = handHistory.findIndex(h => h.id === currentEditingId);
                if (index !== -1) {
                    handHistory[index] = {
                        ...handHistory[index],
                        cards: currentHand,
                        serial: serialVal,
                        team: teamVal,
                        ...result
                    };
                }
                cancelEdit(); // Reset UI
            } else {
                const newHand = { id: Date.now().toString(), cards: currentHand, serial: serialVal, team: teamVal, ...result };
                handHistory.push(newHand);
                upsertHands([newHand]);
            }

            // æ’åºï¼šåˆ†æ•°ä»é«˜åˆ°ä½
            handHistory.sort((a, b) => b.score - a.score);

            updateTable();
            
            // Clear inputs if not editing (if editing, cancelEdit already cleared)
            if (!currentEditingId) {
                // document.getElementById('cardInput').value = ''; // Removed
                document.getElementById('serialInput').value = '';
                document.getElementById('teamInput').value = '';
                // Clear dropdowns
                for (let i = 1; i <= 5; i++) {
                     selectedCards[i] = null;
                     const trigger = document.getElementById(`trigger${i}`);
                     trigger.innerHTML = `... â–¾`;
                     trigger.classList.remove('filled');
                }
            }
            
        } catch (e) {
            errorMsg.textContent = e.message;
            errorMsg.style.display = 'block';
        }
    }
    
    function parseCards(input) {
        // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…æ‰€æœ‰å¯èƒ½çš„ç‰Œç»„åˆ
        // Suits: â™ â™¥â™£â™¦sShHcCdD
        // Ranks: 10, 2-9, tTjJqQkKaA, 1
        const suitRegex = "[â™ â™¥â™£â™¦sShHcCdD]";
        const rankRegex = "(?:10|[2-9]|[tTjJqQkKaA]|1)";
        
        // æ¨¡å¼1: èŠ±è‰² + ç‚¹æ•° (ä¾‹å¦‚: â™ A, s10)
        // æ¨¡å¼2: ç‚¹æ•° + èŠ±è‰² (ä¾‹å¦‚: As, 10s)
        const cardRegex = new RegExp(`(${suitRegex}${rankRegex})|(${rankRegex}${suitRegex})`, 'g');
        
        const parts = input.match(cardRegex) || [];
        
        if (parts.length !== 5) {
             throw new Error(`å¿…é¡»è¾“å…¥5å¼ ç‰Œï¼Œå½“å‰è¯†åˆ«åˆ° ${parts.length} å¼ `);
        }

        const parsedCards = [];
        
        // Helper to find card in deck
        const findCard = (suitChar, rankStr) => {
             // Normalize suitChar to standard symbol or match deck properties
             // rankStr could be '10', 'A', 't', etc.
             
             // Map input suit to deck suit symbol
             const suitMap = {
                 's': 'â™ ', 'S': 'â™ ', 'â™ ': 'â™ ',
                 'h': 'â™¥', 'H': 'â™¥', 'â™¥': 'â™¥',
                 'c': 'â™£', 'C': 'â™£', 'â™£': 'â™£',
                 'd': 'â™¦', 'D': 'â™¦', 'â™¦': 'â™¦'
             };
             
             const targetSuit = suitMap[suitChar];
             if (!targetSuit) return null;

             // Map rank string to value/label
             const rankMap = {
                 '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                 't': 10, 'T': 10,
                 'j': 11, 'J': 11,
                 'q': 12, 'Q': 12,
                 'k': 13, 'K': 13,
                 'a': 14, 'A': 14, '1': 14
             };
             const targetRankVal = rankMap[rankStr];
             if (!targetRankVal) return null;

             return deck.find(c => c.suit === targetSuit && c.rank === targetRankVal);
        };

        for (let part of parts) {
            let suitChar = '';
            let rankStr = '';
            
            // Regex: Suit first or Rank first
            // Suit: [â™ â™¥â™£â™¦sShHcCdD]
            // Rank: [2-9]|10|[tTjJqQkKaA]|1
            
            const matchPrefix = part.match(/^([â™ â™¥â™£â™¦sShHcCdD])([2-9]|10|[tTjJqQkKaA]|1)$/);
            const matchSuffix = part.match(/^([2-9]|10|[tTjJqQkKaA]|1)([â™ â™¥â™£â™¦sShHcCdD])$/);

            if (matchPrefix) {
                suitChar = matchPrefix[1];
                rankStr = matchPrefix[2];
            } else if (matchSuffix) {
                rankStr = matchSuffix[1];
                suitChar = matchSuffix[2];
            } else {
                throw new Error(`æ— æ³•è¯†åˆ«çš„ç‰Œ: ${part}`);
            }

            const card = findCard(suitChar, rankStr);
            if (!card) {
                throw new Error(`æ— æ³•è¯†åˆ«çš„ç‰Œ: ${part}`);
            }
            parsedCards.push(card);
        }
        return parsedCards;
    }

    function evaluateHand(cards) {
        // æ’åºç‰Œé¢ (ä»å¤§åˆ°å°)
        const sortedCards = [...cards].sort((a, b) => b.rank - a.rank);
        const ranks = sortedCards.map(c => c.rank);
        const suits = sortedCards.map(c => c.suit);

        // æ£€æŸ¥åŒèŠ±
        const isFlush = suits.every(s => s === suits[0]);

        // æ£€æŸ¥é¡ºå­
        let isStraight = true;
        for (let i = 0; i < 4; i++) {
            if (ranks[i] - ranks[i+1] !== 1) {
                isStraight = false;
                break;
            }
        }
        // ç‰¹æ®Šæƒ…å†µ: A-5-4-3-2 (A=14, 2=2)
        // æ­¤æ—¶ ranks æ˜¯ [14, 5, 4, 3, 2]
        if (!isStraight && ranks[0] === 14 && ranks[1] === 5 && ranks[2] === 4 && ranks[3] === 3 && ranks[4] === 2) {
            isStraight = true;
            // ä¸ºäº†æ¯”è¾ƒå¤§å°ï¼Œè¿™é‡ŒæŠŠå®ƒå½“ä½œ 5-high straight
            // ä½†æ˜¯åœ¨åˆ†æ•°è®¡ç®—æ—¶éœ€è¦ç‰¹æ®Šå¤„ç†ï¼ŒæŠŠAå½“ä½œ1æ¥å¤„ç†
        }

        // ç»Ÿè®¡ç‚¹æ•°é¢‘ç‡
        const rankCounts = {};
        ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
        
        // è·å–å››æ¡ã€ä¸‰æ¡ã€å¯¹å­
        const counts = Object.values(rankCounts);
        const isFourOfAKind = counts.includes(4);
        const isThreeOfAKind = counts.includes(3);
        const pairCount = counts.filter(c => c === 2).length;

        let handTypeIndex = 0; // 0-9, å¯¹åº” HAND_TYPES ç´¢å¼•
        let score = 0;

        // è®¡ç®—åŸºç¡€åˆ†æ•° (Base Score)
        // æ¯ä¸€çº§ç›¸å·® 1,000,000,000 (10^9) ä¿è¯çº§åˆ«å‹åˆ¶
        // çº§åˆ«å†…æ¯”è¾ƒä½¿ç”¨ HEX ç±»ä¼¼æ€æƒ³: 
        // c1*16^4 + c2*16^3 + ...
        // è¿™é‡Œç®€å•ç”¨ 100è¿›åˆ¶

        const getKickersValue = (cardRanks) => {
            let val = 0;
            let power = 1;
            for (let i = cardRanks.length - 1; i >= 0; i--) {
                val += cardRanks[i] * power;
                power *= 100;
            }
            return val;
        };

        if (isFlush && isStraight) {
            if (ranks[0] === 14 && ranks[1] === 13) { // Royal Flush
                handTypeIndex = 9;
                score = 9 * 10000000000;
            } else { // Straight Flush
                handTypeIndex = 8;
                // å¤„ç† A-5-4-3-2 çš„æƒ…å†µï¼Œæ­¤æ—¶æœ€å¤§ç‰Œæ˜¯ 5
                let highRank = ranks[0];
                if (ranks[0] === 14 && ranks[4] === 2) highRank = 5;
                score = 8 * 10000000000 + highRank;
            }
        } else if (isFourOfAKind) {
            handTypeIndex = 7;
            const quadRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 4));
            const kicker = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 1));
            score = 7 * 10000000000 + quadRank * 100 + kicker;
        } else if (isThreeOfAKind && pairCount === 1) { // Full House
            handTypeIndex = 6;
            const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
            const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
            score = 6 * 10000000000 + tripRank * 100 + pairRank;
        } else if (isFlush) {
            handTypeIndex = 5;
            score = 5 * 10000000000 + getKickersValue(ranks);
        } else if (isStraight) {
            handTypeIndex = 4;
            let highRank = ranks[0];
            if (ranks[0] === 14 && ranks[4] === 2) highRank = 5;
            score = 4 * 10000000000 + highRank;
        } else if (isThreeOfAKind) {
            handTypeIndex = 3;
            const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
            const kickers = ranks.filter(r => r !== tripRank);
            score = 3 * 10000000000 + tripRank * 10000 + getKickersValue(kickers);
        } else if (pairCount === 2) {
            handTypeIndex = 2;
            const pairs = Object.keys(rankCounts).filter(key => rankCounts[key] === 2).map(Number).sort((a,b) => b-a);
            const kicker = ranks.find(r => !pairs.includes(r));
            score = 2 * 10000000000 + pairs[0] * 10000 + pairs[1] * 100 + kicker;
        } else if (pairCount === 1) {
            handTypeIndex = 1;
            const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
            const kickers = ranks.filter(r => r !== pairRank);
            score = 1 * 10000000000 + pairRank * 1000000 + getKickersValue(kickers);
        } else {
            handTypeIndex = 0;
            score = getKickersValue(ranks);
        }

        return {
            handTypeName: HAND_TYPES[handTypeIndex].name,
            score: score
        };
    }

    function editEntry(id) {
        const entry = handHistory.find(h => h.id === id);
        if (!entry) return;

        currentEditingId = id;
        
        // Populate inputs
        document.getElementById('serialInput').value = entry.serial;
        document.getElementById('teamInput').value = entry.team;
        
        // Populate cards
        entry.cards.forEach((card, i) => {
             selectedCards[i+1] = card;
             const trigger = document.getElementById(`trigger${i+1}`);
             trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> â–¾`;
             trigger.classList.add('filled');
        });
        // updateTextInput(); // Removed

        // Update UI state
        document.getElementById('actionBtn').textContent = 'æ›´æ–°';
        document.getElementById('actionBtn').style.backgroundColor = 'var(--xmas-light-green)';
        document.getElementById('cancelBtn').style.display = 'inline-block';
        
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function deleteHand(id) {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        
        const hand = handHistory.find(h => h.id === id);
        if (!hand) return;

        if (confirm(`ç¡®å®šåˆ é™¤é˜Ÿä¼ "${hand.team}" (åºå·: ${hand.serial}) çš„æ‰‹ç‰Œè®°å½•å—ï¼Ÿ`)) {
            // Snapshot current ranks before modification
            snapshotRanks();
            insertRankSnapshot('single', 'hand', hand.serial, 'åˆ é™¤æ‰‹ç‰Œ', { handId: id, cards: hand.cards });

            handHistory = handHistory.filter(h => h.id !== id);
            
            deleteHandsInCloud(hand.serial);
            
            updateTable();
        }
    }

    function cancelEdit() {
        currentEditingId = null;
        
        // Clear inputs
        document.getElementById('serialInput').value = '';
        document.getElementById('teamInput').value = '';
        // document.getElementById('cardInput').value = ''; // Removed
        
        // Clear dropdowns
        for (let i = 1; i <= 5; i++) {
             selectedCards[i] = null;
             const trigger = document.getElementById(`trigger${i}`);
             trigger.innerHTML = `... â–¾`;
             trigger.classList.remove('filled');
        }

        // Reset UI state
        document.getElementById('actionBtn').textContent = 'è®¡ç®— & æ’å';
        document.getElementById('actionBtn').style.backgroundColor = 'var(--xmas-green)';
        document.getElementById('cancelBtn').style.display = 'none';
        document.getElementById('errorMsg').style.display = 'none';
    }

    function clearData() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
            handHistory = [];
            if (supabaseClient && currentYear) supabaseClient.from('hands').delete().eq('year', currentYear);
            cancelEdit();
            updateTable();
        }
    }

    function updateTable() {
        const tbody = document.querySelector('#rankingTable tbody');
        tbody.innerHTML = '';

        let effectiveRank = 1;

        handHistory.forEach((entry, index) => {
            const tr = document.createElement('tr');
            
            // Determine effective rank (handle ties)
            if (index > 0 && entry.score === handHistory[index-1].score) {
                // Tie with previous: effectiveRank remains unchanged
            } else {
                // No tie: effectiveRank is the current position
                effectiveRank = index + 1;
            }

            // æ’å
            const tdRank = document.createElement('td');
            tdRank.innerHTML = `${effectiveRank}${getRankChangeHtml(entry.serial, effectiveRank, 'hand')}`;
            tr.appendChild(tdRank);
            
            // åºå·
            const tdSerial = document.createElement('td');
            tdSerial.textContent = entry.serial;
            tr.appendChild(tdSerial);
            
            // é˜Ÿä¼åç§°
            const tdTeam = document.createElement('td');
            if (isImage(entry.team)) {
                const img = document.createElement('img');
                img.src = entry.team;
                img.style.height = '30px';
                tdTeam.appendChild(img);
            } else {
                tdTeam.textContent = entry.team;
            }
            tr.appendChild(tdTeam);

            // ç‰Œå‹åç§°
            const tdType = document.createElement('td');
            tdType.textContent = entry.handTypeName;
            tr.appendChild(tdType);

            // ç‰Œé¢
            const tdCards = document.createElement('td');
            entry.cards.forEach(card => {
                const span = document.createElement('span');
                span.className = `card ${card.color === 'red' ? 'suit-red' : 'suit-black'}`;
                span.textContent = `${card.suit}${card.rankLabel}`;
                tdCards.appendChild(span);
            });
            tr.appendChild(tdCards);

            // ç§¯åˆ†
            const tdPoints = document.createElement('td');
            // Points calculation based on effective rank
            // Rank 1 gets totalTeams points
            // Rank N gets totalTeams - N + 1 points
            const points = totalTeams - effectiveRank + 1;
            
            tdPoints.textContent = points;
            tdPoints.style.fontWeight = 'bold';
            tdPoints.style.color = points > 0 ? 'var(--xmas-green)' : 'var(--xmas-red)';
            tr.appendChild(tdPoints);

            // åˆ†æ•° (Debugç”¨ï¼Œä¹Ÿå¯ä»¥æ˜¾ç¤º)
            const tdScore = document.createElement('td');
            tdScore.textContent = entry.score.toLocaleString();
            tr.appendChild(tdScore);
            
            // æ“ä½œ
            if (isAdmin) {
                const tdAction = document.createElement('td');
                
                const editBtn = document.createElement('button');
                editBtn.textContent = 'ç¼–è¾‘';
                editBtn.style.padding = '5px 10px';
                editBtn.style.fontSize = '12px';
                editBtn.style.marginRight = '5px';
                editBtn.onclick = () => editEntry(entry.id);
                tdAction.appendChild(editBtn);

                const delBtn = document.createElement('button');
                delBtn.textContent = 'åˆ é™¤';
                delBtn.className = 'btn-danger';
                delBtn.style.padding = '5px 10px';
                delBtn.style.fontSize = '12px';
                delBtn.onclick = () => deleteHand(entry.id);
                tdAction.appendChild(delBtn);

                tr.appendChild(tdAction);
            }

            tbody.appendChild(tr);
        });
    }

    function exportRanking() {
        if (handHistory.length === 0) {
            alert('æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
            return;
        }

        // Prepare data for export
        let effectiveRank = 1;
        const data = handHistory.map((entry, index) => {
            // Determine effective rank (handle ties)
            if (index > 0 && entry.score === handHistory[index-1].score) {
                // Tie: effectiveRank remains unchanged
            } else {
                effectiveRank = index + 1;
            }

            const points = totalTeams - effectiveRank + 1;
            
            // æ ¼å¼åŒ–ç‰Œé¢å­—ç¬¦ä¸²ï¼Œç§»é™¤é¢œè‰²æ ‡è®°ï¼Œçº¯æ–‡æœ¬
            const cardStr = entry.cards.map(c => `${c.suit}${c.rankLabel}`).join(' ');
            
            return {
                "æ’å": effectiveRank,
                "åºå·": entry.serial,
                "é˜Ÿä¼åç§°": isImage(entry.team) ? "[å›¾ç‰‡é˜Ÿä¼]" : entry.team,
                "ç‰Œå‹åç§°": entry.handTypeName,
                "ç‰Œé¢": cardStr,
                "ç§¯åˆ†": points,
                "åˆ†æ•°": entry.score
            };
        });

        // Create worksheet
        const ws = XLSX.utils.json_to_sheet(data);
        
        // Adjust column widths
        const wscols = [
            {wch: 6},  // æ’å
            {wch: 10}, // åºå·
            {wch: 20}, // é˜Ÿä¼åç§°
            {wch: 20}, // ç‰Œå‹åç§°
            {wch: 25}, // ç‰Œé¢
            {wch: 8},  // ç§¯åˆ†
            {wch: 15}  // åˆ†æ•°
        ];
        ws['!cols'] = wscols;

        // Create workbook
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "æ’è¡Œæ¦œ");

        // Generate filename with timestamp
        const date = new Date();
        const dateStr = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        const timeStr = `${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}`;
        const filename = `å¾·å·æ‰‘å…‹æ’è¡Œæ¦œ_${dateStr}_${timeStr}.xlsx`;

        // Export
        try {
            XLSX.writeFile(wb, filename);
        } catch (e) {
            alert('å¯¼å‡ºå¤±è´¥: ' + e.message);
        }
    }

    // Rank Change Tracking Helpers
    let isInitialLoad = true;

    function calculateHandRanks() {
        const ranks = {};
        // Use logic identical to updateTable sorting
        const sorted = [...handHistory].sort((a, b) => b.score - a.score);
        let rank = 1;
        sorted.forEach((h, i) => {
            if (i > 0 && h.score === sorted[i-1].score) {
                // Tie
            } else {
                rank = i + 1;
            }
            ranks[h.serial] = rank;
        });
        return ranks;
    }

    function calculateWishRanks() {
        const ranks = {};
        const sorted = [...wishList].sort((a, b) => b.total - a.total);
        let rank = 1;
        sorted.forEach((w, i) => {
            if (i > 0 && w.total === sorted[i-1].total) {
            } else {
                rank = i + 1;
            }
            ranks[w.serial] = rank;
        });
        return ranks;
    }

    function calculateFinalRanks() {
        const ranks = {};
        // Note: getFinalRankingData relies on current wishList/handHistory states
        const data = getFinalRankingData(); 
        data.forEach(item => {
            ranks[item.serial] = item.rank;
        });
        return ranks;
    }

    function snapshotRanks() {
        previousRanks.hand = calculateHandRanks();
        previousRanks.wish = calculateWishRanks();
        previousRanks.final = calculateFinalRanks();
    }

    function getRankChangeHtml(serial, currentRank, type) {
        // Use persisted baseline if available
        if (!rankBaseline || !rankBaseline[type] || Object.keys(rankBaseline[type]).length === 0) return '';
        const prevRank = rankBaseline[type][serial];
        if (prevRank === undefined) {
            // New Entry - Display below number
            return '<div style="font-size:11px; color:var(--xmas-red); font-weight:bold; margin-top:2px; line-height: 1;">æ–°è¿›æ¦œ</div>';
        }
        
        if (prevRank === currentRank) {
            return '<span style="font-size:12px; color:#aaa; margin-left:5px;">-</span>';
        }
        
        const diff = prevRank - currentRank; // Positive means rank improved (e.g. 5 -> 1, diff 4)
        if (diff > 0) {
            return `<span style="font-size:12px; color:var(--xmas-red); font-weight:bold; margin-left:5px;">â†‘${diff}</span>`;
        } else {
            return `<span style="font-size:12px; color:var(--xmas-green); font-weight:bold; margin-left:5px;">â†“${Math.abs(diff)}</span>`;
        }
    }

    // Rank Change Logs (Snapshots & Computed)
    async function insertRankSnapshot(opType, refType, refIdentifier, summary, details) {
        try {
            if (!supabaseClient || !currentYear) return;
            const row = {
                year: currentYear,
                operation_type: opType,
                ref_type: refType,
                ref_identifier: String(refIdentifier || ''),
                operator: isAdmin ? 'admin' : 'user',
                status: 'snapshot',
                summary: summary || '',
                details: details || {},
                pre_hand_ranks: previousRanks.hand,
                pre_wish_ranks: previousRanks.wish,
                pre_final_ranks: previousRanks.final
            };
            await supabaseClient.from('rank_change_logs').insert(row);
        } catch (e) {
            console.warn('insertRankSnapshot failed', e);
        }
    }

    async function computeRankChange(logId) {
        try {
            if (!supabaseClient || !currentYear) return;
            const { data, error } = await supabaseClient.from('rank_change_logs').select('*').eq('id', logId).single();
            if (error || !data) { alert('æ— æ³•è¯»å–è®°å½•'); return; }

            const postHand = calculateHandRanks();
            const postWish = calculateWishRanks();
            const postFinal = calculateFinalRanks();

            function buildDiff(pre, post) {
                const serials = new Set([...Object.keys(pre||{}), ...Object.keys(post||{})]);
                const changes = [];
                serials.forEach(s => {
                    const a = pre ? pre[s] : undefined;
                    const b = post ? post[s] : undefined;
                    if (a === undefined && b === undefined) return;
                    if (a === b) return;
                    changes.push({ serial: s, from: a ?? null, to: b ?? null, delta: (a!=null && b!=null) ? a - b : null });
                });
                return changes.sort((x,y)=>{
                    const dx = (x.delta==null)?0:Math.abs(x.delta);
                    const dy = (y.delta==null)?0:Math.abs(y.delta);
                    return dy - dx;
                });
            }

            const diff = {
                hand: buildDiff(data.pre_hand_ranks, postHand),
                wish: buildDiff(data.pre_wish_ranks, postWish),
                final: buildDiff(data.pre_final_ranks, postFinal),
                summary: {
                    hand_changed: (buildDiff(data.pre_hand_ranks, postHand)).length,
                    wish_changed: (buildDiff(data.pre_wish_ranks, postWish)).length,
                    final_changed: (buildDiff(data.pre_final_ranks, postFinal)).length
                }
            };

            await supabaseClient.from('rank_change_logs').update({
                status: 'computed',
                post_hand_ranks: postHand,
                post_wish_ranks: postWish,
                post_final_ranks: postFinal,
                diff: diff
            }).eq('id', logId);

            renderRankChangeTab();
        } catch (e) {
            alert('è®¡ç®—å¤±è´¥: ' + e.message);
        }
    }

    async function renderRankChangeTab() {
        const container = document.getElementById('rankChangeContainer');
        if (!container) return;
        container.innerHTML = '';
        
        if (!supabaseClient || !currentYear) { container.textContent = 'æœªè¿æ¥æ•°æ®åº“æˆ–æœªé€‰æ‹©å¹´ä»½'; return; }
        
        const { data: snapshots } = await supabaseClient.from('rank_change_logs').select('*').eq('year', currentYear).eq('status', 'snapshot').order('created_at', { ascending: false });
        const { data: computed } = await supabaseClient.from('rank_change_logs').select('*').eq('year', currentYear).eq('status', 'computed').order('created_at', { ascending: false });

        const snapSection = document.createElement('div');
        snapSection.innerHTML = `<h3 style="color: var(--xmas-green);">å¾…è®¡ç®—è®°å½•</h3>`;
        const snapTable = document.createElement('table');
        snapTable.className = 'team-list-table';
        snapTable.innerHTML = `
            <thead><tr>
                <th style="width:160px;">æ—¶é—´</th>
                <th style="width:80px;">ç±»å‹</th>
                <th style="width:100px;">å…³è”</th>
                <th>æ‘˜è¦</th>
                <th style="width:120px;">æ“ä½œ</th>
            </tr></thead>
            <tbody></tbody>`;
        const snapTbody = snapTable.querySelector('tbody');
        (snapshots||[]).forEach(row => {
            const tr = document.createElement('tr');
            const brief = (row.operation_type === 'bulk') ? 'æ‰¹é‡æ“ä½œ(ç‚¹å‡»è®¡ç®—æŸ¥çœ‹è¯¦æƒ…)' : (row.summary || 'å•æ¡ç¼–è¾‘');
            tr.innerHTML = `
                <td>${new Date(row.created_at).toLocaleString()}</td>
                <td>${row.operation_type}</td>
                <td>${row.ref_type || ''} ${row.ref_identifier || ''}</td>
                <td>${brief}</td>
            `;
            const tdOp = document.createElement('td');
            const btn = document.createElement('button');
            btn.textContent = 'è®¡ç®—æ’åå˜åŒ–';
            btn.className = 'btn-secondary';
            btn.onclick = () => computeRankChange(row.id);
            tdOp.appendChild(btn);
            tr.appendChild(tdOp);
            snapTbody.appendChild(tr);
        });
        snapSection.appendChild(snapTable);
        container.appendChild(snapSection);

        const compSection = document.createElement('div');
        compSection.innerHTML = `<h3 style="color: var(--xmas-green);">è®¡ç®—ç»“æœè®°å½•</h3>`;
        const compTable = document.createElement('table');
        compTable.className = 'team-list-table';
        compTable.innerHTML = `
            <thead><tr>
                <th style="width:160px;">æ—¶é—´</th>
                <th style="width:80px;">ç±»å‹</th>
                <th style="width:100px;">å…³è”</th>
                <th>æ‘˜è¦</th>
                <th style="width:240px;">å˜åŒ–ç»Ÿè®¡</th>
                <th style="width:120px;">è¯¦æƒ…</th>
            </tr></thead>
            <tbody></tbody>`;
        const compTbody = compTable.querySelector('tbody');
        (computed||[]).forEach(row => {
            const tr = document.createElement('tr');
            const stats = row.diff && row.diff.summary ? row.diff.summary : { hand_changed: 0, wish_changed: 0, final_changed: 0 };
            tr.innerHTML = `
                <td>${new Date(row.created_at).toLocaleString()}</td>
                <td>${row.operation_type}</td>
                <td>${row.ref_type || ''} ${row.ref_identifier || ''}</td>
                <td>${row.summary || ''}</td>
                <td>æ‰‹ç‰Œ:${stats.hand_changed} / å¿ƒæ„¿:${stats.wish_changed} / æ€»æ¦œ:${stats.final_changed}</td>
            `;
            const tdDetail = document.createElement('td');
            const btn = document.createElement('button');
            btn.textContent = 'æ˜¾ç¤ºè¯¦ç»†';
            btn.className = 'btn-secondary';
            const detailDiv = document.createElement('div');
            detailDiv.style.display = 'none';
            detailDiv.style.padding = '10px';
            detailDiv.style.background = '#fff';
            detailDiv.style.border = '1px solid #eee';
            detailDiv.style.marginTop = '8px';
            function renderList(title, list) {
                const wrap = document.createElement('div');
                const h = document.createElement('div'); h.textContent = title; h.style.fontWeight = 'bold'; h.style.marginBottom = '6px';
                wrap.appendChild(h);
                (list||[]).forEach(it => {
                    const p = document.createElement('div');
                    p.textContent = `åºå· ${it.serial}: ${it.from ?? '-'} => ${it.to ?? '-'} (${it.delta==null?'-':(it.delta>0?('â†‘'+it.delta):('â†“'+Math.abs(it.delta)))})`;
                    wrap.appendChild(p);
                });
                return wrap;
            }
            detailDiv.appendChild(renderList('æ‰‹ç‰Œå˜åŒ–', row.diff ? row.diff.hand : []));
            detailDiv.appendChild(renderList('å¿ƒæ„¿å˜åŒ–', row.diff ? row.diff.wish : []));
            detailDiv.appendChild(renderList('æœ€ç»ˆæ¦œå˜åŒ–', row.diff ? row.diff.final : []));
            btn.onclick = () => { detailDiv.style.display = (detailDiv.style.display==='none') ? 'block' : 'none'; };
            tdDetail.appendChild(btn);
            tdDetail.appendChild(detailDiv);
            tr.appendChild(tdDetail);
            const trWrap = document.createElement('tr');
            compTbody.appendChild(tr);
        });
        compSection.appendChild(compTable);
        container.appendChild(compSection);
    }

    // --- Batch Wish Functions (Appended/Redefined) ---
    let currentEditingWishSerial = null;

    function addWishRow(data = null) {
        const container = document.getElementById('wishRowsContainer');
        if (!container) return;
        
        const rowId = 'wish_row_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        const div = document.createElement('div');
        div.className = 'wish-row';
        div.id = rowId;
        div.style.borderBottom = '1px dashed #ccc';
        div.style.paddingBottom = '10px';
        div.style.marginBottom = '10px';
        
        const serial = data ? data.serial : '';
        const teamName = data ? data.team : '';
        const w1 = data ? (data.wishes[0] || '') : '';
        const w2 = data ? (data.wishes[1] || '') : '';
        const w3 = data ? (data.wishes[2] || '') : '';
        const w4 = data ? (data.wishes[3] || '') : '';
        const w5 = data ? (data.wishes[4] || '') : '';

        let serialOptions = '<option value="">åºå·</option>';
        let teamOptions = '<option value="">é˜Ÿä¼åç§°</option>';
        
        const sortedList = [...teamList].sort((a, b) => {
            const na = parseInt(a.serial);
            const nb = parseInt(b.serial);
            if (!isNaN(na) && !isNaN(nb)) return na - nb;
            return String(a.serial).localeCompare(String(b.serial));
        });

        sortedList.forEach(t => {
            serialOptions += `<option value="${t.serial}" ${t.serial == serial ? 'selected' : ''}>${t.serial}</option>`;
            teamOptions += `<option value="${t.name}" ${t.name == teamName ? 'selected' : ''}>${isImage(t.name) ? `åºå· ${t.serial} - [å›¾ç‰‡é˜Ÿä¼]` : t.name}</option>`;
        });

        div.innerHTML = `
            <div class="input-group" style="margin-bottom: 10px; width: 100%; display: flex; gap: 10px; align-items: center;">
                <select class="wish-serial" style="width: 120px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; background-color: white;" onchange="syncWishInput('${rowId}', 'serial')">
                    ${serialOptions}
                </select>
                <select class="wish-team" style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px; background-color: white;" onchange="syncWishInput('${rowId}', 'team')">
                    ${teamOptions}
                </select>
                <button onclick="removeWishRow('${rowId}')" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">åˆ é™¤</button>
            </div>
            <div class="input-group" style="margin-bottom: 5px; width: 100%; display: flex; gap: 10px; flex-wrap: wrap;">
                <input type="number" class="wish-val w1" placeholder="1é¢—" value="${w1}" style="flex: 1; min-width: 80px; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <input type="number" class="wish-val w2" placeholder="2é¢—" value="${w2}" style="flex: 1; min-width: 80px; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <input type="number" class="wish-val w3" placeholder="3é¢—" value="${w3}" style="flex: 1; min-width: 80px; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <input type="number" class="wish-val w4" placeholder="4é¢—" value="${w4}" style="flex: 1; min-width: 80px; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <input type="number" class="wish-val w5" placeholder="5é¢—" value="${w5}" style="flex: 1; min-width: 80px; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
            </div>
        `;
        
        container.appendChild(div);
    }

    function removeWishRow(rowId) {
        const row = document.getElementById(rowId);
        if (row) row.remove();
    }

    function syncWishInput(rowId, source) {
        const row = document.getElementById(rowId);
        if (!row) return;
        
        const serialSelect = row.querySelector('.wish-serial');
        const teamSelect = row.querySelector('.wish-team');
        
        if (source === 'serial') {
            const selectedSerial = serialSelect.value;
            const team = teamList.find(t => t.serial === selectedSerial);
            if (team) teamSelect.value = team.name;
            else teamSelect.value = "";
        } else {
            const selectedTeam = teamSelect.value;
            const team = teamList.find(t => t.name === selectedTeam);
            if (team) serialSelect.value = team.serial;
            else serialSelect.value = "";
        }
    }

    function editWish(serial) {
        const wish = wishList.find(w => w.serial === serial);
        if (!wish) return;
        
        currentEditingWishSerial = serial;
        
        const container = document.getElementById('wishRowsContainer');
        container.innerHTML = '';
        
        addWishRow(wish);
        
        document.getElementById('saveWishBtn').textContent = 'æ›´æ–°æ•°æ®';
        document.getElementById('cancelWishEditBtn').style.display = 'inline-block';
        
        // Scroll to form
        const form = document.getElementById('wishFormSection');
        if (form) form.scrollIntoView({ behavior: 'smooth' });
    }

    function cancelWishEdit() {
        currentEditingWishSerial = null;
        
        const container = document.getElementById('wishRowsContainer');
        container.innerHTML = '';
        addWishRow();
        
        document.getElementById('saveWishBtn').textContent = 'æ‰¹é‡ä¿å­˜';
        document.getElementById('cancelWishEditBtn').style.display = 'none';
    }

    function saveAllWishes() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        
        const rows = document.querySelectorAll('.wish-row');
        if (rows.length === 0) return;
        
        let newWishes = [];
        let errors = [];
        
        rows.forEach((row, index) => {
            const serial = row.querySelector('.wish-serial').value;
            const teamName = row.querySelector('.wish-team').value;
            
            if (!serial || !teamName) {
                const inputs = row.querySelectorAll('.wish-val');
                let hasVal = false;
                inputs.forEach(inp => { if (inp.value) hasVal = true; });
                if (!hasVal && !serial && !teamName) return; 
                errors.push(`ç¬¬ ${index + 1} è¡Œï¼šè¯·é€‰æ‹©é˜Ÿä¼`);
                return;
            }
            
            const w1 = parseInt(row.querySelector('.w1').value) || 0;
            const w2 = parseInt(row.querySelector('.w2').value) || 0;
            const w3 = parseInt(row.querySelector('.w3').value) || 0;
            const w4 = parseInt(row.querySelector('.w4').value) || 0;
            const w5 = parseInt(row.querySelector('.w5').value) || 0;
            
            const total = w1 + w2 + w3 + w4 + w5;
            
            newWishes.push({
                serial, team: teamName, wishes: [w1, w2, w3, w4, w5], total
            });
        });
        
        if (errors.length > 0) {
            alert(errors.join('\n'));
            return;
        }
        
        if (newWishes.length === 0) {
            alert('æ²¡æœ‰æœ‰æ•ˆæ•°æ®');
            return;
        }
        
        if (currentEditingWishSerial) {
             const wishData = newWishes[0];
             snapshotRanks();
             insertRankSnapshot('single', 'wish', wishData.serial, 'æ›´æ–°å¿ƒæ„¿', { team: wishData.team });
             const index = wishList.findIndex(w => w.serial === wishData.serial);
             if (index !== -1) wishList[index] = wishData;
             else wishList.push(wishData);
             upsertWishes([wishData]);
             cancelWishEdit();
             alert('æ›´æ–°æˆåŠŸ');
        } else {
             snapshotRanks();
             insertRankSnapshot('batch', 'wish', 'batch', 'æ‰¹é‡å½•å…¥å¿ƒæ„¿', { count: newWishes.length });
             newWishes.forEach(wishData => {
                 const index = wishList.findIndex(w => w.serial === wishData.serial);
                 if (index !== -1) wishList[index] = wishData;
                 else wishList.push(wishData);
             });
             upsertWishes(newWishes);
             document.getElementById('wishRowsContainer').innerHTML = '';
             addWishRow();
             alert(`æˆåŠŸä¿å­˜ ${newWishes.length} æ¡å¿ƒæ„¿è®°å½•`);
        }
        renderWishRanking();
    }
    
    // Auto-init
    setTimeout(addWishRow, 1000);

    // --- Batch Hand Calculation Functions (Appended/Redefined) ---
    
    // Global state for batch rows
    let handRowsData = {}; // { rowId: { selectedCards: {1:null, 2:null...} } }
    let currentEditingHandId = null;

    function addHandRow(data = null) {
        const container = document.getElementById('handRowsContainer');
        if (!container) return;
        
        const rowId = 'hand_row_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        handRowsData[rowId] = { selectedCards: {1:null, 2:null, 3:null, 4:null, 5:null} };
        
        const div = document.createElement('div');
        div.className = 'hand-row';
        div.id = rowId;
        div.style.borderBottom = '1px dashed #ccc';
        div.style.paddingBottom = '10px';
        div.style.marginBottom = '15px'; // slightly more space
        
        const serial = data ? data.serial : '';
        const teamName = data ? data.team : '';
        
        // If editing, populate selectedCards
        if (data && data.cards) {
            data.cards.forEach((c, idx) => {
                // Find card object from deck
                // c could be fullName like "â™ A" or short like "As" if imported? 
                // Usually stored as fullName in handHistory.
                const cardObj = deck.find(d => d.fullName === c || d.rankLabel + d.suit === c); 
                if (cardObj) handRowsData[rowId].selectedCards[idx+1] = cardObj;
            });
        }

        // Build options
        let serialOptions = '<option value="">åºå·</option>';
        let teamOptions = '<option value="">é˜Ÿä¼åç§°</option>';
        const sortedList = [...teamList].sort((a, b) => {
             const na = parseInt(a.serial);
             const nb = parseInt(b.serial);
             if (!isNaN(na) && !isNaN(nb)) return na - nb;
             return String(a.serial).localeCompare(String(b.serial));
        });
        sortedList.forEach(t => {
            serialOptions += `<option value="${t.serial}" ${t.serial == serial ? 'selected' : ''}>${t.serial}</option>`;
            teamOptions += `<option value="${t.name}" ${t.name == teamName ? 'selected' : ''}>${isImage(t.name) ? `åºå· ${t.serial} - [å›¾ç‰‡é˜Ÿä¼]` : t.name}</option>`;
        });

        // Build Card Selectors HTML
        let cardsHtml = '';
        for(let i=1; i<=5; i++) {
            const selectedCard = handRowsData[rowId].selectedCards[i];
            const triggerText = selectedCard 
                ? `<span class="card ${selectedCard.color === 'red' ? 'suit-red' : 'suit-black'}">${selectedCard.suit}${selectedCard.rankLabel}</span> â–¾` 
                : '... â–¾';
            const triggerClass = selectedCard ? 'card-select-trigger filled' : 'card-select-trigger';
            
            cardsHtml += `
                <div class="card-input-group" id="group_${rowId}_${i}">
                    <div class="card-label">ç‰Œ${i}</div>
                    <div class="card-select-trigger ${selectedCard ? 'filled' : ''}" onclick="toggleDropdown(${i}, '${rowId}')" id="trigger_${rowId}_${i}">${triggerText}</div>
                    <div class="dropdown-menu" id="dropdown_${rowId}_${i}">
                        <input type="text" class="search-box" placeholder="æŸ¥æ‰¾..." onkeyup="filterCards(${i}, '${rowId}')" onclick="event.stopPropagation()">
                        <div class="card-options-list" id="list_${rowId}_${i}"></div>
                    </div>
                </div>
            `;
        }

        div.innerHTML = `
            <div class="input-group" style="margin-bottom: 10px; width: 100%; display: flex; gap: 10px; align-items: center;">
                <select class="hand-serial" style="width: 120px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; background-color: white;" onchange="syncHandInput('${rowId}', 'serial')">
                    ${serialOptions}
                </select>
                <select class="hand-team" style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px; background-color: white;" onchange="syncHandInput('${rowId}', 'team')">
                    ${teamOptions}
                </select>
                <button onclick="removeHandRow('${rowId}')" class="btn-danger" style="padding: 5px 10px; font-size: 12px;">åˆ é™¤</button>
            </div>
            <div class="card-selectors" style="background: transparent; border: none; padding: 0; margin-bottom: 10px;">
                ${cardsHtml}
            </div>
        `;
        
        container.appendChild(div);
    }

    function removeHandRow(rowId) {
        const row = document.getElementById(rowId);
        if (row) row.remove();
        delete handRowsData[rowId];
    }
    
    function syncHandInput(rowId, source) {
        const row = document.getElementById(rowId);
        if (!row) return;
        const serialSelect = row.querySelector('.hand-serial');
        const teamSelect = row.querySelector('.hand-team');
        if (source === 'serial') {
            const team = teamList.find(t => t.serial === serialSelect.value);
            if (team) teamSelect.value = team.name; else teamSelect.value = "";
        } else {
            const team = teamList.find(t => t.name === teamSelect.value);
            if (team) serialSelect.value = team.serial; else serialSelect.value = "";
        }
    }

    function toggleDropdown(cardIndex, rowId) {
        const dropdown = document.getElementById(`dropdown_${rowId}_${cardIndex}`);
        const isVisible = dropdown.classList.contains('show');
        
        closeAllDropdowns(); // Closes all .dropdown-menu
        
        if (!isVisible) {
            dropdown.classList.add('show');
            const list = document.getElementById(`list_${rowId}_${cardIndex}`);
            if (list.children.length === 0) {
                 // Populate list on demand
                 list.innerHTML = '';
                 deck.forEach(card => {
                    const option = document.createElement('div');
                    option.className = 'card-option';
                    option.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span>`;
                    option.onclick = (e) => {
                        e.stopPropagation();
                        selectCard(cardIndex, card, rowId);
                    };
                    option.dataset.search = card.searchKey;
                    list.appendChild(option);
                 });
            }
            
            const input = dropdown.querySelector('.search-box');
            input.value = '';
            filterCards(cardIndex, rowId);
            setTimeout(() => input.focus(), 50);
        }
    }

    function selectCard(cardIndex, card, rowId) {
        handRowsData[rowId].selectedCards[cardIndex] = card;
        const trigger = document.getElementById(`trigger_${rowId}_${cardIndex}`);
        trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> â–¾`;
        trigger.classList.add('filled');
        closeAllDropdowns();
    }

    function filterCards(cardIndex, rowId) {
        const input = document.querySelector(`#dropdown_${rowId}_${cardIndex} .search-box`);
        const filter = input.value.toLowerCase();
        const list = document.getElementById(`list_${rowId}_${cardIndex}`);
        const options = list.getElementsByClassName('card-option');
        for (let option of options) {
            if (option.dataset.search.indexOf(filter) > -1) option.style.display = "";
            else option.style.display = "none";
        }
    }
    
    // Redefine closeAllDropdowns to work with new structure (already uses class .dropdown-menu, so it works)
    
    function processBatchHands() {
        if (!isAdmin) { alert('å½“å‰ä¸ºæ™®é€šç”¨æˆ·ï¼Œåªèƒ½æŸ¥çœ‹å’Œå¯¼å‡º'); return; }
        
        const rows = document.querySelectorAll('.hand-row');
        if (rows.length === 0) return;
        
        let newHands = [];
        let errors = [];
        
        rows.forEach((row, index) => {
            const rowId = row.id;
            const serial = row.querySelector('.hand-serial').value;
            const teamName = row.querySelector('.hand-team').value;
            
            // Check cards
            const rowCards = handRowsData[rowId].selectedCards;
            let cards = [];
            let missing = false;
            for(let i=1; i<=5; i++) {
                if(rowCards[i]) cards.push(rowCards[i]);
                else missing = true;
            }
            
            if (!serial && !teamName && missing) return; // Skip empty
            
            if (!serial || !teamName) {
                 errors.push(`ç¬¬ ${index+1} è¡Œï¼šè¯·é€‰æ‹©é˜Ÿä¼`);
                 return;
            }
            if (missing) {
                 errors.push(`ç¬¬ ${index+1} è¡Œï¼šè¯·é€‰æ‹©å®Œæ•´çš„5å¼ ç‰Œ`);
                 return;
            }
            
            // Validation
            // Check duplicates within this hand
            const uniqueCheck = new Set(cards.map(c => c.suit + c.rank));
            if (uniqueCheck.size !== 5) {
                errors.push(`ç¬¬ ${index+1} è¡Œï¼šç‰Œé¢é‡å¤`);
                return;
            }
            
            newHands.push({
                serial, team: teamName, cardsObjects: cards
            });
        });
        
        if (errors.length > 0) {
            alert(errors.join('\n'));
            return;
        }
        
        if (newHands.length === 0) {
             alert('æ²¡æœ‰æœ‰æ•ˆæ•°æ®');
             return;
        }

        snapshotRanks();
        insertRankSnapshot(currentEditingHandId ? 'single' : 'batch', 'hand', currentEditingHandId ? newHands[0].serial : 'batch', currentEditingHandId ? 'æ›´æ–°ç‰Œå‹' : 'æ‰¹é‡å½•å…¥ç‰Œå‹', { count: newHands.length });

        let processedHands = [];
        
        newHands.forEach(h => {
             const result = evaluateHand(h.cardsObjects); 
             const handObj = {
                 id: currentEditingHandId && newHands.length === 1 ? currentEditingHandId : `${currentYear}-${h.serial}`,
                 serial: h.serial,
                 team: h.team,
                 cards: h.cardsObjects, // This stores card objects
                 ...result
             };
             
             // Check if exists
             const index = handHistory.findIndex(ex => ex.serial === handObj.serial);
             if (index !== -1) {
                 handHistory[index] = handObj;
             } else {
                 handHistory.push(handObj);
             }
             processedHands.push(handObj);
        });
        
        handHistory.sort((a, b) => b.score - a.score);
        updateTable();
        upsertHands(processedHands);
        
        if (currentEditingHandId) {
            alert('æ›´æ–°æˆåŠŸ');
            cancelEdit();
        } else {
            alert(`æˆåŠŸä¿å­˜ ${newHands.length} æ¡ç‰Œå‹è®°å½•`);
            // Reset
            document.getElementById('handRowsContainer').innerHTML = '';
            handRowsData = {};
            addHandRow();
        }
    }
    
    function editEntry(id) {
        const hand = handHistory.find(h => h.id === id);
        if (!hand) return;
        
        currentEditingHandId = id;
        
        document.getElementById('handRowsContainer').innerHTML = '';
        handRowsData = {};
        
        addHandRow(hand); // hand has { serial, team, cards: [obj, obj...] }
        
        document.getElementById('actionBtn').textContent = 'æ›´æ–°ç‰Œå‹';
        document.getElementById('cancelBtn').style.display = 'inline-block';
        document.querySelector('.toolbar').scrollIntoView({ behavior: 'smooth' });
    }
    
    function cancelEdit() {
        currentEditingHandId = null;
        document.getElementById('handRowsContainer').innerHTML = '';
        handRowsData = {};
        addHandRow();
        
        document.getElementById('actionBtn').textContent = 'æ‰¹é‡è®¡ç®— & æ’å';
        document.getElementById('cancelBtn').style.display = 'none';
        document.getElementById('errorMsg').style.display = 'none';
    }
    
    function updateCalculatorDropdowns() {
        // Need to update batch rows options when teamList changes
        // Since rows are dynamic, we might need to re-render or update options in existing rows.
        // For simplicity, we can just find all select elements and update their options.
        
        const serialSelects = document.querySelectorAll('.hand-serial, .wish-serial');
        const teamSelects = document.querySelectorAll('.hand-team, .wish-team');
        
        // Build options HTML
        let serialOptions = '<option value="">åºå·</option>';
        let teamOptions = '<option value="">é˜Ÿä¼åç§°</option>';
        const sortedList = [...teamList].sort((a, b) => {
             const na = parseInt(a.serial);
             const nb = parseInt(b.serial);
             if (!isNaN(na) && !isNaN(nb)) return na - nb;
             return String(a.serial).localeCompare(String(b.serial));
        });
        sortedList.forEach(t => {
            serialOptions += `<option value="${t.serial}">${t.serial}</option>`;
            teamOptions += `<option value="${t.name}">${isImage(t.name) ? `åºå· ${t.serial} - [å›¾ç‰‡é˜Ÿä¼]` : t.name}</option>`;
        });

        serialSelects.forEach(sel => {
            const val = sel.value;
            sel.innerHTML = serialOptions;
            sel.value = val;
        });
        teamSelects.forEach(sel => {
            const val = sel.value;
            sel.innerHTML = teamOptions;
            sel.value = val;
        });
    }

    // Initialize first row
    setTimeout(addHandRow, 1000);
    
    // --- Cleanup/Overrides for old functions ---
    function renderDropdowns() {}
    function renderWishDropdowns() {}
    
    // å¯åŠ¨
    init();
</script>

</body>
</html>
