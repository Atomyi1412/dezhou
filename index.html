<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>德州扑克牌型计算器</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 900px;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        /* Card Selector Styles */
        .card-selectors {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .card-input-group {
            display: flex;
            flex-direction: column;
            width: 120px;
            position: relative;
        }

        .card-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
            text-align: center;
        }

        .card-select-trigger {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 42px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .card-select-trigger:hover {
            border-color: #007bff;
        }

        .card-select-trigger.filled {
            background-color: #e3f2fd;
            border-color: #90caf9;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            width: 200px;
            max-height: 300px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            display: none;
            overflow-y: auto;
            padding: 5px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .search-box {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #eee;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .card-option {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s;
        }

        .card-option:hover {
            background-color: #f5f5f5;
        }

        .card-option.selected {
            background-color: #e3f2fd;
        }
        
        .action-area {
            text-align: center;
            margin: 20px 0;
        }

        button {
            padding: 12px 40px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        .card {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-right: 4px;
            background: #fff;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .suit-red { color: #d9534f; }
        .suit-black { color: #292b2c; }
        .error-msg {
            color: #d9534f;
            margin-top: 10px;
            display: none;
            text-align: center;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>德州扑克牌型计算器</h1>
    
    <div class="input-group" style="margin-bottom: 10px; width: 100%; display: flex; gap: 10px;">
        <input type="text" id="serialInput" placeholder="序号 (例如: 1)" style="width: 100px; padding: 12px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px;">
        <input type="text" id="teamInput" placeholder="队伍名称" style="flex: 1; padding: 12px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px;">
    </div>
    
    <div class="input-group" style="margin-bottom: 20px; width: 100%; display: flex; gap: 10px;">
        <input type="text" id="cardInput" placeholder="输入5张牌 (例如: ♠A ♥K ♣Q ♦J ♠10 或 As Kh Qc Jd Ts)" style="flex: 1; padding: 12px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px;">
    </div>

    <div class="card-selectors">
        <!-- Generate 5 card inputs -->
        <div class="card-input-group" id="group1">
            <div class="card-label">牌1</div>
            <div class="card-select-trigger" onclick="toggleDropdown(1)" id="trigger1">... ▾</div>
            <div class="dropdown-menu" id="dropdown1">
                <input type="text" class="search-box" placeholder="查找..." onkeyup="filterCards(1)" onclick="event.stopPropagation()">
                <div class="card-options-list" id="list1"></div>
            </div>
        </div>
        <div class="card-input-group" id="group2">
            <div class="card-label">牌2</div>
            <div class="card-select-trigger" onclick="toggleDropdown(2)" id="trigger2">... ▾</div>
            <div class="dropdown-menu" id="dropdown2">
                <input type="text" class="search-box" placeholder="查找..." onkeyup="filterCards(2)" onclick="event.stopPropagation()">
                <div class="card-options-list" id="list2"></div>
            </div>
        </div>
        <div class="card-input-group" id="group3">
            <div class="card-label">牌3</div>
            <div class="card-select-trigger" onclick="toggleDropdown(3)" id="trigger3">... ▾</div>
            <div class="dropdown-menu" id="dropdown3">
                <input type="text" class="search-box" placeholder="查找..." onkeyup="filterCards(3)" onclick="event.stopPropagation()">
                <div class="card-options-list" id="list3"></div>
            </div>
        </div>
        <div class="card-input-group" id="group4">
            <div class="card-label">牌4</div>
            <div class="card-select-trigger" onclick="toggleDropdown(4)" id="trigger4">... ▾</div>
            <div class="dropdown-menu" id="dropdown4">
                <input type="text" class="search-box" placeholder="查找..." onkeyup="filterCards(4)" onclick="event.stopPropagation()">
                <div class="card-options-list" id="list4"></div>
            </div>
        </div>
        <div class="card-input-group" id="group5">
            <div class="card-label">牌5</div>
            <div class="card-select-trigger" onclick="toggleDropdown(5)" id="trigger5">... ▾</div>
            <div class="dropdown-menu" id="dropdown5">
                <input type="text" class="search-box" placeholder="查找..." onkeyup="filterCards(5)" onclick="event.stopPropagation()">
                <div class="card-options-list" id="list5"></div>
            </div>
        </div>
    </div>

    <div class="action-area">
        <button id="actionBtn" onclick="processHand()">计算 & 排名</button>
        <button id="cancelBtn" onclick="cancelEdit()" style="display:none; background-color: #6c757d; margin-left: 10px;">取消</button>
    </div>

    <div id="errorMsg" class="error-msg"></div>

    <details style="margin-bottom: 10px; border: 1px solid #ddd; border-radius: 5px; padding: 10px; background: #f9f9f9;">
        <summary style="cursor: pointer; font-weight: bold; color: #007bff;">设置</summary>
        <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px;">
            <label for="totalTeamsInput">报名队伍总数:</label>
            <input type="number" id="totalTeamsInput" value="50" min="1" style="padding: 5px; border: 1px solid #ccc; border-radius: 3px; width: 80px;" onchange="updateTotalTeams()">
            <span style="color: #666; font-size: 12px;">(用于计算积分，第1名获得此分数)</span>
        </div>
    </details>

    <details style="margin-bottom: 20px; border: 1px solid #ddd; border-radius: 5px; padding: 10px; background: #f9f9f9;">
        <summary style="cursor: pointer; font-weight: bold; color: #007bff;">批量导入 (Excel/CSV)</summary>
        <div style="margin-top: 10px;">
            <div style="margin-bottom: 10px; padding: 10px; background: #fff; border: 1px dashed #ccc; border-radius: 5px;">
                <p style="margin: 0 0 5px 0; font-size: 14px; font-weight: bold;">上传文件导入:</p>
                <input type="file" id="fileInput" accept=".xlsx, .xls, .csv" onchange="handleFileUpload(event)" style="width: 100%;">
            </div>

            <p style="font-size: 14px; color: #666; margin-bottom: 5px;">或粘贴内容 (格式: 序号 | 队伍名称 | 牌面)</p>
            <textarea id="bulkInput" rows="5" style="width: 100%; padding: 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 5px;" placeholder="例如:
1	TeamA	♠A ♥K ♣Q ♦J ♠10
2	TeamB	As Ks Qs Js Ts"></textarea>
            <div style="margin-top: 10px; text-align: right;">
                <button onclick="processBulkImport()" style="background-color: #28a745; padding: 8px 20px;">批量导入</button>
            </div>
        </div>
    </details>

    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
        <h2 style="margin: 0;">排行榜</h2>
        <div>
            <button onclick="exportRanking()" style="background-color: #17a2b8; padding: 8px 20px; font-size: 14px; margin-right: 10px;">导出表格</button>
            <button onclick="clearData()" style="background-color: #dc3545; padding: 8px 20px; font-size: 14px;">清空数据</button>
        </div>
    </div>
    <table id="rankingTable">
        <thead>
            <tr>
                <th>排名</th>
                <th>序号</th>
                <th>队伍名称</th>
                <th>牌型名称</th>
                <th>牌面</th>
                <th>积分</th>
                <th>分数</th>
                <th>操作</th>
            </tr>
        </thead>
        <tbody>
            <!-- 结果将插入这里 -->
        </tbody>
    </table>
</div>

<script>
    // 牌面定义
    const SUITS = {
        's': '♠', 'S': '♠', '♠': '♠',
        'h': '♥', 'H': '♥', '♥': '♥',
        'c': '♣', 'C': '♣', '♣': '♣',
        'd': '♦', 'D': '♦', '♦': '♦'
    };
    
    const RANKS = {
        '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
        'T': 10, 't': 10,
        'J': 11, 'j': 11,
        'Q': 12, 'q': 12,
        'K': 13, 'k': 13,
        'A': 14, 'a': 14
    };

    const RANK_NAMES = {
        2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '10',
        11: 'J', 12: 'Q', 13: 'K', 14: 'A'
    };

    const HAND_TYPES = [
        { name: "高牌", value: 1 },
        { name: "对子", value: 2 },
        { name: "两对", value: 3 },
        { name: "三条", value: 4 },
        { name: "顺子", value: 5 },
        { name: "同花", value: 6 },
        { name: "葫芦", value: 7 },
        { name: "四条", value: 8 },
        { name: "同花顺", value: 9 },
        { name: "皇家同花顺", value: 10 }
    ];
    
    // 全局状态：保存每个位置选中的牌
    // 格式: { 1: { suit: '♠', rank: 14, name: '♠A' }, ... }
    let selectedCards = {
        1: null, 2: null, 3: null, 4: null, 5: null
    };
    
    let deck = [];
    let totalTeams = 50;

    function updateTotalTeams() {
        const input = document.getElementById('totalTeamsInput');
        const val = parseInt(input.value);
        if (!isNaN(val) && val > 0) {
            totalTeams = val;
            updateTable();
        }
    }

    // 初始化
    function init() {
        generateDeck();
        renderDropdowns();
        
        // 点击外部关闭下拉菜单
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.card-input-group')) {
                closeAllDropdowns();
            }
        });
    }

    function generateDeck() {
        const suits = [
            { symbol: '♠', color: 'black', name: 'Spade', chinese: '黑桃', short: 's' },
            { symbol: '♥', color: 'red', name: 'Heart', chinese: '红桃', short: 'h' },
            { symbol: '♣', color: 'black', name: 'Club', chinese: '梅花', short: 'c' },
            { symbol: '♦', color: 'red', name: 'Diamond', chinese: '方块', short: 'd' }
        ];
        const ranks = [
            { val: 2, label: '2' }, { val: 3, label: '3' }, { val: 4, label: '4' }, 
            { val: 5, label: '5' }, { val: 6, label: '6' }, { val: 7, label: '7' }, 
            { val: 8, label: '8' }, { val: 9, label: '9' }, { val: 10, label: '10', alias: 't' },
            { val: 11, label: 'J' }, { val: 12, label: 'Q' }, { val: 13, label: 'K' }, { val: 14, label: 'A', alias: '1' }
        ];

        deck = [];
        for (let s of suits) {
            for (let r of ranks) {
                // 构建搜索关键词
                // 移除英文全称(Spade, Heart...)，因为它们包含 'a' 会导致搜索 'A' 时匹配所有牌
                // 保留: 符号(♠), 点数(A), 中文(黑桃), 简写(s), 别名(t, 1)
                let keys = [
                    `${s.symbol}${r.label}`, // ♠A
                    r.label,                 // A
                    s.chinese,               // 黑桃
                    s.short,                 // s
                    s.short + r.label,       // sA
                    r.label + s.short        // As
                ];
                if (r.alias) keys.push(r.alias);

                deck.push({
                    suit: s.symbol,
                    rank: r.val,
                    rankLabel: r.label,
                    color: s.color,
                    fullName: `${s.symbol}${r.label}`,
                    searchKey: keys.join(' ').toLowerCase()
                });
            }
        }
    }

    function renderDropdowns() {
        for (let i = 1; i <= 5; i++) {
            const list = document.getElementById(`list${i}`);
            list.innerHTML = '';
            deck.forEach(card => {
                const option = document.createElement('div');
                option.className = 'card-option';
                option.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span>`;
                option.onclick = (e) => {
                    e.stopPropagation();
                    selectCard(i, card);
                };
                // Store card data for filtering
                option.dataset.search = card.searchKey;
                list.appendChild(option);
            });
        }
    }

    function toggleDropdown(index) {
        const dropdown = document.getElementById(`dropdown${index}`);
        const isVisible = dropdown.classList.contains('show');
        
        closeAllDropdowns();
        
        if (!isVisible) {
            dropdown.classList.add('show');
            // Focus search box
            const input = dropdown.querySelector('.search-box');
            input.value = '';
            filterCards(index); // Reset filter
            setTimeout(() => input.focus(), 50);
        }
    }

    function closeAllDropdowns() {
        document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.remove('show'));
    }

    function selectCard(index, card) {
        selectedCards[index] = card;
        
        // Update trigger UI
        const trigger = document.getElementById(`trigger${index}`);
        trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> ▾`;
        trigger.classList.add('filled');
        
        closeAllDropdowns();
        updateTextInput();
    }

    function updateTextInput() {
        const parts = [];
        for (let i = 1; i <= 5; i++) {
            if (selectedCards[i]) {
                parts.push(selectedCards[i].fullName); // Use fullName (e.g., ♠A)
            }
        }
        // Only update if text input is empty or we are syncing from valid dropdowns
        // Actually, better to always sync to show what is selected
        document.getElementById('cardInput').value = parts.join(' ');
    }

    function filterCards(index) {
        const input = document.querySelector(`#dropdown${index} .search-box`);
        const filter = input.value.toLowerCase();
        const list = document.getElementById(`list${index}`);
        const options = list.getElementsByClassName('card-option');

        for (let option of options) {
            const txtValue = option.dataset.search;
            if (txtValue.indexOf(filter) > -1) {
                option.style.display = "";
            } else {
                option.style.display = "none";
            }
        }
    }

    let handHistory = [];
    let currentEditingId = null;

    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        
        if (file.name.endsWith('.csv')) {
            reader.onload = function(e) {
                const text = e.target.result;
                document.getElementById('bulkInput').value = text;
                processBulkImport();
            };
            reader.readAsText(file);
        } else {
            // Excel
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    
                    // Convert to JSON (array of arrays) to be safe
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                    
                    // Convert to Tab Separated Values for our existing parser
                    // Replace newlines in cell data with space to prevent line breaking
                    const tsv = jsonData.map(row => 
                        row.map(cell => {
                            if (typeof cell === 'string') {
                                return cell.replace(/[\n\r]+/g, ' ');
                            }
                            return cell;
                        }).join('\t')
                    ).join('\n');
                    
                    document.getElementById('bulkInput').value = tsv;
                    processBulkImport();
                } catch (err) {
                    alert('读取Excel文件失败: ' + err.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Reset file input so same file can be selected again if needed
        event.target.value = '';
    }

    function processBulkImport() {
        const input = document.getElementById('bulkInput').value.trim();
        if (!input) return;

        // Use a smarter split that respects quotes (standard CSV/TSV behavior) to handle multi-line fields in copy-paste scenarios
        // Regex: Split by newline if not followed by an odd number of quotes
        // But JS doesn't support variable length lookbehind, so we use lookahead for even quotes until end of string.
        // Actually, simple strategy: if a line has unclosed quote, merge with next.
        
        let rawLines = input.split(/\r?\n/);
        const lines = [];
        let currentLine = '';
        let inQuote = false;
        
        for (let line of rawLines) {
            // Count quotes in this line
            const quotes = (line.match(/"/g) || []).length;
            
            if (!inQuote) {
                if (quotes % 2 === 0) {
                    // Balanced, simple line
                    lines.push(line);
                } else {
                    // Unbalanced, start of multi-line
                    currentLine = line;
                    inQuote = true;
                }
            } else {
                currentLine += '\n' + line; // Restore newline
                if (quotes % 2 !== 0) {
                    // Found closing quote (odd number of quotes + previous odd = even)
                    lines.push(currentLine);
                    currentLine = '';
                    inQuote = false;
                }
                // If even quotes, we are still inside multiline quote
            }
        }
        if (currentLine) lines.push(currentLine); // Push remaining if any

        let successCount = 0;
        let errors = [];

        lines.forEach((line, index) => {
            line = line.trim();
            if (!line) return;
            
            // Handle CSV/TSV parsing manually to respect quotes
            let parts = [];
            
            if (line.includes('\t')) {
                // TSV - usually simpler, but let's respect quotes if present
                // Simple split is often enough for TSV unless tab is in value (rare)
                parts = line.split('\t');
            } else {
                // CSV - need to respect quotes for commas
                // Regex to match fields: "..." or non-comma
                // Note: This is a simplified CSV parser
                const matches = line.match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g); 
                // Actually, let's fallback to simple split if no quotes
                if (line.indexOf('"') === -1) {
                    parts = line.split(/[,，]/);
                } else {
                    // Regex for CSV split ignoring commas in quotes
                    // pattern:  ( " [^"]* " | [^,]+ )
                    const re = /(".*?"|[^,]+)(?=\s*,|\s*$)/g;
                    // This is hard to get right with regex globally.
                    // Let's iterate chars or use a simple state machine if we really want to support complex CSV paste.
                    // Given the context, if it has quotes, it's likely from Excel copy-paste which is TSV usually.
                    // If comma separated, likely manual entry.
                    
                    // Let's just try simple split first. If it fails, maybe user pasted weirdly.
                    parts = line.split(/[,，]/);
                }
            }

            // Clean up parts (remove surrounding quotes)
            parts = parts.map(p => {
                p = p.trim();
                if (p.startsWith('"') && p.endsWith('"')) {
                    p = p.slice(1, -1).replace(/""/g, '"'); // Unescape double quotes
                }
                return p;
            });

            // Clean up newlines in values (e.g. team name with newline)
            parts = parts.map(p => p.replace(/[\n\r]+/g, ' '));
            
            if (parts.length < 3) {
                 // Try to recover if cards are space separated and were split by comma?
                 // No, parts logic above handles separators.
                 // Maybe the regex failed.
            }
            
            if (parts.length < 3) {
                errors.push(`第 ${index+1} 行格式错误: 需包含 序号, 队伍名称, 牌面`);
                return;
            }

            const serial = parts[0];
            const team = parts[1];
            
            // Cards might be spread across remaining parts if delimiters were mixed
            let cardsStr = parts.slice(2).join(' ');

            try {
                const cards = parseCards(cardsStr);
                const result = evaluateHand(cards);
                
                handHistory.push({
                    id: Date.now().toString() + Math.random(), // Ensure unique ID
                    cards: cards,
                    serial: serial,
                    team: team,
                    ...result
                });
                successCount++;
            } catch (e) {
                errors.push(`第 ${index+1} 行 (${team}) 错误: ${e.message}`);
            }
        });

        // Re-sort and update table
        handHistory.sort((a, b) => b.score - a.score);
        updateTable();
        
        // Show result
        if (errors.length > 0) {
            alert(`导入完成: ${successCount} 成功\n\n错误:\n${errors.join('\n')}`);
        } else {
            alert(`成功导入 ${successCount} 条数据`);
            document.getElementById('bulkInput').value = '';
            // Close details
            document.querySelector('details').removeAttribute('open');
        }
    }

    function processHand() {
        const errorMsg = document.getElementById('errorMsg');
        const inputVal = document.getElementById('cardInput').value.trim();
        const serialVal = document.getElementById('serialInput').value.trim();
        const teamVal = document.getElementById('teamInput').value.trim();
        
        errorMsg.style.display = 'none';

        try {
            if (!serialVal) throw new Error("请输入序号");
            if (!teamVal) throw new Error("请输入队伍名称");

            let currentHand = [];

            // Strategy: 
            // 1. If text input has changed manually (we can't easily detect "manual" vs "auto" here without more state),
            //    let's try to parse text first if it looks valid.
            // 2. Or, just parse text input always if it's not empty. 
            //    Since selectCard updates text input, text input should be the source of truth if populated.
            
            if (inputVal) {
                currentHand = parseCards(inputVal);
                // Sync back to UI (dropdowns)
                currentHand.forEach((card, i) => {
                    // We need to find this card in our deck to get the exact object ref if possible, 
                    // or just use the object returned by parseCards (which should be from deck)
                    // parseCards now returns objects from deck.
                    selectedCards[i+1] = card;
                    
                    // Update trigger UI manually
                    const trigger = document.getElementById(`trigger${i+1}`);
                    trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> ▾`;
                    trigger.classList.add('filled');
                });
                // Clear remaining slots if any (e.g. input had 3 cards) - actually parseCards throws if not 5
            } else {
                // Use dropdowns
                for (let i = 1; i <= 5; i++) {
                    if (!selectedCards[i]) {
                        throw new Error(`请选择第 ${i} 张牌`);
                    }
                    currentHand.push(selectedCards[i]);
                }
            }
            
            // Check duplicates
            const uniqueCheck = new Set(currentHand.map(c => c.suit + c.rank));
            if (uniqueCheck.size !== 5) {
                throw new Error("牌面重复，请检查");
            }
            
            const result = evaluateHand(currentHand);
            
            if (currentEditingId) {
                // Update existing
                const index = handHistory.findIndex(h => h.id === currentEditingId);
                if (index !== -1) {
                    handHistory[index] = {
                        ...handHistory[index],
                        cards: currentHand,
                        serial: serialVal,
                        team: teamVal,
                        ...result
                    };
                }
                cancelEdit(); // Reset UI
            } else {
                // Add new
                handHistory.push({
                    id: Date.now().toString(), // Simple unique ID
                    cards: currentHand,
                    serial: serialVal,
                    team: teamVal,
                    ...result
                });
            }

            // 排序：分数从高到低
            handHistory.sort((a, b) => b.score - a.score);

            updateTable();
            
            // Clear inputs if not editing (if editing, cancelEdit already cleared)
            if (!currentEditingId) {
                document.getElementById('cardInput').value = '';
                document.getElementById('serialInput').value = '';
                document.getElementById('teamInput').value = '';
                // Clear dropdowns
                for (let i = 1; i <= 5; i++) {
                     selectedCards[i] = null;
                     const trigger = document.getElementById(`trigger${i}`);
                     trigger.innerHTML = `... ▾`;
                     trigger.classList.remove('filled');
                }
            }
            
        } catch (e) {
            errorMsg.textContent = e.message;
            errorMsg.style.display = 'block';
        }
    }
    
    function parseCards(input) {
        // 正则表达式匹配所有可能的牌组合
        // Suits: ♠♥♣♦sShHcCdD
        // Ranks: 10, 2-9, tTjJqQkKaA, 1
        const suitRegex = "[♠♥♣♦sShHcCdD]";
        const rankRegex = "(?:10|[2-9]|[tTjJqQkKaA]|1)";
        
        // 模式1: 花色 + 点数 (例如: ♠A, s10)
        // 模式2: 点数 + 花色 (例如: As, 10s)
        const cardRegex = new RegExp(`(${suitRegex}${rankRegex})|(${rankRegex}${suitRegex})`, 'g');
        
        const parts = input.match(cardRegex) || [];
        
        if (parts.length !== 5) {
             throw new Error(`必须输入5张牌，当前识别到 ${parts.length} 张`);
        }

        const parsedCards = [];
        
        // Helper to find card in deck
        const findCard = (suitChar, rankStr) => {
             // Normalize suitChar to standard symbol or match deck properties
             // rankStr could be '10', 'A', 't', etc.
             
             // Map input suit to deck suit symbol
             const suitMap = {
                 's': '♠', 'S': '♠', '♠': '♠',
                 'h': '♥', 'H': '♥', '♥': '♥',
                 'c': '♣', 'C': '♣', '♣': '♣',
                 'd': '♦', 'D': '♦', '♦': '♦'
             };
             
             const targetSuit = suitMap[suitChar];
             if (!targetSuit) return null;

             // Map rank string to value/label
             const rankMap = {
                 '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
                 't': 10, 'T': 10,
                 'j': 11, 'J': 11,
                 'q': 12, 'Q': 12,
                 'k': 13, 'K': 13,
                 'a': 14, 'A': 14, '1': 14
             };
             const targetRankVal = rankMap[rankStr];
             if (!targetRankVal) return null;

             return deck.find(c => c.suit === targetSuit && c.rank === targetRankVal);
        };

        for (let part of parts) {
            let suitChar = '';
            let rankStr = '';
            
            // Regex: Suit first or Rank first
            // Suit: [♠♥♣♦sShHcCdD]
            // Rank: [2-9]|10|[tTjJqQkKaA]|1
            
            const matchPrefix = part.match(/^([♠♥♣♦sShHcCdD])([2-9]|10|[tTjJqQkKaA]|1)$/);
            const matchSuffix = part.match(/^([2-9]|10|[tTjJqQkKaA]|1)([♠♥♣♦sShHcCdD])$/);

            if (matchPrefix) {
                suitChar = matchPrefix[1];
                rankStr = matchPrefix[2];
            } else if (matchSuffix) {
                rankStr = matchSuffix[1];
                suitChar = matchSuffix[2];
            } else {
                throw new Error(`无法识别的牌: ${part}`);
            }

            const card = findCard(suitChar, rankStr);
            if (!card) {
                throw new Error(`无法识别的牌: ${part}`);
            }
            parsedCards.push(card);
        }
        return parsedCards;
    }

    function evaluateHand(cards) {
        // 排序牌面 (从大到小)
        const sortedCards = [...cards].sort((a, b) => b.rank - a.rank);
        const ranks = sortedCards.map(c => c.rank);
        const suits = sortedCards.map(c => c.suit);

        // 检查同花
        const isFlush = suits.every(s => s === suits[0]);

        // 检查顺子
        let isStraight = true;
        for (let i = 0; i < 4; i++) {
            if (ranks[i] - ranks[i+1] !== 1) {
                isStraight = false;
                break;
            }
        }
        // 特殊情况: A-5-4-3-2 (A=14, 2=2)
        // 此时 ranks 是 [14, 5, 4, 3, 2]
        if (!isStraight && ranks[0] === 14 && ranks[1] === 5 && ranks[2] === 4 && ranks[3] === 3 && ranks[4] === 2) {
            isStraight = true;
            // 为了比较大小，这里把它当作 5-high straight
            // 但是在分数计算时需要特殊处理，把A当作1来处理
        }

        // 统计点数频率
        const rankCounts = {};
        ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
        
        // 获取四条、三条、对子
        const counts = Object.values(rankCounts);
        const isFourOfAKind = counts.includes(4);
        const isThreeOfAKind = counts.includes(3);
        const pairCount = counts.filter(c => c === 2).length;

        let handTypeIndex = 0; // 0-9, 对应 HAND_TYPES 索引
        let score = 0;

        // 计算基础分数 (Base Score)
        // 每一级相差 1,000,000,000 (10^9) 保证级别压制
        // 级别内比较使用 HEX 类似思想: 
        // c1*16^4 + c2*16^3 + ...
        // 这里简单用 100进制

        const getKickersValue = (cardRanks) => {
            let val = 0;
            let power = 1;
            for (let i = cardRanks.length - 1; i >= 0; i--) {
                val += cardRanks[i] * power;
                power *= 100;
            }
            return val;
        };

        if (isFlush && isStraight) {
            if (ranks[0] === 14 && ranks[1] === 13) { // Royal Flush
                handTypeIndex = 9;
                score = 9 * 10000000000;
            } else { // Straight Flush
                handTypeIndex = 8;
                // 处理 A-5-4-3-2 的情况，此时最大牌是 5
                let highRank = ranks[0];
                if (ranks[0] === 14 && ranks[4] === 2) highRank = 5;
                score = 8 * 10000000000 + highRank;
            }
        } else if (isFourOfAKind) {
            handTypeIndex = 7;
            const quadRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 4));
            const kicker = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 1));
            score = 7 * 10000000000 + quadRank * 100 + kicker;
        } else if (isThreeOfAKind && pairCount === 1) { // Full House
            handTypeIndex = 6;
            const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
            const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
            score = 6 * 10000000000 + tripRank * 100 + pairRank;
        } else if (isFlush) {
            handTypeIndex = 5;
            score = 5 * 10000000000 + getKickersValue(ranks);
        } else if (isStraight) {
            handTypeIndex = 4;
            let highRank = ranks[0];
            if (ranks[0] === 14 && ranks[4] === 2) highRank = 5;
            score = 4 * 10000000000 + highRank;
        } else if (isThreeOfAKind) {
            handTypeIndex = 3;
            const tripRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 3));
            const kickers = ranks.filter(r => r !== tripRank);
            score = 3 * 10000000000 + tripRank * 10000 + getKickersValue(kickers);
        } else if (pairCount === 2) {
            handTypeIndex = 2;
            const pairs = Object.keys(rankCounts).filter(key => rankCounts[key] === 2).map(Number).sort((a,b) => b-a);
            const kicker = ranks.find(r => !pairs.includes(r));
            score = 2 * 10000000000 + pairs[0] * 10000 + pairs[1] * 100 + kicker;
        } else if (pairCount === 1) {
            handTypeIndex = 1;
            const pairRank = parseInt(Object.keys(rankCounts).find(key => rankCounts[key] === 2));
            const kickers = ranks.filter(r => r !== pairRank);
            score = 1 * 10000000000 + pairRank * 1000000 + getKickersValue(kickers);
        } else {
            handTypeIndex = 0;
            score = getKickersValue(ranks);
        }

        return {
            handTypeName: HAND_TYPES[handTypeIndex].name,
            score: score
        };
    }

    function editEntry(id) {
        const entry = handHistory.find(h => h.id === id);
        if (!entry) return;

        currentEditingId = id;
        
        // Populate inputs
        document.getElementById('serialInput').value = entry.serial;
        document.getElementById('teamInput').value = entry.team;
        
        // Populate cards
        entry.cards.forEach((card, i) => {
             selectedCards[i+1] = card;
             const trigger = document.getElementById(`trigger${i+1}`);
             trigger.innerHTML = `<span class="card ${card.color === 'red' ? 'suit-red' : 'suit-black'}">${card.suit}${card.rankLabel}</span> ▾`;
             trigger.classList.add('filled');
        });
        updateTextInput();

        // Update UI state
        document.getElementById('actionBtn').textContent = '更新';
        document.getElementById('actionBtn').style.backgroundColor = '#28a745';
        document.getElementById('cancelBtn').style.display = 'inline-block';
        
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function cancelEdit() {
        currentEditingId = null;
        
        // Clear inputs
        document.getElementById('serialInput').value = '';
        document.getElementById('teamInput').value = '';
        document.getElementById('cardInput').value = '';
        
        // Clear dropdowns
        for (let i = 1; i <= 5; i++) {
             selectedCards[i] = null;
             const trigger = document.getElementById(`trigger${i}`);
             trigger.innerHTML = `... ▾`;
             trigger.classList.remove('filled');
        }

        // Reset UI state
        document.getElementById('actionBtn').textContent = '计算 & 排名';
        document.getElementById('actionBtn').style.backgroundColor = '#007bff';
        document.getElementById('cancelBtn').style.display = 'none';
        document.getElementById('errorMsg').style.display = 'none';
    }

    function clearData() {
        if (confirm('确定要清空所有数据吗？此操作不可恢复。')) {
            handHistory = [];
            cancelEdit();
            updateTable();
        }
    }

    function updateTable() {
        const tbody = document.querySelector('#rankingTable tbody');
        tbody.innerHTML = '';

        let effectiveRank = 1;

        handHistory.forEach((entry, index) => {
            const tr = document.createElement('tr');
            
            // Determine effective rank (handle ties)
            if (index > 0 && entry.score === handHistory[index-1].score) {
                // Tie with previous: effectiveRank remains unchanged
            } else {
                // No tie: effectiveRank is the current position
                effectiveRank = index + 1;
            }

            // 排名
            const tdRank = document.createElement('td');
            tdRank.textContent = effectiveRank;
            tr.appendChild(tdRank);
            
            // 序号
            const tdSerial = document.createElement('td');
            tdSerial.textContent = entry.serial;
            tr.appendChild(tdSerial);
            
            // 队伍名称
            const tdTeam = document.createElement('td');
            tdTeam.textContent = entry.team;
            tr.appendChild(tdTeam);

            // 牌型名称
            const tdType = document.createElement('td');
            tdType.textContent = entry.handTypeName;
            tr.appendChild(tdType);

            // 牌面
            const tdCards = document.createElement('td');
            entry.cards.forEach(card => {
                const span = document.createElement('span');
                span.className = `card ${card.color === 'red' ? 'suit-red' : 'suit-black'}`;
                span.textContent = `${card.suit}${card.rankLabel}`;
                tdCards.appendChild(span);
            });
            tr.appendChild(tdCards);

            // 积分
            const tdPoints = document.createElement('td');
            // Points calculation based on effective rank
            // Rank 1 gets totalTeams points
            // Rank N gets totalTeams - N + 1 points
            const points = totalTeams - effectiveRank + 1;
            
            tdPoints.textContent = points;
            tdPoints.style.fontWeight = 'bold';
            tdPoints.style.color = points > 0 ? '#28a745' : '#dc3545';
            tr.appendChild(tdPoints);

            // 分数 (Debug用，也可以显示)
            const tdScore = document.createElement('td');
            tdScore.textContent = entry.score.toLocaleString();
            tr.appendChild(tdScore);
            
            // 操作
            const tdAction = document.createElement('td');
            const editBtn = document.createElement('button');
            editBtn.textContent = '编辑';
            editBtn.style.padding = '5px 10px';
            editBtn.style.fontSize = '12px';
            editBtn.onclick = () => editEntry(entry.id);
            tdAction.appendChild(editBtn);
            tr.appendChild(tdAction);

            tbody.appendChild(tr);
        });
    }

    function exportRanking() {
        if (handHistory.length === 0) {
            alert('没有数据可导出');
            return;
        }

        // Prepare data for export
        let effectiveRank = 1;
        const data = handHistory.map((entry, index) => {
            // Determine effective rank (handle ties)
            if (index > 0 && entry.score === handHistory[index-1].score) {
                // Tie: effectiveRank remains unchanged
            } else {
                effectiveRank = index + 1;
            }

            const points = totalTeams - effectiveRank + 1;
            
            // 格式化牌面字符串，移除颜色标记，纯文本
            const cardStr = entry.cards.map(c => `${c.suit}${c.rankLabel}`).join(' ');
            
            return {
                "排名": effectiveRank,
                "序号": entry.serial,
                "队伍名称": entry.team,
                "牌型名称": entry.handTypeName,
                "牌面": cardStr,
                "积分": points,
                "分数": entry.score
            };
        });

        // Create worksheet
        const ws = XLSX.utils.json_to_sheet(data);
        
        // Adjust column widths
        const wscols = [
            {wch: 6},  // 排名
            {wch: 10}, // 序号
            {wch: 20}, // 队伍名称
            {wch: 20}, // 牌型名称
            {wch: 25}, // 牌面
            {wch: 8},  // 积分
            {wch: 15}  // 分数
        ];
        ws['!cols'] = wscols;

        // Create workbook
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "排行榜");

        // Generate filename with timestamp
        const date = new Date();
        const dateStr = `${date.getFullYear()}${(date.getMonth()+1).toString().padStart(2,'0')}${date.getDate().toString().padStart(2,'0')}`;
        const timeStr = `${date.getHours().toString().padStart(2,'0')}${date.getMinutes().toString().padStart(2,'0')}`;
        const filename = `德州扑克排行榜_${dateStr}_${timeStr}.xlsx`;

        // Export
        try {
            XLSX.writeFile(wb, filename);
        } catch (e) {
            alert('导出失败: ' + e.message);
        }
    }

    // 启动
    init();
</script>

</body>
</html>
